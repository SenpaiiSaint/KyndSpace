
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Verification
 * 
 */
export type Verification = $Result.DefaultSelection<Prisma.$VerificationPayload>
/**
 * Model JournalEntry
 * 
 */
export type JournalEntry = $Result.DefaultSelection<Prisma.$JournalEntryPayload>
/**
 * Model Habit
 * 
 */
export type Habit = $Result.DefaultSelection<Prisma.$HabitPayload>
/**
 * Model Class
 * 
 */
export type Class = $Result.DefaultSelection<Prisma.$ClassPayload>
/**
 * Model Booking
 * 
 */
export type Booking = $Result.DefaultSelection<Prisma.$BookingPayload>
/**
 * Model BiometricData
 * 
 */
export type BiometricData = $Result.DefaultSelection<Prisma.$BiometricDataPayload>
/**
 * Model MoodEntry
 * 
 */
export type MoodEntry = $Result.DefaultSelection<Prisma.$MoodEntryPayload>
/**
 * Model StressPrediction
 * 
 */
export type StressPrediction = $Result.DefaultSelection<Prisma.$StressPredictionPayload>
/**
 * Model WellnessChallenge
 * 
 */
export type WellnessChallenge = $Result.DefaultSelection<Prisma.$WellnessChallengePayload>
/**
 * Model ChallengeParticipant
 * 
 */
export type ChallengeParticipant = $Result.DefaultSelection<Prisma.$ChallengeParticipantPayload>
/**
 * Model AIRecommendation
 * 
 */
export type AIRecommendation = $Result.DefaultSelection<Prisma.$AIRecommendationPayload>
/**
 * Model DeviceConnection
 * 
 */
export type DeviceConnection = $Result.DefaultSelection<Prisma.$DeviceConnectionPayload>
/**
 * Model WellnessSession
 * 
 */
export type WellnessSession = $Result.DefaultSelection<Prisma.$WellnessSessionPayload>
/**
 * Model EnvironmentalData
 * 
 */
export type EnvironmentalData = $Result.DefaultSelection<Prisma.$EnvironmentalDataPayload>
/**
 * Model WellnessGroup
 * 
 */
export type WellnessGroup = $Result.DefaultSelection<Prisma.$WellnessGroupPayload>
/**
 * Model GroupMembership
 * 
 */
export type GroupMembership = $Result.DefaultSelection<Prisma.$GroupMembershipPayload>
/**
 * Model WorkplaceIntegration
 * 
 */
export type WorkplaceIntegration = $Result.DefaultSelection<Prisma.$WorkplaceIntegrationPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verification`: Exposes CRUD operations for the **Verification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Verifications
    * const verifications = await prisma.verification.findMany()
    * ```
    */
  get verification(): Prisma.VerificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.journalEntry`: Exposes CRUD operations for the **JournalEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JournalEntries
    * const journalEntries = await prisma.journalEntry.findMany()
    * ```
    */
  get journalEntry(): Prisma.JournalEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.habit`: Exposes CRUD operations for the **Habit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Habits
    * const habits = await prisma.habit.findMany()
    * ```
    */
  get habit(): Prisma.HabitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.class`: Exposes CRUD operations for the **Class** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Classes
    * const classes = await prisma.class.findMany()
    * ```
    */
  get class(): Prisma.ClassDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.booking`: Exposes CRUD operations for the **Booking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookings
    * const bookings = await prisma.booking.findMany()
    * ```
    */
  get booking(): Prisma.BookingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.biometricData`: Exposes CRUD operations for the **BiometricData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BiometricData
    * const biometricData = await prisma.biometricData.findMany()
    * ```
    */
  get biometricData(): Prisma.BiometricDataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.moodEntry`: Exposes CRUD operations for the **MoodEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MoodEntries
    * const moodEntries = await prisma.moodEntry.findMany()
    * ```
    */
  get moodEntry(): Prisma.MoodEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stressPrediction`: Exposes CRUD operations for the **StressPrediction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StressPredictions
    * const stressPredictions = await prisma.stressPrediction.findMany()
    * ```
    */
  get stressPrediction(): Prisma.StressPredictionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wellnessChallenge`: Exposes CRUD operations for the **WellnessChallenge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WellnessChallenges
    * const wellnessChallenges = await prisma.wellnessChallenge.findMany()
    * ```
    */
  get wellnessChallenge(): Prisma.WellnessChallengeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.challengeParticipant`: Exposes CRUD operations for the **ChallengeParticipant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChallengeParticipants
    * const challengeParticipants = await prisma.challengeParticipant.findMany()
    * ```
    */
  get challengeParticipant(): Prisma.ChallengeParticipantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIRecommendation`: Exposes CRUD operations for the **AIRecommendation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIRecommendations
    * const aIRecommendations = await prisma.aIRecommendation.findMany()
    * ```
    */
  get aIRecommendation(): Prisma.AIRecommendationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deviceConnection`: Exposes CRUD operations for the **DeviceConnection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeviceConnections
    * const deviceConnections = await prisma.deviceConnection.findMany()
    * ```
    */
  get deviceConnection(): Prisma.DeviceConnectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wellnessSession`: Exposes CRUD operations for the **WellnessSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WellnessSessions
    * const wellnessSessions = await prisma.wellnessSession.findMany()
    * ```
    */
  get wellnessSession(): Prisma.WellnessSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.environmentalData`: Exposes CRUD operations for the **EnvironmentalData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EnvironmentalData
    * const environmentalData = await prisma.environmentalData.findMany()
    * ```
    */
  get environmentalData(): Prisma.EnvironmentalDataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wellnessGroup`: Exposes CRUD operations for the **WellnessGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WellnessGroups
    * const wellnessGroups = await prisma.wellnessGroup.findMany()
    * ```
    */
  get wellnessGroup(): Prisma.WellnessGroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.groupMembership`: Exposes CRUD operations for the **GroupMembership** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GroupMemberships
    * const groupMemberships = await prisma.groupMembership.findMany()
    * ```
    */
  get groupMembership(): Prisma.GroupMembershipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workplaceIntegration`: Exposes CRUD operations for the **WorkplaceIntegration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkplaceIntegrations
    * const workplaceIntegrations = await prisma.workplaceIntegration.findMany()
    * ```
    */
  get workplaceIntegration(): Prisma.WorkplaceIntegrationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.8.2
   * Query Engine version: 2060c79ba17c6bb9f5823312b6f6b7f4a845738e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Session: 'Session',
    Account: 'Account',
    Verification: 'Verification',
    JournalEntry: 'JournalEntry',
    Habit: 'Habit',
    Class: 'Class',
    Booking: 'Booking',
    BiometricData: 'BiometricData',
    MoodEntry: 'MoodEntry',
    StressPrediction: 'StressPrediction',
    WellnessChallenge: 'WellnessChallenge',
    ChallengeParticipant: 'ChallengeParticipant',
    AIRecommendation: 'AIRecommendation',
    DeviceConnection: 'DeviceConnection',
    WellnessSession: 'WellnessSession',
    EnvironmentalData: 'EnvironmentalData',
    WellnessGroup: 'WellnessGroup',
    GroupMembership: 'GroupMembership',
    WorkplaceIntegration: 'WorkplaceIntegration'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "session" | "account" | "verification" | "journalEntry" | "habit" | "class" | "booking" | "biometricData" | "moodEntry" | "stressPrediction" | "wellnessChallenge" | "challengeParticipant" | "aIRecommendation" | "deviceConnection" | "wellnessSession" | "environmentalData" | "wellnessGroup" | "groupMembership" | "workplaceIntegration"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Verification: {
        payload: Prisma.$VerificationPayload<ExtArgs>
        fields: Prisma.VerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findFirst: {
            args: Prisma.VerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findMany: {
            args: Prisma.VerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          create: {
            args: Prisma.VerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          createMany: {
            args: Prisma.VerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          delete: {
            args: Prisma.VerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          update: {
            args: Prisma.VerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          deleteMany: {
            args: Prisma.VerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          upsert: {
            args: Prisma.VerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          aggregate: {
            args: Prisma.VerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerification>
          }
          groupBy: {
            args: Prisma.VerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationCountAggregateOutputType> | number
          }
        }
      }
      JournalEntry: {
        payload: Prisma.$JournalEntryPayload<ExtArgs>
        fields: Prisma.JournalEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JournalEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JournalEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>
          }
          findFirst: {
            args: Prisma.JournalEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JournalEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>
          }
          findMany: {
            args: Prisma.JournalEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>[]
          }
          create: {
            args: Prisma.JournalEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>
          }
          createMany: {
            args: Prisma.JournalEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JournalEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>[]
          }
          delete: {
            args: Prisma.JournalEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>
          }
          update: {
            args: Prisma.JournalEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>
          }
          deleteMany: {
            args: Prisma.JournalEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JournalEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JournalEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>[]
          }
          upsert: {
            args: Prisma.JournalEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>
          }
          aggregate: {
            args: Prisma.JournalEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJournalEntry>
          }
          groupBy: {
            args: Prisma.JournalEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<JournalEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.JournalEntryCountArgs<ExtArgs>
            result: $Utils.Optional<JournalEntryCountAggregateOutputType> | number
          }
        }
      }
      Habit: {
        payload: Prisma.$HabitPayload<ExtArgs>
        fields: Prisma.HabitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HabitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HabitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitPayload>
          }
          findFirst: {
            args: Prisma.HabitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HabitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitPayload>
          }
          findMany: {
            args: Prisma.HabitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitPayload>[]
          }
          create: {
            args: Prisma.HabitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitPayload>
          }
          createMany: {
            args: Prisma.HabitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HabitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitPayload>[]
          }
          delete: {
            args: Prisma.HabitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitPayload>
          }
          update: {
            args: Prisma.HabitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitPayload>
          }
          deleteMany: {
            args: Prisma.HabitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HabitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HabitUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitPayload>[]
          }
          upsert: {
            args: Prisma.HabitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitPayload>
          }
          aggregate: {
            args: Prisma.HabitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHabit>
          }
          groupBy: {
            args: Prisma.HabitGroupByArgs<ExtArgs>
            result: $Utils.Optional<HabitGroupByOutputType>[]
          }
          count: {
            args: Prisma.HabitCountArgs<ExtArgs>
            result: $Utils.Optional<HabitCountAggregateOutputType> | number
          }
        }
      }
      Class: {
        payload: Prisma.$ClassPayload<ExtArgs>
        fields: Prisma.ClassFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          findFirst: {
            args: Prisma.ClassFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          findMany: {
            args: Prisma.ClassFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          create: {
            args: Prisma.ClassCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          createMany: {
            args: Prisma.ClassCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClassCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          delete: {
            args: Prisma.ClassDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          update: {
            args: Prisma.ClassUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          deleteMany: {
            args: Prisma.ClassDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClassUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          upsert: {
            args: Prisma.ClassUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          aggregate: {
            args: Prisma.ClassAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClass>
          }
          groupBy: {
            args: Prisma.ClassGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassCountArgs<ExtArgs>
            result: $Utils.Optional<ClassCountAggregateOutputType> | number
          }
        }
      }
      Booking: {
        payload: Prisma.$BookingPayload<ExtArgs>
        fields: Prisma.BookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findFirst: {
            args: Prisma.BookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findMany: {
            args: Prisma.BookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          create: {
            args: Prisma.BookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          createMany: {
            args: Prisma.BookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          delete: {
            args: Prisma.BookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          update: {
            args: Prisma.BookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          deleteMany: {
            args: Prisma.BookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          upsert: {
            args: Prisma.BookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          aggregate: {
            args: Prisma.BookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBooking>
          }
          groupBy: {
            args: Prisma.BookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingCountArgs<ExtArgs>
            result: $Utils.Optional<BookingCountAggregateOutputType> | number
          }
        }
      }
      BiometricData: {
        payload: Prisma.$BiometricDataPayload<ExtArgs>
        fields: Prisma.BiometricDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BiometricDataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiometricDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BiometricDataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiometricDataPayload>
          }
          findFirst: {
            args: Prisma.BiometricDataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiometricDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BiometricDataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiometricDataPayload>
          }
          findMany: {
            args: Prisma.BiometricDataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiometricDataPayload>[]
          }
          create: {
            args: Prisma.BiometricDataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiometricDataPayload>
          }
          createMany: {
            args: Prisma.BiometricDataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BiometricDataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiometricDataPayload>[]
          }
          delete: {
            args: Prisma.BiometricDataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiometricDataPayload>
          }
          update: {
            args: Prisma.BiometricDataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiometricDataPayload>
          }
          deleteMany: {
            args: Prisma.BiometricDataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BiometricDataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BiometricDataUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiometricDataPayload>[]
          }
          upsert: {
            args: Prisma.BiometricDataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiometricDataPayload>
          }
          aggregate: {
            args: Prisma.BiometricDataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBiometricData>
          }
          groupBy: {
            args: Prisma.BiometricDataGroupByArgs<ExtArgs>
            result: $Utils.Optional<BiometricDataGroupByOutputType>[]
          }
          count: {
            args: Prisma.BiometricDataCountArgs<ExtArgs>
            result: $Utils.Optional<BiometricDataCountAggregateOutputType> | number
          }
        }
      }
      MoodEntry: {
        payload: Prisma.$MoodEntryPayload<ExtArgs>
        fields: Prisma.MoodEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MoodEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MoodEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodEntryPayload>
          }
          findFirst: {
            args: Prisma.MoodEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MoodEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodEntryPayload>
          }
          findMany: {
            args: Prisma.MoodEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodEntryPayload>[]
          }
          create: {
            args: Prisma.MoodEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodEntryPayload>
          }
          createMany: {
            args: Prisma.MoodEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MoodEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodEntryPayload>[]
          }
          delete: {
            args: Prisma.MoodEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodEntryPayload>
          }
          update: {
            args: Prisma.MoodEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodEntryPayload>
          }
          deleteMany: {
            args: Prisma.MoodEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MoodEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MoodEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodEntryPayload>[]
          }
          upsert: {
            args: Prisma.MoodEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodEntryPayload>
          }
          aggregate: {
            args: Prisma.MoodEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMoodEntry>
          }
          groupBy: {
            args: Prisma.MoodEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<MoodEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.MoodEntryCountArgs<ExtArgs>
            result: $Utils.Optional<MoodEntryCountAggregateOutputType> | number
          }
        }
      }
      StressPrediction: {
        payload: Prisma.$StressPredictionPayload<ExtArgs>
        fields: Prisma.StressPredictionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StressPredictionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StressPredictionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StressPredictionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StressPredictionPayload>
          }
          findFirst: {
            args: Prisma.StressPredictionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StressPredictionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StressPredictionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StressPredictionPayload>
          }
          findMany: {
            args: Prisma.StressPredictionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StressPredictionPayload>[]
          }
          create: {
            args: Prisma.StressPredictionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StressPredictionPayload>
          }
          createMany: {
            args: Prisma.StressPredictionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StressPredictionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StressPredictionPayload>[]
          }
          delete: {
            args: Prisma.StressPredictionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StressPredictionPayload>
          }
          update: {
            args: Prisma.StressPredictionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StressPredictionPayload>
          }
          deleteMany: {
            args: Prisma.StressPredictionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StressPredictionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StressPredictionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StressPredictionPayload>[]
          }
          upsert: {
            args: Prisma.StressPredictionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StressPredictionPayload>
          }
          aggregate: {
            args: Prisma.StressPredictionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStressPrediction>
          }
          groupBy: {
            args: Prisma.StressPredictionGroupByArgs<ExtArgs>
            result: $Utils.Optional<StressPredictionGroupByOutputType>[]
          }
          count: {
            args: Prisma.StressPredictionCountArgs<ExtArgs>
            result: $Utils.Optional<StressPredictionCountAggregateOutputType> | number
          }
        }
      }
      WellnessChallenge: {
        payload: Prisma.$WellnessChallengePayload<ExtArgs>
        fields: Prisma.WellnessChallengeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WellnessChallengeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellnessChallengePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WellnessChallengeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellnessChallengePayload>
          }
          findFirst: {
            args: Prisma.WellnessChallengeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellnessChallengePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WellnessChallengeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellnessChallengePayload>
          }
          findMany: {
            args: Prisma.WellnessChallengeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellnessChallengePayload>[]
          }
          create: {
            args: Prisma.WellnessChallengeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellnessChallengePayload>
          }
          createMany: {
            args: Prisma.WellnessChallengeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WellnessChallengeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellnessChallengePayload>[]
          }
          delete: {
            args: Prisma.WellnessChallengeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellnessChallengePayload>
          }
          update: {
            args: Prisma.WellnessChallengeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellnessChallengePayload>
          }
          deleteMany: {
            args: Prisma.WellnessChallengeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WellnessChallengeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WellnessChallengeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellnessChallengePayload>[]
          }
          upsert: {
            args: Prisma.WellnessChallengeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellnessChallengePayload>
          }
          aggregate: {
            args: Prisma.WellnessChallengeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWellnessChallenge>
          }
          groupBy: {
            args: Prisma.WellnessChallengeGroupByArgs<ExtArgs>
            result: $Utils.Optional<WellnessChallengeGroupByOutputType>[]
          }
          count: {
            args: Prisma.WellnessChallengeCountArgs<ExtArgs>
            result: $Utils.Optional<WellnessChallengeCountAggregateOutputType> | number
          }
        }
      }
      ChallengeParticipant: {
        payload: Prisma.$ChallengeParticipantPayload<ExtArgs>
        fields: Prisma.ChallengeParticipantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChallengeParticipantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeParticipantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChallengeParticipantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeParticipantPayload>
          }
          findFirst: {
            args: Prisma.ChallengeParticipantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeParticipantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChallengeParticipantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeParticipantPayload>
          }
          findMany: {
            args: Prisma.ChallengeParticipantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeParticipantPayload>[]
          }
          create: {
            args: Prisma.ChallengeParticipantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeParticipantPayload>
          }
          createMany: {
            args: Prisma.ChallengeParticipantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChallengeParticipantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeParticipantPayload>[]
          }
          delete: {
            args: Prisma.ChallengeParticipantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeParticipantPayload>
          }
          update: {
            args: Prisma.ChallengeParticipantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeParticipantPayload>
          }
          deleteMany: {
            args: Prisma.ChallengeParticipantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChallengeParticipantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChallengeParticipantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeParticipantPayload>[]
          }
          upsert: {
            args: Prisma.ChallengeParticipantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeParticipantPayload>
          }
          aggregate: {
            args: Prisma.ChallengeParticipantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChallengeParticipant>
          }
          groupBy: {
            args: Prisma.ChallengeParticipantGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChallengeParticipantGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChallengeParticipantCountArgs<ExtArgs>
            result: $Utils.Optional<ChallengeParticipantCountAggregateOutputType> | number
          }
        }
      }
      AIRecommendation: {
        payload: Prisma.$AIRecommendationPayload<ExtArgs>
        fields: Prisma.AIRecommendationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIRecommendationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIRecommendationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIRecommendationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIRecommendationPayload>
          }
          findFirst: {
            args: Prisma.AIRecommendationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIRecommendationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIRecommendationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIRecommendationPayload>
          }
          findMany: {
            args: Prisma.AIRecommendationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIRecommendationPayload>[]
          }
          create: {
            args: Prisma.AIRecommendationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIRecommendationPayload>
          }
          createMany: {
            args: Prisma.AIRecommendationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIRecommendationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIRecommendationPayload>[]
          }
          delete: {
            args: Prisma.AIRecommendationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIRecommendationPayload>
          }
          update: {
            args: Prisma.AIRecommendationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIRecommendationPayload>
          }
          deleteMany: {
            args: Prisma.AIRecommendationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIRecommendationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AIRecommendationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIRecommendationPayload>[]
          }
          upsert: {
            args: Prisma.AIRecommendationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIRecommendationPayload>
          }
          aggregate: {
            args: Prisma.AIRecommendationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIRecommendation>
          }
          groupBy: {
            args: Prisma.AIRecommendationGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIRecommendationGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIRecommendationCountArgs<ExtArgs>
            result: $Utils.Optional<AIRecommendationCountAggregateOutputType> | number
          }
        }
      }
      DeviceConnection: {
        payload: Prisma.$DeviceConnectionPayload<ExtArgs>
        fields: Prisma.DeviceConnectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceConnectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceConnectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceConnectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceConnectionPayload>
          }
          findFirst: {
            args: Prisma.DeviceConnectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceConnectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceConnectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceConnectionPayload>
          }
          findMany: {
            args: Prisma.DeviceConnectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceConnectionPayload>[]
          }
          create: {
            args: Prisma.DeviceConnectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceConnectionPayload>
          }
          createMany: {
            args: Prisma.DeviceConnectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeviceConnectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceConnectionPayload>[]
          }
          delete: {
            args: Prisma.DeviceConnectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceConnectionPayload>
          }
          update: {
            args: Prisma.DeviceConnectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceConnectionPayload>
          }
          deleteMany: {
            args: Prisma.DeviceConnectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceConnectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeviceConnectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceConnectionPayload>[]
          }
          upsert: {
            args: Prisma.DeviceConnectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceConnectionPayload>
          }
          aggregate: {
            args: Prisma.DeviceConnectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeviceConnection>
          }
          groupBy: {
            args: Prisma.DeviceConnectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceConnectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceConnectionCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceConnectionCountAggregateOutputType> | number
          }
        }
      }
      WellnessSession: {
        payload: Prisma.$WellnessSessionPayload<ExtArgs>
        fields: Prisma.WellnessSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WellnessSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellnessSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WellnessSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellnessSessionPayload>
          }
          findFirst: {
            args: Prisma.WellnessSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellnessSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WellnessSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellnessSessionPayload>
          }
          findMany: {
            args: Prisma.WellnessSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellnessSessionPayload>[]
          }
          create: {
            args: Prisma.WellnessSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellnessSessionPayload>
          }
          createMany: {
            args: Prisma.WellnessSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WellnessSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellnessSessionPayload>[]
          }
          delete: {
            args: Prisma.WellnessSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellnessSessionPayload>
          }
          update: {
            args: Prisma.WellnessSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellnessSessionPayload>
          }
          deleteMany: {
            args: Prisma.WellnessSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WellnessSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WellnessSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellnessSessionPayload>[]
          }
          upsert: {
            args: Prisma.WellnessSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellnessSessionPayload>
          }
          aggregate: {
            args: Prisma.WellnessSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWellnessSession>
          }
          groupBy: {
            args: Prisma.WellnessSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<WellnessSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.WellnessSessionCountArgs<ExtArgs>
            result: $Utils.Optional<WellnessSessionCountAggregateOutputType> | number
          }
        }
      }
      EnvironmentalData: {
        payload: Prisma.$EnvironmentalDataPayload<ExtArgs>
        fields: Prisma.EnvironmentalDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EnvironmentalDataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvironmentalDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EnvironmentalDataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvironmentalDataPayload>
          }
          findFirst: {
            args: Prisma.EnvironmentalDataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvironmentalDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EnvironmentalDataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvironmentalDataPayload>
          }
          findMany: {
            args: Prisma.EnvironmentalDataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvironmentalDataPayload>[]
          }
          create: {
            args: Prisma.EnvironmentalDataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvironmentalDataPayload>
          }
          createMany: {
            args: Prisma.EnvironmentalDataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EnvironmentalDataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvironmentalDataPayload>[]
          }
          delete: {
            args: Prisma.EnvironmentalDataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvironmentalDataPayload>
          }
          update: {
            args: Prisma.EnvironmentalDataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvironmentalDataPayload>
          }
          deleteMany: {
            args: Prisma.EnvironmentalDataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EnvironmentalDataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EnvironmentalDataUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvironmentalDataPayload>[]
          }
          upsert: {
            args: Prisma.EnvironmentalDataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvironmentalDataPayload>
          }
          aggregate: {
            args: Prisma.EnvironmentalDataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEnvironmentalData>
          }
          groupBy: {
            args: Prisma.EnvironmentalDataGroupByArgs<ExtArgs>
            result: $Utils.Optional<EnvironmentalDataGroupByOutputType>[]
          }
          count: {
            args: Prisma.EnvironmentalDataCountArgs<ExtArgs>
            result: $Utils.Optional<EnvironmentalDataCountAggregateOutputType> | number
          }
        }
      }
      WellnessGroup: {
        payload: Prisma.$WellnessGroupPayload<ExtArgs>
        fields: Prisma.WellnessGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WellnessGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellnessGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WellnessGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellnessGroupPayload>
          }
          findFirst: {
            args: Prisma.WellnessGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellnessGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WellnessGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellnessGroupPayload>
          }
          findMany: {
            args: Prisma.WellnessGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellnessGroupPayload>[]
          }
          create: {
            args: Prisma.WellnessGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellnessGroupPayload>
          }
          createMany: {
            args: Prisma.WellnessGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WellnessGroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellnessGroupPayload>[]
          }
          delete: {
            args: Prisma.WellnessGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellnessGroupPayload>
          }
          update: {
            args: Prisma.WellnessGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellnessGroupPayload>
          }
          deleteMany: {
            args: Prisma.WellnessGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WellnessGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WellnessGroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellnessGroupPayload>[]
          }
          upsert: {
            args: Prisma.WellnessGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellnessGroupPayload>
          }
          aggregate: {
            args: Prisma.WellnessGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWellnessGroup>
          }
          groupBy: {
            args: Prisma.WellnessGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<WellnessGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.WellnessGroupCountArgs<ExtArgs>
            result: $Utils.Optional<WellnessGroupCountAggregateOutputType> | number
          }
        }
      }
      GroupMembership: {
        payload: Prisma.$GroupMembershipPayload<ExtArgs>
        fields: Prisma.GroupMembershipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupMembershipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMembershipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupMembershipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMembershipPayload>
          }
          findFirst: {
            args: Prisma.GroupMembershipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMembershipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupMembershipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMembershipPayload>
          }
          findMany: {
            args: Prisma.GroupMembershipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMembershipPayload>[]
          }
          create: {
            args: Prisma.GroupMembershipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMembershipPayload>
          }
          createMany: {
            args: Prisma.GroupMembershipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GroupMembershipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMembershipPayload>[]
          }
          delete: {
            args: Prisma.GroupMembershipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMembershipPayload>
          }
          update: {
            args: Prisma.GroupMembershipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMembershipPayload>
          }
          deleteMany: {
            args: Prisma.GroupMembershipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroupMembershipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GroupMembershipUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMembershipPayload>[]
          }
          upsert: {
            args: Prisma.GroupMembershipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMembershipPayload>
          }
          aggregate: {
            args: Prisma.GroupMembershipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroupMembership>
          }
          groupBy: {
            args: Prisma.GroupMembershipGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupMembershipGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupMembershipCountArgs<ExtArgs>
            result: $Utils.Optional<GroupMembershipCountAggregateOutputType> | number
          }
        }
      }
      WorkplaceIntegration: {
        payload: Prisma.$WorkplaceIntegrationPayload<ExtArgs>
        fields: Prisma.WorkplaceIntegrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkplaceIntegrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkplaceIntegrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkplaceIntegrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkplaceIntegrationPayload>
          }
          findFirst: {
            args: Prisma.WorkplaceIntegrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkplaceIntegrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkplaceIntegrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkplaceIntegrationPayload>
          }
          findMany: {
            args: Prisma.WorkplaceIntegrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkplaceIntegrationPayload>[]
          }
          create: {
            args: Prisma.WorkplaceIntegrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkplaceIntegrationPayload>
          }
          createMany: {
            args: Prisma.WorkplaceIntegrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkplaceIntegrationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkplaceIntegrationPayload>[]
          }
          delete: {
            args: Prisma.WorkplaceIntegrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkplaceIntegrationPayload>
          }
          update: {
            args: Prisma.WorkplaceIntegrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkplaceIntegrationPayload>
          }
          deleteMany: {
            args: Prisma.WorkplaceIntegrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkplaceIntegrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkplaceIntegrationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkplaceIntegrationPayload>[]
          }
          upsert: {
            args: Prisma.WorkplaceIntegrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkplaceIntegrationPayload>
          }
          aggregate: {
            args: Prisma.WorkplaceIntegrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkplaceIntegration>
          }
          groupBy: {
            args: Prisma.WorkplaceIntegrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkplaceIntegrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkplaceIntegrationCountArgs<ExtArgs>
            result: $Utils.Optional<WorkplaceIntegrationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    session?: SessionOmit
    account?: AccountOmit
    verification?: VerificationOmit
    journalEntry?: JournalEntryOmit
    habit?: HabitOmit
    class?: ClassOmit
    booking?: BookingOmit
    biometricData?: BiometricDataOmit
    moodEntry?: MoodEntryOmit
    stressPrediction?: StressPredictionOmit
    wellnessChallenge?: WellnessChallengeOmit
    challengeParticipant?: ChallengeParticipantOmit
    aIRecommendation?: AIRecommendationOmit
    deviceConnection?: DeviceConnectionOmit
    wellnessSession?: WellnessSessionOmit
    environmentalData?: EnvironmentalDataOmit
    wellnessGroup?: WellnessGroupOmit
    groupMembership?: GroupMembershipOmit
    workplaceIntegration?: WorkplaceIntegrationOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    sessions: number
    journalEntries: number
    habits: number
    bookings: number
    biometricData: number
    moodEntries: number
    stressPredictions: number
    challengeParticipants: number
    aiRecommendations: number
    deviceConnections: number
    wellnessSessions: number
    environmentalData: number
    collaborativeGroups: number
    workplaceIntegrations: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    journalEntries?: boolean | UserCountOutputTypeCountJournalEntriesArgs
    habits?: boolean | UserCountOutputTypeCountHabitsArgs
    bookings?: boolean | UserCountOutputTypeCountBookingsArgs
    biometricData?: boolean | UserCountOutputTypeCountBiometricDataArgs
    moodEntries?: boolean | UserCountOutputTypeCountMoodEntriesArgs
    stressPredictions?: boolean | UserCountOutputTypeCountStressPredictionsArgs
    challengeParticipants?: boolean | UserCountOutputTypeCountChallengeParticipantsArgs
    aiRecommendations?: boolean | UserCountOutputTypeCountAiRecommendationsArgs
    deviceConnections?: boolean | UserCountOutputTypeCountDeviceConnectionsArgs
    wellnessSessions?: boolean | UserCountOutputTypeCountWellnessSessionsArgs
    environmentalData?: boolean | UserCountOutputTypeCountEnvironmentalDataArgs
    collaborativeGroups?: boolean | UserCountOutputTypeCountCollaborativeGroupsArgs
    workplaceIntegrations?: boolean | UserCountOutputTypeCountWorkplaceIntegrationsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountJournalEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalEntryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountHabitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HabitWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBiometricDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BiometricDataWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMoodEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MoodEntryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStressPredictionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StressPredictionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChallengeParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeParticipantWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAiRecommendationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIRecommendationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDeviceConnectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceConnectionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWellnessSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WellnessSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEnvironmentalDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnvironmentalDataWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCollaborativeGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupMembershipWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWorkplaceIntegrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkplaceIntegrationWhereInput
  }


  /**
   * Count Type ClassCountOutputType
   */

  export type ClassCountOutputType = {
    bookings: number
  }

  export type ClassCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | ClassCountOutputTypeCountBookingsArgs
  }

  // Custom InputTypes
  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassCountOutputType
     */
    select?: ClassCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }


  /**
   * Count Type WellnessChallengeCountOutputType
   */

  export type WellnessChallengeCountOutputType = {
    participants: number
  }

  export type WellnessChallengeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participants?: boolean | WellnessChallengeCountOutputTypeCountParticipantsArgs
  }

  // Custom InputTypes
  /**
   * WellnessChallengeCountOutputType without action
   */
  export type WellnessChallengeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellnessChallengeCountOutputType
     */
    select?: WellnessChallengeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WellnessChallengeCountOutputType without action
   */
  export type WellnessChallengeCountOutputTypeCountParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeParticipantWhereInput
  }


  /**
   * Count Type WellnessGroupCountOutputType
   */

  export type WellnessGroupCountOutputType = {
    members: number
  }

  export type WellnessGroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | WellnessGroupCountOutputTypeCountMembersArgs
  }

  // Custom InputTypes
  /**
   * WellnessGroupCountOutputType without action
   */
  export type WellnessGroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellnessGroupCountOutputType
     */
    select?: WellnessGroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WellnessGroupCountOutputType without action
   */
  export type WellnessGroupCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupMembershipWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    baseStressLevel: number | null
    sleepGoal: number | null
    stepsGoal: number | null
  }

  export type UserSumAggregateOutputType = {
    baseStressLevel: number | null
    sleepGoal: number | null
    stepsGoal: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
    timezone: string | null
    aiCoachEnabled: boolean | null
    biometricSyncEnabled: boolean | null
    baseStressLevel: number | null
    sleepGoal: number | null
    stepsGoal: number | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
    timezone: string | null
    aiCoachEnabled: boolean | null
    biometricSyncEnabled: boolean | null
    baseStressLevel: number | null
    sleepGoal: number | null
    stepsGoal: number | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    image: number
    createdAt: number
    updatedAt: number
    timezone: number
    preferences: number
    aiCoachEnabled: number
    biometricSyncEnabled: number
    baseStressLevel: number
    sleepGoal: number
    stepsGoal: number
    workSchedule: number
    personalityProfile: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    baseStressLevel?: true
    sleepGoal?: true
    stepsGoal?: true
  }

  export type UserSumAggregateInputType = {
    baseStressLevel?: true
    sleepGoal?: true
    stepsGoal?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    timezone?: true
    aiCoachEnabled?: true
    biometricSyncEnabled?: true
    baseStressLevel?: true
    sleepGoal?: true
    stepsGoal?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    timezone?: true
    aiCoachEnabled?: true
    biometricSyncEnabled?: true
    baseStressLevel?: true
    sleepGoal?: true
    stepsGoal?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    timezone?: true
    preferences?: true
    aiCoachEnabled?: true
    biometricSyncEnabled?: true
    baseStressLevel?: true
    sleepGoal?: true
    stepsGoal?: true
    workSchedule?: true
    personalityProfile?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string | null
    email: string
    emailVerified: boolean
    image: string | null
    createdAt: Date
    updatedAt: Date
    timezone: string
    preferences: JsonValue | null
    aiCoachEnabled: boolean
    biometricSyncEnabled: boolean
    baseStressLevel: number | null
    sleepGoal: number | null
    stepsGoal: number | null
    workSchedule: JsonValue | null
    personalityProfile: JsonValue | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    timezone?: boolean
    preferences?: boolean
    aiCoachEnabled?: boolean
    biometricSyncEnabled?: boolean
    baseStressLevel?: boolean
    sleepGoal?: boolean
    stepsGoal?: boolean
    workSchedule?: boolean
    personalityProfile?: boolean
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    account?: boolean | User$accountArgs<ExtArgs>
    journalEntries?: boolean | User$journalEntriesArgs<ExtArgs>
    habits?: boolean | User$habitsArgs<ExtArgs>
    bookings?: boolean | User$bookingsArgs<ExtArgs>
    biometricData?: boolean | User$biometricDataArgs<ExtArgs>
    moodEntries?: boolean | User$moodEntriesArgs<ExtArgs>
    stressPredictions?: boolean | User$stressPredictionsArgs<ExtArgs>
    challengeParticipants?: boolean | User$challengeParticipantsArgs<ExtArgs>
    aiRecommendations?: boolean | User$aiRecommendationsArgs<ExtArgs>
    deviceConnections?: boolean | User$deviceConnectionsArgs<ExtArgs>
    wellnessSessions?: boolean | User$wellnessSessionsArgs<ExtArgs>
    environmentalData?: boolean | User$environmentalDataArgs<ExtArgs>
    collaborativeGroups?: boolean | User$collaborativeGroupsArgs<ExtArgs>
    workplaceIntegrations?: boolean | User$workplaceIntegrationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    timezone?: boolean
    preferences?: boolean
    aiCoachEnabled?: boolean
    biometricSyncEnabled?: boolean
    baseStressLevel?: boolean
    sleepGoal?: boolean
    stepsGoal?: boolean
    workSchedule?: boolean
    personalityProfile?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    timezone?: boolean
    preferences?: boolean
    aiCoachEnabled?: boolean
    biometricSyncEnabled?: boolean
    baseStressLevel?: boolean
    sleepGoal?: boolean
    stepsGoal?: boolean
    workSchedule?: boolean
    personalityProfile?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    timezone?: boolean
    preferences?: boolean
    aiCoachEnabled?: boolean
    biometricSyncEnabled?: boolean
    baseStressLevel?: boolean
    sleepGoal?: boolean
    stepsGoal?: boolean
    workSchedule?: boolean
    personalityProfile?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "emailVerified" | "image" | "createdAt" | "updatedAt" | "timezone" | "preferences" | "aiCoachEnabled" | "biometricSyncEnabled" | "baseStressLevel" | "sleepGoal" | "stepsGoal" | "workSchedule" | "personalityProfile", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    account?: boolean | User$accountArgs<ExtArgs>
    journalEntries?: boolean | User$journalEntriesArgs<ExtArgs>
    habits?: boolean | User$habitsArgs<ExtArgs>
    bookings?: boolean | User$bookingsArgs<ExtArgs>
    biometricData?: boolean | User$biometricDataArgs<ExtArgs>
    moodEntries?: boolean | User$moodEntriesArgs<ExtArgs>
    stressPredictions?: boolean | User$stressPredictionsArgs<ExtArgs>
    challengeParticipants?: boolean | User$challengeParticipantsArgs<ExtArgs>
    aiRecommendations?: boolean | User$aiRecommendationsArgs<ExtArgs>
    deviceConnections?: boolean | User$deviceConnectionsArgs<ExtArgs>
    wellnessSessions?: boolean | User$wellnessSessionsArgs<ExtArgs>
    environmentalData?: boolean | User$environmentalDataArgs<ExtArgs>
    collaborativeGroups?: boolean | User$collaborativeGroupsArgs<ExtArgs>
    workplaceIntegrations?: boolean | User$workplaceIntegrationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      account: Prisma.$AccountPayload<ExtArgs> | null
      journalEntries: Prisma.$JournalEntryPayload<ExtArgs>[]
      habits: Prisma.$HabitPayload<ExtArgs>[]
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      biometricData: Prisma.$BiometricDataPayload<ExtArgs>[]
      moodEntries: Prisma.$MoodEntryPayload<ExtArgs>[]
      stressPredictions: Prisma.$StressPredictionPayload<ExtArgs>[]
      challengeParticipants: Prisma.$ChallengeParticipantPayload<ExtArgs>[]
      aiRecommendations: Prisma.$AIRecommendationPayload<ExtArgs>[]
      deviceConnections: Prisma.$DeviceConnectionPayload<ExtArgs>[]
      wellnessSessions: Prisma.$WellnessSessionPayload<ExtArgs>[]
      environmentalData: Prisma.$EnvironmentalDataPayload<ExtArgs>[]
      collaborativeGroups: Prisma.$GroupMembershipPayload<ExtArgs>[]
      workplaceIntegrations: Prisma.$WorkplaceIntegrationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      email: string
      emailVerified: boolean
      image: string | null
      createdAt: Date
      updatedAt: Date
      timezone: string
      preferences: Prisma.JsonValue | null
      aiCoachEnabled: boolean
      biometricSyncEnabled: boolean
      baseStressLevel: number | null
      sleepGoal: number | null
      stepsGoal: number | null
      workSchedule: Prisma.JsonValue | null
      personalityProfile: Prisma.JsonValue | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    account<T extends User$accountArgs<ExtArgs> = {}>(args?: Subset<T, User$accountArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    journalEntries<T extends User$journalEntriesArgs<ExtArgs> = {}>(args?: Subset<T, User$journalEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    habits<T extends User$habitsArgs<ExtArgs> = {}>(args?: Subset<T, User$habitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HabitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bookings<T extends User$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, User$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    biometricData<T extends User$biometricDataArgs<ExtArgs> = {}>(args?: Subset<T, User$biometricDataArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BiometricDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    moodEntries<T extends User$moodEntriesArgs<ExtArgs> = {}>(args?: Subset<T, User$moodEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoodEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stressPredictions<T extends User$stressPredictionsArgs<ExtArgs> = {}>(args?: Subset<T, User$stressPredictionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StressPredictionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    challengeParticipants<T extends User$challengeParticipantsArgs<ExtArgs> = {}>(args?: Subset<T, User$challengeParticipantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    aiRecommendations<T extends User$aiRecommendationsArgs<ExtArgs> = {}>(args?: Subset<T, User$aiRecommendationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIRecommendationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deviceConnections<T extends User$deviceConnectionsArgs<ExtArgs> = {}>(args?: Subset<T, User$deviceConnectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceConnectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    wellnessSessions<T extends User$wellnessSessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$wellnessSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WellnessSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    environmentalData<T extends User$environmentalDataArgs<ExtArgs> = {}>(args?: Subset<T, User$environmentalDataArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnvironmentalDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    collaborativeGroups<T extends User$collaborativeGroupsArgs<ExtArgs> = {}>(args?: Subset<T, User$collaborativeGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workplaceIntegrations<T extends User$workplaceIntegrationsArgs<ExtArgs> = {}>(args?: Subset<T, User$workplaceIntegrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkplaceIntegrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly image: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly timezone: FieldRef<"User", 'String'>
    readonly preferences: FieldRef<"User", 'Json'>
    readonly aiCoachEnabled: FieldRef<"User", 'Boolean'>
    readonly biometricSyncEnabled: FieldRef<"User", 'Boolean'>
    readonly baseStressLevel: FieldRef<"User", 'Int'>
    readonly sleepGoal: FieldRef<"User", 'Float'>
    readonly stepsGoal: FieldRef<"User", 'Int'>
    readonly workSchedule: FieldRef<"User", 'Json'>
    readonly personalityProfile: FieldRef<"User", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.account
   */
  export type User$accountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
  }

  /**
   * User.journalEntries
   */
  export type User$journalEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    where?: JournalEntryWhereInput
    orderBy?: JournalEntryOrderByWithRelationInput | JournalEntryOrderByWithRelationInput[]
    cursor?: JournalEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalEntryScalarFieldEnum | JournalEntryScalarFieldEnum[]
  }

  /**
   * User.habits
   */
  export type User$habitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Habit
     */
    select?: HabitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Habit
     */
    omit?: HabitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitInclude<ExtArgs> | null
    where?: HabitWhereInput
    orderBy?: HabitOrderByWithRelationInput | HabitOrderByWithRelationInput[]
    cursor?: HabitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HabitScalarFieldEnum | HabitScalarFieldEnum[]
  }

  /**
   * User.bookings
   */
  export type User$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * User.biometricData
   */
  export type User$biometricDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiometricData
     */
    select?: BiometricDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BiometricData
     */
    omit?: BiometricDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiometricDataInclude<ExtArgs> | null
    where?: BiometricDataWhereInput
    orderBy?: BiometricDataOrderByWithRelationInput | BiometricDataOrderByWithRelationInput[]
    cursor?: BiometricDataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BiometricDataScalarFieldEnum | BiometricDataScalarFieldEnum[]
  }

  /**
   * User.moodEntries
   */
  export type User$moodEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodEntry
     */
    select?: MoodEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoodEntry
     */
    omit?: MoodEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodEntryInclude<ExtArgs> | null
    where?: MoodEntryWhereInput
    orderBy?: MoodEntryOrderByWithRelationInput | MoodEntryOrderByWithRelationInput[]
    cursor?: MoodEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MoodEntryScalarFieldEnum | MoodEntryScalarFieldEnum[]
  }

  /**
   * User.stressPredictions
   */
  export type User$stressPredictionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StressPrediction
     */
    select?: StressPredictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StressPrediction
     */
    omit?: StressPredictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StressPredictionInclude<ExtArgs> | null
    where?: StressPredictionWhereInput
    orderBy?: StressPredictionOrderByWithRelationInput | StressPredictionOrderByWithRelationInput[]
    cursor?: StressPredictionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StressPredictionScalarFieldEnum | StressPredictionScalarFieldEnum[]
  }

  /**
   * User.challengeParticipants
   */
  export type User$challengeParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeParticipant
     */
    select?: ChallengeParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeParticipant
     */
    omit?: ChallengeParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeParticipantInclude<ExtArgs> | null
    where?: ChallengeParticipantWhereInput
    orderBy?: ChallengeParticipantOrderByWithRelationInput | ChallengeParticipantOrderByWithRelationInput[]
    cursor?: ChallengeParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChallengeParticipantScalarFieldEnum | ChallengeParticipantScalarFieldEnum[]
  }

  /**
   * User.aiRecommendations
   */
  export type User$aiRecommendationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRecommendation
     */
    select?: AIRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRecommendation
     */
    omit?: AIRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRecommendationInclude<ExtArgs> | null
    where?: AIRecommendationWhereInput
    orderBy?: AIRecommendationOrderByWithRelationInput | AIRecommendationOrderByWithRelationInput[]
    cursor?: AIRecommendationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIRecommendationScalarFieldEnum | AIRecommendationScalarFieldEnum[]
  }

  /**
   * User.deviceConnections
   */
  export type User$deviceConnectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceConnection
     */
    select?: DeviceConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceConnection
     */
    omit?: DeviceConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceConnectionInclude<ExtArgs> | null
    where?: DeviceConnectionWhereInput
    orderBy?: DeviceConnectionOrderByWithRelationInput | DeviceConnectionOrderByWithRelationInput[]
    cursor?: DeviceConnectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceConnectionScalarFieldEnum | DeviceConnectionScalarFieldEnum[]
  }

  /**
   * User.wellnessSessions
   */
  export type User$wellnessSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellnessSession
     */
    select?: WellnessSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellnessSession
     */
    omit?: WellnessSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellnessSessionInclude<ExtArgs> | null
    where?: WellnessSessionWhereInput
    orderBy?: WellnessSessionOrderByWithRelationInput | WellnessSessionOrderByWithRelationInput[]
    cursor?: WellnessSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WellnessSessionScalarFieldEnum | WellnessSessionScalarFieldEnum[]
  }

  /**
   * User.environmentalData
   */
  export type User$environmentalDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvironmentalData
     */
    select?: EnvironmentalDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnvironmentalData
     */
    omit?: EnvironmentalDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvironmentalDataInclude<ExtArgs> | null
    where?: EnvironmentalDataWhereInput
    orderBy?: EnvironmentalDataOrderByWithRelationInput | EnvironmentalDataOrderByWithRelationInput[]
    cursor?: EnvironmentalDataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnvironmentalDataScalarFieldEnum | EnvironmentalDataScalarFieldEnum[]
  }

  /**
   * User.collaborativeGroups
   */
  export type User$collaborativeGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMembership
     */
    select?: GroupMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMembership
     */
    omit?: GroupMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMembershipInclude<ExtArgs> | null
    where?: GroupMembershipWhereInput
    orderBy?: GroupMembershipOrderByWithRelationInput | GroupMembershipOrderByWithRelationInput[]
    cursor?: GroupMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupMembershipScalarFieldEnum | GroupMembershipScalarFieldEnum[]
  }

  /**
   * User.workplaceIntegrations
   */
  export type User$workplaceIntegrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkplaceIntegration
     */
    select?: WorkplaceIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkplaceIntegration
     */
    omit?: WorkplaceIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkplaceIntegrationInclude<ExtArgs> | null
    where?: WorkplaceIntegrationWhereInput
    orderBy?: WorkplaceIntegrationOrderByWithRelationInput | WorkplaceIntegrationOrderByWithRelationInput[]
    cursor?: WorkplaceIntegrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkplaceIntegrationScalarFieldEnum | WorkplaceIntegrationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    expiresAt: number
    ipAddress: number
    userAgent: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: string
    token: string
    expiresAt: Date
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    updatedAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "token" | "expiresAt" | "ipAddress" | "userAgent" | "createdAt" | "updatedAt", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      expiresAt: Date
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly token: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    accountId: string | null
    providerId: string | null
    accessToken: string | null
    refreshToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    idToken: string | null
    password: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    accountId: string | null
    providerId: string | null
    accessToken: string | null
    refreshToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    idToken: string | null
    password: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    accountId: number
    providerId: number
    accessToken: number
    refreshToken: number
    accessTokenExpiresAt: number
    refreshTokenExpiresAt: number
    scope: number
    idToken: number
    password: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    accountId?: true
    providerId?: true
    accessToken?: true
    refreshToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    idToken?: true
    password?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    accountId?: true
    providerId?: true
    accessToken?: true
    refreshToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    idToken?: true
    password?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    accountId?: true
    providerId?: true
    accessToken?: true
    refreshToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    idToken?: true
    password?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    accountId: string
    providerId: string
    accessToken: string | null
    refreshToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    idToken: string | null
    password: string | null
    expiresAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountId?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    idToken?: boolean
    password?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountId?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    idToken?: boolean
    password?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountId?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    idToken?: boolean
    password?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    accountId?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    idToken?: boolean
    password?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "accountId" | "providerId" | "accessToken" | "refreshToken" | "accessTokenExpiresAt" | "refreshTokenExpiresAt" | "scope" | "idToken" | "password" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      accountId: string
      providerId: string
      accessToken: string | null
      refreshToken: string | null
      accessTokenExpiresAt: Date | null
      refreshTokenExpiresAt: Date | null
      scope: string | null
      idToken: string | null
      password: string | null
      expiresAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly accountId: FieldRef<"Account", 'String'>
    readonly providerId: FieldRef<"Account", 'String'>
    readonly accessToken: FieldRef<"Account", 'String'>
    readonly refreshToken: FieldRef<"Account", 'String'>
    readonly accessTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly refreshTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly idToken: FieldRef<"Account", 'String'>
    readonly password: FieldRef<"Account", 'String'>
    readonly expiresAt: FieldRef<"Account", 'DateTime'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Verification
   */

  export type AggregateVerification = {
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  export type VerificationMinAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationMaxAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationCountAggregateOutputType = {
    id: number
    identifier: number
    value: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VerificationMinAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationMaxAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationCountAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verification to aggregate.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Verifications
    **/
    _count?: true | VerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationMaxAggregateInputType
  }

  export type GetVerificationAggregateType<T extends VerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerification[P]>
      : GetScalarType<T[P], AggregateVerification[P]>
  }




  export type VerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationWhereInput
    orderBy?: VerificationOrderByWithAggregationInput | VerificationOrderByWithAggregationInput[]
    by: VerificationScalarFieldEnum[] | VerificationScalarFieldEnum
    having?: VerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationCountAggregateInputType | true
    _min?: VerificationMinAggregateInputType
    _max?: VerificationMaxAggregateInputType
  }

  export type VerificationGroupByOutputType = {
    id: string
    identifier: string
    value: string
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  type GetVerificationGroupByPayload<T extends VerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationGroupByOutputType[P]>
        }
      >
    >


  export type VerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectScalar = {
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "identifier" | "value" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["verification"]>

  export type $VerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Verification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      identifier: string
      value: string
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["verification"]>
    composites: {}
  }

  type VerificationGetPayload<S extends boolean | null | undefined | VerificationDefaultArgs> = $Result.GetResult<Prisma.$VerificationPayload, S>

  type VerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationCountAggregateInputType | true
    }

  export interface VerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Verification'], meta: { name: 'Verification' } }
    /**
     * Find zero or one Verification that matches the filter.
     * @param {VerificationFindUniqueArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationFindUniqueArgs>(args: SelectSubset<T, VerificationFindUniqueArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Verification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationFindUniqueOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationFindFirstArgs>(args?: SelectSubset<T, VerificationFindFirstArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Verifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Verifications
     * const verifications = await prisma.verification.findMany()
     * 
     * // Get first 10 Verifications
     * const verifications = await prisma.verification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationWithIdOnly = await prisma.verification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationFindManyArgs>(args?: SelectSubset<T, VerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Verification.
     * @param {VerificationCreateArgs} args - Arguments to create a Verification.
     * @example
     * // Create one Verification
     * const Verification = await prisma.verification.create({
     *   data: {
     *     // ... data to create a Verification
     *   }
     * })
     * 
     */
    create<T extends VerificationCreateArgs>(args: SelectSubset<T, VerificationCreateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Verifications.
     * @param {VerificationCreateManyArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationCreateManyArgs>(args?: SelectSubset<T, VerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Verifications and returns the data saved in the database.
     * @param {VerificationCreateManyAndReturnArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Verification.
     * @param {VerificationDeleteArgs} args - Arguments to delete one Verification.
     * @example
     * // Delete one Verification
     * const Verification = await prisma.verification.delete({
     *   where: {
     *     // ... filter to delete one Verification
     *   }
     * })
     * 
     */
    delete<T extends VerificationDeleteArgs>(args: SelectSubset<T, VerificationDeleteArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Verification.
     * @param {VerificationUpdateArgs} args - Arguments to update one Verification.
     * @example
     * // Update one Verification
     * const verification = await prisma.verification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationUpdateArgs>(args: SelectSubset<T, VerificationUpdateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Verifications.
     * @param {VerificationDeleteManyArgs} args - Arguments to filter Verifications to delete.
     * @example
     * // Delete a few Verifications
     * const { count } = await prisma.verification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationDeleteManyArgs>(args?: SelectSubset<T, VerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationUpdateManyArgs>(args: SelectSubset<T, VerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications and returns the data updated in the database.
     * @param {VerificationUpdateManyAndReturnArgs} args - Arguments to update many Verifications.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Verification.
     * @param {VerificationUpsertArgs} args - Arguments to update or create a Verification.
     * @example
     * // Update or create a Verification
     * const verification = await prisma.verification.upsert({
     *   create: {
     *     // ... data to create a Verification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Verification we want to update
     *   }
     * })
     */
    upsert<T extends VerificationUpsertArgs>(args: SelectSubset<T, VerificationUpsertArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCountArgs} args - Arguments to filter Verifications to count.
     * @example
     * // Count the number of Verifications
     * const count = await prisma.verification.count({
     *   where: {
     *     // ... the filter for the Verifications we want to count
     *   }
     * })
    **/
    count<T extends VerificationCountArgs>(
      args?: Subset<T, VerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationAggregateArgs>(args: Subset<T, VerificationAggregateArgs>): Prisma.PrismaPromise<GetVerificationAggregateType<T>>

    /**
     * Group by Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationGroupByArgs['orderBy'] }
        : { orderBy?: VerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Verification model
   */
  readonly fields: VerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Verification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Verification model
   */
  interface VerificationFieldRefs {
    readonly id: FieldRef<"Verification", 'String'>
    readonly identifier: FieldRef<"Verification", 'String'>
    readonly value: FieldRef<"Verification", 'String'>
    readonly expiresAt: FieldRef<"Verification", 'DateTime'>
    readonly createdAt: FieldRef<"Verification", 'DateTime'>
    readonly updatedAt: FieldRef<"Verification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Verification findUnique
   */
  export type VerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findUniqueOrThrow
   */
  export type VerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findFirst
   */
  export type VerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findFirstOrThrow
   */
  export type VerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findMany
   */
  export type VerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verifications to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification create
   */
  export type VerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to create a Verification.
     */
    data: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
  }

  /**
   * Verification createMany
   */
  export type VerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification createManyAndReturn
   */
  export type VerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification update
   */
  export type VerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to update a Verification.
     */
    data: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
    /**
     * Choose, which Verification to update.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification updateMany
   */
  export type VerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification updateManyAndReturn
   */
  export type VerificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification upsert
   */
  export type VerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The filter to search for the Verification to update in case it exists.
     */
    where: VerificationWhereUniqueInput
    /**
     * In case the Verification found by the `where` argument doesn't exist, create a new Verification with this data.
     */
    create: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
    /**
     * In case the Verification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
  }

  /**
   * Verification delete
   */
  export type VerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter which Verification to delete.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification deleteMany
   */
  export type VerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verifications to delete
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to delete.
     */
    limit?: number
  }

  /**
   * Verification without action
   */
  export type VerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
  }


  /**
   * Model JournalEntry
   */

  export type AggregateJournalEntry = {
    _count: JournalEntryCountAggregateOutputType | null
    _avg: JournalEntryAvgAggregateOutputType | null
    _sum: JournalEntrySumAggregateOutputType | null
    _min: JournalEntryMinAggregateOutputType | null
    _max: JournalEntryMaxAggregateOutputType | null
  }

  export type JournalEntryAvgAggregateOutputType = {
    stressLevel: number | null
    sentiment: number | null
  }

  export type JournalEntrySumAggregateOutputType = {
    stressLevel: number | null
    sentiment: number | null
  }

  export type JournalEntryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    content: string | null
    date: Date | null
    mood: string | null
    stressLevel: number | null
    sentiment: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JournalEntryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    content: string | null
    date: Date | null
    mood: string | null
    stressLevel: number | null
    sentiment: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JournalEntryCountAggregateOutputType = {
    id: number
    userId: number
    content: number
    date: number
    mood: number
    stressLevel: number
    emotionScores: number
    topics: number
    sentiment: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type JournalEntryAvgAggregateInputType = {
    stressLevel?: true
    sentiment?: true
  }

  export type JournalEntrySumAggregateInputType = {
    stressLevel?: true
    sentiment?: true
  }

  export type JournalEntryMinAggregateInputType = {
    id?: true
    userId?: true
    content?: true
    date?: true
    mood?: true
    stressLevel?: true
    sentiment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JournalEntryMaxAggregateInputType = {
    id?: true
    userId?: true
    content?: true
    date?: true
    mood?: true
    stressLevel?: true
    sentiment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JournalEntryCountAggregateInputType = {
    id?: true
    userId?: true
    content?: true
    date?: true
    mood?: true
    stressLevel?: true
    emotionScores?: true
    topics?: true
    sentiment?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type JournalEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalEntry to aggregate.
     */
    where?: JournalEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalEntries to fetch.
     */
    orderBy?: JournalEntryOrderByWithRelationInput | JournalEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JournalEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JournalEntries
    **/
    _count?: true | JournalEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JournalEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JournalEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JournalEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JournalEntryMaxAggregateInputType
  }

  export type GetJournalEntryAggregateType<T extends JournalEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateJournalEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJournalEntry[P]>
      : GetScalarType<T[P], AggregateJournalEntry[P]>
  }




  export type JournalEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalEntryWhereInput
    orderBy?: JournalEntryOrderByWithAggregationInput | JournalEntryOrderByWithAggregationInput[]
    by: JournalEntryScalarFieldEnum[] | JournalEntryScalarFieldEnum
    having?: JournalEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JournalEntryCountAggregateInputType | true
    _avg?: JournalEntryAvgAggregateInputType
    _sum?: JournalEntrySumAggregateInputType
    _min?: JournalEntryMinAggregateInputType
    _max?: JournalEntryMaxAggregateInputType
  }

  export type JournalEntryGroupByOutputType = {
    id: string
    userId: string
    content: string
    date: Date
    mood: string | null
    stressLevel: number | null
    emotionScores: JsonValue | null
    topics: JsonValue | null
    sentiment: number | null
    createdAt: Date
    updatedAt: Date
    _count: JournalEntryCountAggregateOutputType | null
    _avg: JournalEntryAvgAggregateOutputType | null
    _sum: JournalEntrySumAggregateOutputType | null
    _min: JournalEntryMinAggregateOutputType | null
    _max: JournalEntryMaxAggregateOutputType | null
  }

  type GetJournalEntryGroupByPayload<T extends JournalEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JournalEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JournalEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JournalEntryGroupByOutputType[P]>
            : GetScalarType<T[P], JournalEntryGroupByOutputType[P]>
        }
      >
    >


  export type JournalEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    content?: boolean
    date?: boolean
    mood?: boolean
    stressLevel?: boolean
    emotionScores?: boolean
    topics?: boolean
    sentiment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalEntry"]>

  export type JournalEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    content?: boolean
    date?: boolean
    mood?: boolean
    stressLevel?: boolean
    emotionScores?: boolean
    topics?: boolean
    sentiment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalEntry"]>

  export type JournalEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    content?: boolean
    date?: boolean
    mood?: boolean
    stressLevel?: boolean
    emotionScores?: boolean
    topics?: boolean
    sentiment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalEntry"]>

  export type JournalEntrySelectScalar = {
    id?: boolean
    userId?: boolean
    content?: boolean
    date?: boolean
    mood?: boolean
    stressLevel?: boolean
    emotionScores?: boolean
    topics?: boolean
    sentiment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type JournalEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "content" | "date" | "mood" | "stressLevel" | "emotionScores" | "topics" | "sentiment" | "createdAt" | "updatedAt", ExtArgs["result"]["journalEntry"]>
  export type JournalEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type JournalEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type JournalEntryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $JournalEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JournalEntry"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      content: string
      date: Date
      mood: string | null
      stressLevel: number | null
      emotionScores: Prisma.JsonValue | null
      topics: Prisma.JsonValue | null
      sentiment: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["journalEntry"]>
    composites: {}
  }

  type JournalEntryGetPayload<S extends boolean | null | undefined | JournalEntryDefaultArgs> = $Result.GetResult<Prisma.$JournalEntryPayload, S>

  type JournalEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JournalEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JournalEntryCountAggregateInputType | true
    }

  export interface JournalEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JournalEntry'], meta: { name: 'JournalEntry' } }
    /**
     * Find zero or one JournalEntry that matches the filter.
     * @param {JournalEntryFindUniqueArgs} args - Arguments to find a JournalEntry
     * @example
     * // Get one JournalEntry
     * const journalEntry = await prisma.journalEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JournalEntryFindUniqueArgs>(args: SelectSubset<T, JournalEntryFindUniqueArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JournalEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JournalEntryFindUniqueOrThrowArgs} args - Arguments to find a JournalEntry
     * @example
     * // Get one JournalEntry
     * const journalEntry = await prisma.journalEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JournalEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, JournalEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JournalEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryFindFirstArgs} args - Arguments to find a JournalEntry
     * @example
     * // Get one JournalEntry
     * const journalEntry = await prisma.journalEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JournalEntryFindFirstArgs>(args?: SelectSubset<T, JournalEntryFindFirstArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JournalEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryFindFirstOrThrowArgs} args - Arguments to find a JournalEntry
     * @example
     * // Get one JournalEntry
     * const journalEntry = await prisma.journalEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JournalEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, JournalEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JournalEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JournalEntries
     * const journalEntries = await prisma.journalEntry.findMany()
     * 
     * // Get first 10 JournalEntries
     * const journalEntries = await prisma.journalEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const journalEntryWithIdOnly = await prisma.journalEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JournalEntryFindManyArgs>(args?: SelectSubset<T, JournalEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JournalEntry.
     * @param {JournalEntryCreateArgs} args - Arguments to create a JournalEntry.
     * @example
     * // Create one JournalEntry
     * const JournalEntry = await prisma.journalEntry.create({
     *   data: {
     *     // ... data to create a JournalEntry
     *   }
     * })
     * 
     */
    create<T extends JournalEntryCreateArgs>(args: SelectSubset<T, JournalEntryCreateArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JournalEntries.
     * @param {JournalEntryCreateManyArgs} args - Arguments to create many JournalEntries.
     * @example
     * // Create many JournalEntries
     * const journalEntry = await prisma.journalEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JournalEntryCreateManyArgs>(args?: SelectSubset<T, JournalEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JournalEntries and returns the data saved in the database.
     * @param {JournalEntryCreateManyAndReturnArgs} args - Arguments to create many JournalEntries.
     * @example
     * // Create many JournalEntries
     * const journalEntry = await prisma.journalEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JournalEntries and only return the `id`
     * const journalEntryWithIdOnly = await prisma.journalEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JournalEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, JournalEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JournalEntry.
     * @param {JournalEntryDeleteArgs} args - Arguments to delete one JournalEntry.
     * @example
     * // Delete one JournalEntry
     * const JournalEntry = await prisma.journalEntry.delete({
     *   where: {
     *     // ... filter to delete one JournalEntry
     *   }
     * })
     * 
     */
    delete<T extends JournalEntryDeleteArgs>(args: SelectSubset<T, JournalEntryDeleteArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JournalEntry.
     * @param {JournalEntryUpdateArgs} args - Arguments to update one JournalEntry.
     * @example
     * // Update one JournalEntry
     * const journalEntry = await prisma.journalEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JournalEntryUpdateArgs>(args: SelectSubset<T, JournalEntryUpdateArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JournalEntries.
     * @param {JournalEntryDeleteManyArgs} args - Arguments to filter JournalEntries to delete.
     * @example
     * // Delete a few JournalEntries
     * const { count } = await prisma.journalEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JournalEntryDeleteManyArgs>(args?: SelectSubset<T, JournalEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JournalEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JournalEntries
     * const journalEntry = await prisma.journalEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JournalEntryUpdateManyArgs>(args: SelectSubset<T, JournalEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JournalEntries and returns the data updated in the database.
     * @param {JournalEntryUpdateManyAndReturnArgs} args - Arguments to update many JournalEntries.
     * @example
     * // Update many JournalEntries
     * const journalEntry = await prisma.journalEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JournalEntries and only return the `id`
     * const journalEntryWithIdOnly = await prisma.journalEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JournalEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, JournalEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JournalEntry.
     * @param {JournalEntryUpsertArgs} args - Arguments to update or create a JournalEntry.
     * @example
     * // Update or create a JournalEntry
     * const journalEntry = await prisma.journalEntry.upsert({
     *   create: {
     *     // ... data to create a JournalEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JournalEntry we want to update
     *   }
     * })
     */
    upsert<T extends JournalEntryUpsertArgs>(args: SelectSubset<T, JournalEntryUpsertArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JournalEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryCountArgs} args - Arguments to filter JournalEntries to count.
     * @example
     * // Count the number of JournalEntries
     * const count = await prisma.journalEntry.count({
     *   where: {
     *     // ... the filter for the JournalEntries we want to count
     *   }
     * })
    **/
    count<T extends JournalEntryCountArgs>(
      args?: Subset<T, JournalEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JournalEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JournalEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JournalEntryAggregateArgs>(args: Subset<T, JournalEntryAggregateArgs>): Prisma.PrismaPromise<GetJournalEntryAggregateType<T>>

    /**
     * Group by JournalEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JournalEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JournalEntryGroupByArgs['orderBy'] }
        : { orderBy?: JournalEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JournalEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJournalEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JournalEntry model
   */
  readonly fields: JournalEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JournalEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JournalEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JournalEntry model
   */
  interface JournalEntryFieldRefs {
    readonly id: FieldRef<"JournalEntry", 'String'>
    readonly userId: FieldRef<"JournalEntry", 'String'>
    readonly content: FieldRef<"JournalEntry", 'String'>
    readonly date: FieldRef<"JournalEntry", 'DateTime'>
    readonly mood: FieldRef<"JournalEntry", 'String'>
    readonly stressLevel: FieldRef<"JournalEntry", 'Int'>
    readonly emotionScores: FieldRef<"JournalEntry", 'Json'>
    readonly topics: FieldRef<"JournalEntry", 'Json'>
    readonly sentiment: FieldRef<"JournalEntry", 'Float'>
    readonly createdAt: FieldRef<"JournalEntry", 'DateTime'>
    readonly updatedAt: FieldRef<"JournalEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * JournalEntry findUnique
   */
  export type JournalEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter, which JournalEntry to fetch.
     */
    where: JournalEntryWhereUniqueInput
  }

  /**
   * JournalEntry findUniqueOrThrow
   */
  export type JournalEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter, which JournalEntry to fetch.
     */
    where: JournalEntryWhereUniqueInput
  }

  /**
   * JournalEntry findFirst
   */
  export type JournalEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter, which JournalEntry to fetch.
     */
    where?: JournalEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalEntries to fetch.
     */
    orderBy?: JournalEntryOrderByWithRelationInput | JournalEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalEntries.
     */
    cursor?: JournalEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalEntries.
     */
    distinct?: JournalEntryScalarFieldEnum | JournalEntryScalarFieldEnum[]
  }

  /**
   * JournalEntry findFirstOrThrow
   */
  export type JournalEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter, which JournalEntry to fetch.
     */
    where?: JournalEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalEntries to fetch.
     */
    orderBy?: JournalEntryOrderByWithRelationInput | JournalEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalEntries.
     */
    cursor?: JournalEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalEntries.
     */
    distinct?: JournalEntryScalarFieldEnum | JournalEntryScalarFieldEnum[]
  }

  /**
   * JournalEntry findMany
   */
  export type JournalEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter, which JournalEntries to fetch.
     */
    where?: JournalEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalEntries to fetch.
     */
    orderBy?: JournalEntryOrderByWithRelationInput | JournalEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JournalEntries.
     */
    cursor?: JournalEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalEntries.
     */
    skip?: number
    distinct?: JournalEntryScalarFieldEnum | JournalEntryScalarFieldEnum[]
  }

  /**
   * JournalEntry create
   */
  export type JournalEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a JournalEntry.
     */
    data: XOR<JournalEntryCreateInput, JournalEntryUncheckedCreateInput>
  }

  /**
   * JournalEntry createMany
   */
  export type JournalEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JournalEntries.
     */
    data: JournalEntryCreateManyInput | JournalEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JournalEntry createManyAndReturn
   */
  export type JournalEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * The data used to create many JournalEntries.
     */
    data: JournalEntryCreateManyInput | JournalEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JournalEntry update
   */
  export type JournalEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a JournalEntry.
     */
    data: XOR<JournalEntryUpdateInput, JournalEntryUncheckedUpdateInput>
    /**
     * Choose, which JournalEntry to update.
     */
    where: JournalEntryWhereUniqueInput
  }

  /**
   * JournalEntry updateMany
   */
  export type JournalEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JournalEntries.
     */
    data: XOR<JournalEntryUpdateManyMutationInput, JournalEntryUncheckedUpdateManyInput>
    /**
     * Filter which JournalEntries to update
     */
    where?: JournalEntryWhereInput
    /**
     * Limit how many JournalEntries to update.
     */
    limit?: number
  }

  /**
   * JournalEntry updateManyAndReturn
   */
  export type JournalEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * The data used to update JournalEntries.
     */
    data: XOR<JournalEntryUpdateManyMutationInput, JournalEntryUncheckedUpdateManyInput>
    /**
     * Filter which JournalEntries to update
     */
    where?: JournalEntryWhereInput
    /**
     * Limit how many JournalEntries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JournalEntry upsert
   */
  export type JournalEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the JournalEntry to update in case it exists.
     */
    where: JournalEntryWhereUniqueInput
    /**
     * In case the JournalEntry found by the `where` argument doesn't exist, create a new JournalEntry with this data.
     */
    create: XOR<JournalEntryCreateInput, JournalEntryUncheckedCreateInput>
    /**
     * In case the JournalEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JournalEntryUpdateInput, JournalEntryUncheckedUpdateInput>
  }

  /**
   * JournalEntry delete
   */
  export type JournalEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter which JournalEntry to delete.
     */
    where: JournalEntryWhereUniqueInput
  }

  /**
   * JournalEntry deleteMany
   */
  export type JournalEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalEntries to delete
     */
    where?: JournalEntryWhereInput
    /**
     * Limit how many JournalEntries to delete.
     */
    limit?: number
  }

  /**
   * JournalEntry without action
   */
  export type JournalEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
  }


  /**
   * Model Habit
   */

  export type AggregateHabit = {
    _count: HabitCountAggregateOutputType | null
    _avg: HabitAvgAggregateOutputType | null
    _sum: HabitSumAggregateOutputType | null
    _min: HabitMinAggregateOutputType | null
    _max: HabitMaxAggregateOutputType | null
  }

  export type HabitAvgAggregateOutputType = {
    difficultyLevel: number | null
  }

  export type HabitSumAggregateOutputType = {
    difficultyLevel: number | null
  }

  export type HabitMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    isCompleted: boolean | null
    date: Date | null
    aiSuggested: boolean | null
    difficultyLevel: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HabitMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    isCompleted: boolean | null
    date: Date | null
    aiSuggested: boolean | null
    difficultyLevel: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HabitCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    isCompleted: number
    date: number
    aiSuggested: number
    adaptiveReminder: number
    difficultyLevel: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HabitAvgAggregateInputType = {
    difficultyLevel?: true
  }

  export type HabitSumAggregateInputType = {
    difficultyLevel?: true
  }

  export type HabitMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    isCompleted?: true
    date?: true
    aiSuggested?: true
    difficultyLevel?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HabitMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    isCompleted?: true
    date?: true
    aiSuggested?: true
    difficultyLevel?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HabitCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    isCompleted?: true
    date?: true
    aiSuggested?: true
    adaptiveReminder?: true
    difficultyLevel?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HabitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Habit to aggregate.
     */
    where?: HabitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Habits to fetch.
     */
    orderBy?: HabitOrderByWithRelationInput | HabitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HabitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Habits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Habits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Habits
    **/
    _count?: true | HabitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HabitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HabitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HabitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HabitMaxAggregateInputType
  }

  export type GetHabitAggregateType<T extends HabitAggregateArgs> = {
        [P in keyof T & keyof AggregateHabit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHabit[P]>
      : GetScalarType<T[P], AggregateHabit[P]>
  }




  export type HabitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HabitWhereInput
    orderBy?: HabitOrderByWithAggregationInput | HabitOrderByWithAggregationInput[]
    by: HabitScalarFieldEnum[] | HabitScalarFieldEnum
    having?: HabitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HabitCountAggregateInputType | true
    _avg?: HabitAvgAggregateInputType
    _sum?: HabitSumAggregateInputType
    _min?: HabitMinAggregateInputType
    _max?: HabitMaxAggregateInputType
  }

  export type HabitGroupByOutputType = {
    id: string
    userId: string
    title: string
    isCompleted: boolean
    date: Date
    aiSuggested: boolean
    adaptiveReminder: JsonValue | null
    difficultyLevel: number | null
    createdAt: Date
    updatedAt: Date
    _count: HabitCountAggregateOutputType | null
    _avg: HabitAvgAggregateOutputType | null
    _sum: HabitSumAggregateOutputType | null
    _min: HabitMinAggregateOutputType | null
    _max: HabitMaxAggregateOutputType | null
  }

  type GetHabitGroupByPayload<T extends HabitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HabitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HabitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HabitGroupByOutputType[P]>
            : GetScalarType<T[P], HabitGroupByOutputType[P]>
        }
      >
    >


  export type HabitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    isCompleted?: boolean
    date?: boolean
    aiSuggested?: boolean
    adaptiveReminder?: boolean
    difficultyLevel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["habit"]>

  export type HabitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    isCompleted?: boolean
    date?: boolean
    aiSuggested?: boolean
    adaptiveReminder?: boolean
    difficultyLevel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["habit"]>

  export type HabitSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    isCompleted?: boolean
    date?: boolean
    aiSuggested?: boolean
    adaptiveReminder?: boolean
    difficultyLevel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["habit"]>

  export type HabitSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    isCompleted?: boolean
    date?: boolean
    aiSuggested?: boolean
    adaptiveReminder?: boolean
    difficultyLevel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HabitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "isCompleted" | "date" | "aiSuggested" | "adaptiveReminder" | "difficultyLevel" | "createdAt" | "updatedAt", ExtArgs["result"]["habit"]>
  export type HabitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type HabitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type HabitIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $HabitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Habit"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      isCompleted: boolean
      date: Date
      aiSuggested: boolean
      adaptiveReminder: Prisma.JsonValue | null
      difficultyLevel: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["habit"]>
    composites: {}
  }

  type HabitGetPayload<S extends boolean | null | undefined | HabitDefaultArgs> = $Result.GetResult<Prisma.$HabitPayload, S>

  type HabitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HabitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HabitCountAggregateInputType | true
    }

  export interface HabitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Habit'], meta: { name: 'Habit' } }
    /**
     * Find zero or one Habit that matches the filter.
     * @param {HabitFindUniqueArgs} args - Arguments to find a Habit
     * @example
     * // Get one Habit
     * const habit = await prisma.habit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HabitFindUniqueArgs>(args: SelectSubset<T, HabitFindUniqueArgs<ExtArgs>>): Prisma__HabitClient<$Result.GetResult<Prisma.$HabitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Habit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HabitFindUniqueOrThrowArgs} args - Arguments to find a Habit
     * @example
     * // Get one Habit
     * const habit = await prisma.habit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HabitFindUniqueOrThrowArgs>(args: SelectSubset<T, HabitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HabitClient<$Result.GetResult<Prisma.$HabitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Habit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitFindFirstArgs} args - Arguments to find a Habit
     * @example
     * // Get one Habit
     * const habit = await prisma.habit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HabitFindFirstArgs>(args?: SelectSubset<T, HabitFindFirstArgs<ExtArgs>>): Prisma__HabitClient<$Result.GetResult<Prisma.$HabitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Habit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitFindFirstOrThrowArgs} args - Arguments to find a Habit
     * @example
     * // Get one Habit
     * const habit = await prisma.habit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HabitFindFirstOrThrowArgs>(args?: SelectSubset<T, HabitFindFirstOrThrowArgs<ExtArgs>>): Prisma__HabitClient<$Result.GetResult<Prisma.$HabitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Habits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Habits
     * const habits = await prisma.habit.findMany()
     * 
     * // Get first 10 Habits
     * const habits = await prisma.habit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const habitWithIdOnly = await prisma.habit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HabitFindManyArgs>(args?: SelectSubset<T, HabitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HabitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Habit.
     * @param {HabitCreateArgs} args - Arguments to create a Habit.
     * @example
     * // Create one Habit
     * const Habit = await prisma.habit.create({
     *   data: {
     *     // ... data to create a Habit
     *   }
     * })
     * 
     */
    create<T extends HabitCreateArgs>(args: SelectSubset<T, HabitCreateArgs<ExtArgs>>): Prisma__HabitClient<$Result.GetResult<Prisma.$HabitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Habits.
     * @param {HabitCreateManyArgs} args - Arguments to create many Habits.
     * @example
     * // Create many Habits
     * const habit = await prisma.habit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HabitCreateManyArgs>(args?: SelectSubset<T, HabitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Habits and returns the data saved in the database.
     * @param {HabitCreateManyAndReturnArgs} args - Arguments to create many Habits.
     * @example
     * // Create many Habits
     * const habit = await prisma.habit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Habits and only return the `id`
     * const habitWithIdOnly = await prisma.habit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HabitCreateManyAndReturnArgs>(args?: SelectSubset<T, HabitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HabitPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Habit.
     * @param {HabitDeleteArgs} args - Arguments to delete one Habit.
     * @example
     * // Delete one Habit
     * const Habit = await prisma.habit.delete({
     *   where: {
     *     // ... filter to delete one Habit
     *   }
     * })
     * 
     */
    delete<T extends HabitDeleteArgs>(args: SelectSubset<T, HabitDeleteArgs<ExtArgs>>): Prisma__HabitClient<$Result.GetResult<Prisma.$HabitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Habit.
     * @param {HabitUpdateArgs} args - Arguments to update one Habit.
     * @example
     * // Update one Habit
     * const habit = await prisma.habit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HabitUpdateArgs>(args: SelectSubset<T, HabitUpdateArgs<ExtArgs>>): Prisma__HabitClient<$Result.GetResult<Prisma.$HabitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Habits.
     * @param {HabitDeleteManyArgs} args - Arguments to filter Habits to delete.
     * @example
     * // Delete a few Habits
     * const { count } = await prisma.habit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HabitDeleteManyArgs>(args?: SelectSubset<T, HabitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Habits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Habits
     * const habit = await prisma.habit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HabitUpdateManyArgs>(args: SelectSubset<T, HabitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Habits and returns the data updated in the database.
     * @param {HabitUpdateManyAndReturnArgs} args - Arguments to update many Habits.
     * @example
     * // Update many Habits
     * const habit = await prisma.habit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Habits and only return the `id`
     * const habitWithIdOnly = await prisma.habit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HabitUpdateManyAndReturnArgs>(args: SelectSubset<T, HabitUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HabitPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Habit.
     * @param {HabitUpsertArgs} args - Arguments to update or create a Habit.
     * @example
     * // Update or create a Habit
     * const habit = await prisma.habit.upsert({
     *   create: {
     *     // ... data to create a Habit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Habit we want to update
     *   }
     * })
     */
    upsert<T extends HabitUpsertArgs>(args: SelectSubset<T, HabitUpsertArgs<ExtArgs>>): Prisma__HabitClient<$Result.GetResult<Prisma.$HabitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Habits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitCountArgs} args - Arguments to filter Habits to count.
     * @example
     * // Count the number of Habits
     * const count = await prisma.habit.count({
     *   where: {
     *     // ... the filter for the Habits we want to count
     *   }
     * })
    **/
    count<T extends HabitCountArgs>(
      args?: Subset<T, HabitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HabitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Habit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HabitAggregateArgs>(args: Subset<T, HabitAggregateArgs>): Prisma.PrismaPromise<GetHabitAggregateType<T>>

    /**
     * Group by Habit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HabitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HabitGroupByArgs['orderBy'] }
        : { orderBy?: HabitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HabitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHabitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Habit model
   */
  readonly fields: HabitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Habit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HabitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Habit model
   */
  interface HabitFieldRefs {
    readonly id: FieldRef<"Habit", 'String'>
    readonly userId: FieldRef<"Habit", 'String'>
    readonly title: FieldRef<"Habit", 'String'>
    readonly isCompleted: FieldRef<"Habit", 'Boolean'>
    readonly date: FieldRef<"Habit", 'DateTime'>
    readonly aiSuggested: FieldRef<"Habit", 'Boolean'>
    readonly adaptiveReminder: FieldRef<"Habit", 'Json'>
    readonly difficultyLevel: FieldRef<"Habit", 'Int'>
    readonly createdAt: FieldRef<"Habit", 'DateTime'>
    readonly updatedAt: FieldRef<"Habit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Habit findUnique
   */
  export type HabitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Habit
     */
    select?: HabitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Habit
     */
    omit?: HabitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitInclude<ExtArgs> | null
    /**
     * Filter, which Habit to fetch.
     */
    where: HabitWhereUniqueInput
  }

  /**
   * Habit findUniqueOrThrow
   */
  export type HabitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Habit
     */
    select?: HabitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Habit
     */
    omit?: HabitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitInclude<ExtArgs> | null
    /**
     * Filter, which Habit to fetch.
     */
    where: HabitWhereUniqueInput
  }

  /**
   * Habit findFirst
   */
  export type HabitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Habit
     */
    select?: HabitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Habit
     */
    omit?: HabitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitInclude<ExtArgs> | null
    /**
     * Filter, which Habit to fetch.
     */
    where?: HabitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Habits to fetch.
     */
    orderBy?: HabitOrderByWithRelationInput | HabitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Habits.
     */
    cursor?: HabitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Habits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Habits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Habits.
     */
    distinct?: HabitScalarFieldEnum | HabitScalarFieldEnum[]
  }

  /**
   * Habit findFirstOrThrow
   */
  export type HabitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Habit
     */
    select?: HabitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Habit
     */
    omit?: HabitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitInclude<ExtArgs> | null
    /**
     * Filter, which Habit to fetch.
     */
    where?: HabitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Habits to fetch.
     */
    orderBy?: HabitOrderByWithRelationInput | HabitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Habits.
     */
    cursor?: HabitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Habits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Habits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Habits.
     */
    distinct?: HabitScalarFieldEnum | HabitScalarFieldEnum[]
  }

  /**
   * Habit findMany
   */
  export type HabitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Habit
     */
    select?: HabitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Habit
     */
    omit?: HabitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitInclude<ExtArgs> | null
    /**
     * Filter, which Habits to fetch.
     */
    where?: HabitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Habits to fetch.
     */
    orderBy?: HabitOrderByWithRelationInput | HabitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Habits.
     */
    cursor?: HabitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Habits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Habits.
     */
    skip?: number
    distinct?: HabitScalarFieldEnum | HabitScalarFieldEnum[]
  }

  /**
   * Habit create
   */
  export type HabitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Habit
     */
    select?: HabitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Habit
     */
    omit?: HabitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitInclude<ExtArgs> | null
    /**
     * The data needed to create a Habit.
     */
    data: XOR<HabitCreateInput, HabitUncheckedCreateInput>
  }

  /**
   * Habit createMany
   */
  export type HabitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Habits.
     */
    data: HabitCreateManyInput | HabitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Habit createManyAndReturn
   */
  export type HabitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Habit
     */
    select?: HabitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Habit
     */
    omit?: HabitOmit<ExtArgs> | null
    /**
     * The data used to create many Habits.
     */
    data: HabitCreateManyInput | HabitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Habit update
   */
  export type HabitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Habit
     */
    select?: HabitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Habit
     */
    omit?: HabitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitInclude<ExtArgs> | null
    /**
     * The data needed to update a Habit.
     */
    data: XOR<HabitUpdateInput, HabitUncheckedUpdateInput>
    /**
     * Choose, which Habit to update.
     */
    where: HabitWhereUniqueInput
  }

  /**
   * Habit updateMany
   */
  export type HabitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Habits.
     */
    data: XOR<HabitUpdateManyMutationInput, HabitUncheckedUpdateManyInput>
    /**
     * Filter which Habits to update
     */
    where?: HabitWhereInput
    /**
     * Limit how many Habits to update.
     */
    limit?: number
  }

  /**
   * Habit updateManyAndReturn
   */
  export type HabitUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Habit
     */
    select?: HabitSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Habit
     */
    omit?: HabitOmit<ExtArgs> | null
    /**
     * The data used to update Habits.
     */
    data: XOR<HabitUpdateManyMutationInput, HabitUncheckedUpdateManyInput>
    /**
     * Filter which Habits to update
     */
    where?: HabitWhereInput
    /**
     * Limit how many Habits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Habit upsert
   */
  export type HabitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Habit
     */
    select?: HabitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Habit
     */
    omit?: HabitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitInclude<ExtArgs> | null
    /**
     * The filter to search for the Habit to update in case it exists.
     */
    where: HabitWhereUniqueInput
    /**
     * In case the Habit found by the `where` argument doesn't exist, create a new Habit with this data.
     */
    create: XOR<HabitCreateInput, HabitUncheckedCreateInput>
    /**
     * In case the Habit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HabitUpdateInput, HabitUncheckedUpdateInput>
  }

  /**
   * Habit delete
   */
  export type HabitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Habit
     */
    select?: HabitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Habit
     */
    omit?: HabitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitInclude<ExtArgs> | null
    /**
     * Filter which Habit to delete.
     */
    where: HabitWhereUniqueInput
  }

  /**
   * Habit deleteMany
   */
  export type HabitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Habits to delete
     */
    where?: HabitWhereInput
    /**
     * Limit how many Habits to delete.
     */
    limit?: number
  }

  /**
   * Habit without action
   */
  export type HabitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Habit
     */
    select?: HabitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Habit
     */
    omit?: HabitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitInclude<ExtArgs> | null
  }


  /**
   * Model Class
   */

  export type AggregateClass = {
    _count: ClassCountAggregateOutputType | null
    _avg: ClassAvgAggregateOutputType | null
    _sum: ClassSumAggregateOutputType | null
    _min: ClassMinAggregateOutputType | null
    _max: ClassMaxAggregateOutputType | null
  }

  export type ClassAvgAggregateOutputType = {
    durationMins: number | null
    capacity: number | null
    stressLevel: number | null
  }

  export type ClassSumAggregateOutputType = {
    durationMins: number | null
    capacity: number | null
    stressLevel: number | null
  }

  export type ClassMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    startTime: Date | null
    durationMins: number | null
    instructor: string | null
    imageUrl: string | null
    capacity: number | null
    intensity: string | null
    stressLevel: number | null
    aiOptimized: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClassMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    startTime: Date | null
    durationMins: number | null
    instructor: string | null
    imageUrl: string | null
    capacity: number | null
    intensity: string | null
    stressLevel: number | null
    aiOptimized: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClassCountAggregateOutputType = {
    id: number
    title: number
    description: number
    startTime: number
    durationMins: number
    instructor: number
    imageUrl: number
    capacity: number
    intensity: number
    stressLevel: number
    aiOptimized: number
    adaptiveContent: number
    prerequisites: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClassAvgAggregateInputType = {
    durationMins?: true
    capacity?: true
    stressLevel?: true
  }

  export type ClassSumAggregateInputType = {
    durationMins?: true
    capacity?: true
    stressLevel?: true
  }

  export type ClassMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    startTime?: true
    durationMins?: true
    instructor?: true
    imageUrl?: true
    capacity?: true
    intensity?: true
    stressLevel?: true
    aiOptimized?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClassMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    startTime?: true
    durationMins?: true
    instructor?: true
    imageUrl?: true
    capacity?: true
    intensity?: true
    stressLevel?: true
    aiOptimized?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClassCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    startTime?: true
    durationMins?: true
    instructor?: true
    imageUrl?: true
    capacity?: true
    intensity?: true
    stressLevel?: true
    aiOptimized?: true
    adaptiveContent?: true
    prerequisites?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClassAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Class to aggregate.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Classes
    **/
    _count?: true | ClassCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClassAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClassSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassMaxAggregateInputType
  }

  export type GetClassAggregateType<T extends ClassAggregateArgs> = {
        [P in keyof T & keyof AggregateClass]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClass[P]>
      : GetScalarType<T[P], AggregateClass[P]>
  }




  export type ClassGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithAggregationInput | ClassOrderByWithAggregationInput[]
    by: ClassScalarFieldEnum[] | ClassScalarFieldEnum
    having?: ClassScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassCountAggregateInputType | true
    _avg?: ClassAvgAggregateInputType
    _sum?: ClassSumAggregateInputType
    _min?: ClassMinAggregateInputType
    _max?: ClassMaxAggregateInputType
  }

  export type ClassGroupByOutputType = {
    id: string
    title: string
    description: string | null
    startTime: Date
    durationMins: number
    instructor: string
    imageUrl: string | null
    capacity: number
    intensity: string
    stressLevel: number | null
    aiOptimized: boolean
    adaptiveContent: JsonValue | null
    prerequisites: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ClassCountAggregateOutputType | null
    _avg: ClassAvgAggregateOutputType | null
    _sum: ClassSumAggregateOutputType | null
    _min: ClassMinAggregateOutputType | null
    _max: ClassMaxAggregateOutputType | null
  }

  type GetClassGroupByPayload<T extends ClassGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassGroupByOutputType[P]>
            : GetScalarType<T[P], ClassGroupByOutputType[P]>
        }
      >
    >


  export type ClassSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    startTime?: boolean
    durationMins?: boolean
    instructor?: boolean
    imageUrl?: boolean
    capacity?: boolean
    intensity?: boolean
    stressLevel?: boolean
    aiOptimized?: boolean
    adaptiveContent?: boolean
    prerequisites?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookings?: boolean | Class$bookingsArgs<ExtArgs>
    _count?: boolean | ClassCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["class"]>

  export type ClassSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    startTime?: boolean
    durationMins?: boolean
    instructor?: boolean
    imageUrl?: boolean
    capacity?: boolean
    intensity?: boolean
    stressLevel?: boolean
    aiOptimized?: boolean
    adaptiveContent?: boolean
    prerequisites?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["class"]>

  export type ClassSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    startTime?: boolean
    durationMins?: boolean
    instructor?: boolean
    imageUrl?: boolean
    capacity?: boolean
    intensity?: boolean
    stressLevel?: boolean
    aiOptimized?: boolean
    adaptiveContent?: boolean
    prerequisites?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["class"]>

  export type ClassSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    startTime?: boolean
    durationMins?: boolean
    instructor?: boolean
    imageUrl?: boolean
    capacity?: boolean
    intensity?: boolean
    stressLevel?: boolean
    aiOptimized?: boolean
    adaptiveContent?: boolean
    prerequisites?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClassOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "startTime" | "durationMins" | "instructor" | "imageUrl" | "capacity" | "intensity" | "stressLevel" | "aiOptimized" | "adaptiveContent" | "prerequisites" | "createdAt" | "updatedAt", ExtArgs["result"]["class"]>
  export type ClassInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | Class$bookingsArgs<ExtArgs>
    _count?: boolean | ClassCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClassIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ClassIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ClassPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Class"
    objects: {
      bookings: Prisma.$BookingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      startTime: Date
      durationMins: number
      instructor: string
      imageUrl: string | null
      capacity: number
      intensity: string
      stressLevel: number | null
      aiOptimized: boolean
      adaptiveContent: Prisma.JsonValue | null
      prerequisites: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["class"]>
    composites: {}
  }

  type ClassGetPayload<S extends boolean | null | undefined | ClassDefaultArgs> = $Result.GetResult<Prisma.$ClassPayload, S>

  type ClassCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClassFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClassCountAggregateInputType | true
    }

  export interface ClassDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Class'], meta: { name: 'Class' } }
    /**
     * Find zero or one Class that matches the filter.
     * @param {ClassFindUniqueArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassFindUniqueArgs>(args: SelectSubset<T, ClassFindUniqueArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Class that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClassFindUniqueOrThrowArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Class that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindFirstArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassFindFirstArgs>(args?: SelectSubset<T, ClassFindFirstArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Class that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindFirstOrThrowArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Classes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Classes
     * const classes = await prisma.class.findMany()
     * 
     * // Get first 10 Classes
     * const classes = await prisma.class.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classWithIdOnly = await prisma.class.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassFindManyArgs>(args?: SelectSubset<T, ClassFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Class.
     * @param {ClassCreateArgs} args - Arguments to create a Class.
     * @example
     * // Create one Class
     * const Class = await prisma.class.create({
     *   data: {
     *     // ... data to create a Class
     *   }
     * })
     * 
     */
    create<T extends ClassCreateArgs>(args: SelectSubset<T, ClassCreateArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Classes.
     * @param {ClassCreateManyArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const class = await prisma.class.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassCreateManyArgs>(args?: SelectSubset<T, ClassCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Classes and returns the data saved in the database.
     * @param {ClassCreateManyAndReturnArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const class = await prisma.class.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Classes and only return the `id`
     * const classWithIdOnly = await prisma.class.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClassCreateManyAndReturnArgs>(args?: SelectSubset<T, ClassCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Class.
     * @param {ClassDeleteArgs} args - Arguments to delete one Class.
     * @example
     * // Delete one Class
     * const Class = await prisma.class.delete({
     *   where: {
     *     // ... filter to delete one Class
     *   }
     * })
     * 
     */
    delete<T extends ClassDeleteArgs>(args: SelectSubset<T, ClassDeleteArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Class.
     * @param {ClassUpdateArgs} args - Arguments to update one Class.
     * @example
     * // Update one Class
     * const class = await prisma.class.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassUpdateArgs>(args: SelectSubset<T, ClassUpdateArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Classes.
     * @param {ClassDeleteManyArgs} args - Arguments to filter Classes to delete.
     * @example
     * // Delete a few Classes
     * const { count } = await prisma.class.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassDeleteManyArgs>(args?: SelectSubset<T, ClassDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Classes
     * const class = await prisma.class.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassUpdateManyArgs>(args: SelectSubset<T, ClassUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classes and returns the data updated in the database.
     * @param {ClassUpdateManyAndReturnArgs} args - Arguments to update many Classes.
     * @example
     * // Update many Classes
     * const class = await prisma.class.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Classes and only return the `id`
     * const classWithIdOnly = await prisma.class.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClassUpdateManyAndReturnArgs>(args: SelectSubset<T, ClassUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Class.
     * @param {ClassUpsertArgs} args - Arguments to update or create a Class.
     * @example
     * // Update or create a Class
     * const class = await prisma.class.upsert({
     *   create: {
     *     // ... data to create a Class
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Class we want to update
     *   }
     * })
     */
    upsert<T extends ClassUpsertArgs>(args: SelectSubset<T, ClassUpsertArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassCountArgs} args - Arguments to filter Classes to count.
     * @example
     * // Count the number of Classes
     * const count = await prisma.class.count({
     *   where: {
     *     // ... the filter for the Classes we want to count
     *   }
     * })
    **/
    count<T extends ClassCountArgs>(
      args?: Subset<T, ClassCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassAggregateArgs>(args: Subset<T, ClassAggregateArgs>): Prisma.PrismaPromise<GetClassAggregateType<T>>

    /**
     * Group by Class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassGroupByArgs['orderBy'] }
        : { orderBy?: ClassGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Class model
   */
  readonly fields: ClassFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Class.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookings<T extends Class$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Class$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Class model
   */
  interface ClassFieldRefs {
    readonly id: FieldRef<"Class", 'String'>
    readonly title: FieldRef<"Class", 'String'>
    readonly description: FieldRef<"Class", 'String'>
    readonly startTime: FieldRef<"Class", 'DateTime'>
    readonly durationMins: FieldRef<"Class", 'Int'>
    readonly instructor: FieldRef<"Class", 'String'>
    readonly imageUrl: FieldRef<"Class", 'String'>
    readonly capacity: FieldRef<"Class", 'Int'>
    readonly intensity: FieldRef<"Class", 'String'>
    readonly stressLevel: FieldRef<"Class", 'Int'>
    readonly aiOptimized: FieldRef<"Class", 'Boolean'>
    readonly adaptiveContent: FieldRef<"Class", 'Json'>
    readonly prerequisites: FieldRef<"Class", 'Json'>
    readonly createdAt: FieldRef<"Class", 'DateTime'>
    readonly updatedAt: FieldRef<"Class", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Class findUnique
   */
  export type ClassFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class findUniqueOrThrow
   */
  export type ClassFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class findFirst
   */
  export type ClassFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class findFirstOrThrow
   */
  export type ClassFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class findMany
   */
  export type ClassFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Classes to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class create
   */
  export type ClassCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The data needed to create a Class.
     */
    data: XOR<ClassCreateInput, ClassUncheckedCreateInput>
  }

  /**
   * Class createMany
   */
  export type ClassCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Classes.
     */
    data: ClassCreateManyInput | ClassCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Class createManyAndReturn
   */
  export type ClassCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * The data used to create many Classes.
     */
    data: ClassCreateManyInput | ClassCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Class update
   */
  export type ClassUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The data needed to update a Class.
     */
    data: XOR<ClassUpdateInput, ClassUncheckedUpdateInput>
    /**
     * Choose, which Class to update.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class updateMany
   */
  export type ClassUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Classes.
     */
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyInput>
    /**
     * Filter which Classes to update
     */
    where?: ClassWhereInput
    /**
     * Limit how many Classes to update.
     */
    limit?: number
  }

  /**
   * Class updateManyAndReturn
   */
  export type ClassUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * The data used to update Classes.
     */
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyInput>
    /**
     * Filter which Classes to update
     */
    where?: ClassWhereInput
    /**
     * Limit how many Classes to update.
     */
    limit?: number
  }

  /**
   * Class upsert
   */
  export type ClassUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The filter to search for the Class to update in case it exists.
     */
    where: ClassWhereUniqueInput
    /**
     * In case the Class found by the `where` argument doesn't exist, create a new Class with this data.
     */
    create: XOR<ClassCreateInput, ClassUncheckedCreateInput>
    /**
     * In case the Class was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassUpdateInput, ClassUncheckedUpdateInput>
  }

  /**
   * Class delete
   */
  export type ClassDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter which Class to delete.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class deleteMany
   */
  export type ClassDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Classes to delete
     */
    where?: ClassWhereInput
    /**
     * Limit how many Classes to delete.
     */
    limit?: number
  }

  /**
   * Class.bookings
   */
  export type Class$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Class without action
   */
  export type ClassDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
  }


  /**
   * Model Booking
   */

  export type AggregateBooking = {
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  export type BookingAvgAggregateOutputType = {
    predictedEffectiveness: number | null
  }

  export type BookingSumAggregateOutputType = {
    predictedEffectiveness: number | null
  }

  export type BookingMinAggregateOutputType = {
    id: string | null
    userId: string | null
    classId: string | null
    aiSuggested: boolean | null
    predictedEffectiveness: number | null
    createdAt: Date | null
  }

  export type BookingMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    classId: string | null
    aiSuggested: boolean | null
    predictedEffectiveness: number | null
    createdAt: Date | null
  }

  export type BookingCountAggregateOutputType = {
    id: number
    userId: number
    classId: number
    aiSuggested: number
    predictedEffectiveness: number
    createdAt: number
    _all: number
  }


  export type BookingAvgAggregateInputType = {
    predictedEffectiveness?: true
  }

  export type BookingSumAggregateInputType = {
    predictedEffectiveness?: true
  }

  export type BookingMinAggregateInputType = {
    id?: true
    userId?: true
    classId?: true
    aiSuggested?: true
    predictedEffectiveness?: true
    createdAt?: true
  }

  export type BookingMaxAggregateInputType = {
    id?: true
    userId?: true
    classId?: true
    aiSuggested?: true
    predictedEffectiveness?: true
    createdAt?: true
  }

  export type BookingCountAggregateInputType = {
    id?: true
    userId?: true
    classId?: true
    aiSuggested?: true
    predictedEffectiveness?: true
    createdAt?: true
    _all?: true
  }

  export type BookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Booking to aggregate.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bookings
    **/
    _count?: true | BookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingMaxAggregateInputType
  }

  export type GetBookingAggregateType<T extends BookingAggregateArgs> = {
        [P in keyof T & keyof AggregateBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBooking[P]>
      : GetScalarType<T[P], AggregateBooking[P]>
  }




  export type BookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithAggregationInput | BookingOrderByWithAggregationInput[]
    by: BookingScalarFieldEnum[] | BookingScalarFieldEnum
    having?: BookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingCountAggregateInputType | true
    _avg?: BookingAvgAggregateInputType
    _sum?: BookingSumAggregateInputType
    _min?: BookingMinAggregateInputType
    _max?: BookingMaxAggregateInputType
  }

  export type BookingGroupByOutputType = {
    id: string
    userId: string
    classId: string
    aiSuggested: boolean
    predictedEffectiveness: number | null
    createdAt: Date
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  type GetBookingGroupByPayload<T extends BookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingGroupByOutputType[P]>
            : GetScalarType<T[P], BookingGroupByOutputType[P]>
        }
      >
    >


  export type BookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    classId?: boolean
    aiSuggested?: boolean
    predictedEffectiveness?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    classId?: boolean
    aiSuggested?: boolean
    predictedEffectiveness?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    classId?: boolean
    aiSuggested?: boolean
    predictedEffectiveness?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectScalar = {
    id?: boolean
    userId?: boolean
    classId?: boolean
    aiSuggested?: boolean
    predictedEffectiveness?: boolean
    createdAt?: boolean
  }

  export type BookingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "classId" | "aiSuggested" | "predictedEffectiveness" | "createdAt", ExtArgs["result"]["booking"]>
  export type BookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }
  export type BookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }
  export type BookingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }

  export type $BookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Booking"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      class: Prisma.$ClassPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      classId: string
      aiSuggested: boolean
      predictedEffectiveness: number | null
      createdAt: Date
    }, ExtArgs["result"]["booking"]>
    composites: {}
  }

  type BookingGetPayload<S extends boolean | null | undefined | BookingDefaultArgs> = $Result.GetResult<Prisma.$BookingPayload, S>

  type BookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookingCountAggregateInputType | true
    }

  export interface BookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Booking'], meta: { name: 'Booking' } }
    /**
     * Find zero or one Booking that matches the filter.
     * @param {BookingFindUniqueArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingFindUniqueArgs>(args: SelectSubset<T, BookingFindUniqueArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Booking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookingFindUniqueOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Booking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingFindFirstArgs>(args?: SelectSubset<T, BookingFindFirstArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Booking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookings
     * const bookings = await prisma.booking.findMany()
     * 
     * // Get first 10 Bookings
     * const bookings = await prisma.booking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingWithIdOnly = await prisma.booking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingFindManyArgs>(args?: SelectSubset<T, BookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Booking.
     * @param {BookingCreateArgs} args - Arguments to create a Booking.
     * @example
     * // Create one Booking
     * const Booking = await prisma.booking.create({
     *   data: {
     *     // ... data to create a Booking
     *   }
     * })
     * 
     */
    create<T extends BookingCreateArgs>(args: SelectSubset<T, BookingCreateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bookings.
     * @param {BookingCreateManyArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingCreateManyArgs>(args?: SelectSubset<T, BookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bookings and returns the data saved in the database.
     * @param {BookingCreateManyAndReturnArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bookings and only return the `id`
     * const bookingWithIdOnly = await prisma.booking.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Booking.
     * @param {BookingDeleteArgs} args - Arguments to delete one Booking.
     * @example
     * // Delete one Booking
     * const Booking = await prisma.booking.delete({
     *   where: {
     *     // ... filter to delete one Booking
     *   }
     * })
     * 
     */
    delete<T extends BookingDeleteArgs>(args: SelectSubset<T, BookingDeleteArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Booking.
     * @param {BookingUpdateArgs} args - Arguments to update one Booking.
     * @example
     * // Update one Booking
     * const booking = await prisma.booking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingUpdateArgs>(args: SelectSubset<T, BookingUpdateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bookings.
     * @param {BookingDeleteManyArgs} args - Arguments to filter Bookings to delete.
     * @example
     * // Delete a few Bookings
     * const { count } = await prisma.booking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingDeleteManyArgs>(args?: SelectSubset<T, BookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingUpdateManyArgs>(args: SelectSubset<T, BookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings and returns the data updated in the database.
     * @param {BookingUpdateManyAndReturnArgs} args - Arguments to update many Bookings.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bookings and only return the `id`
     * const bookingWithIdOnly = await prisma.booking.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookingUpdateManyAndReturnArgs>(args: SelectSubset<T, BookingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Booking.
     * @param {BookingUpsertArgs} args - Arguments to update or create a Booking.
     * @example
     * // Update or create a Booking
     * const booking = await prisma.booking.upsert({
     *   create: {
     *     // ... data to create a Booking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Booking we want to update
     *   }
     * })
     */
    upsert<T extends BookingUpsertArgs>(args: SelectSubset<T, BookingUpsertArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCountArgs} args - Arguments to filter Bookings to count.
     * @example
     * // Count the number of Bookings
     * const count = await prisma.booking.count({
     *   where: {
     *     // ... the filter for the Bookings we want to count
     *   }
     * })
    **/
    count<T extends BookingCountArgs>(
      args?: Subset<T, BookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingAggregateArgs>(args: Subset<T, BookingAggregateArgs>): Prisma.PrismaPromise<GetBookingAggregateType<T>>

    /**
     * Group by Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingGroupByArgs['orderBy'] }
        : { orderBy?: BookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Booking model
   */
  readonly fields: BookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Booking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Booking model
   */
  interface BookingFieldRefs {
    readonly id: FieldRef<"Booking", 'String'>
    readonly userId: FieldRef<"Booking", 'String'>
    readonly classId: FieldRef<"Booking", 'String'>
    readonly aiSuggested: FieldRef<"Booking", 'Boolean'>
    readonly predictedEffectiveness: FieldRef<"Booking", 'Float'>
    readonly createdAt: FieldRef<"Booking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Booking findUnique
   */
  export type BookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findUniqueOrThrow
   */
  export type BookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findFirst
   */
  export type BookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findFirstOrThrow
   */
  export type BookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findMany
   */
  export type BookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Bookings to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking create
   */
  export type BookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to create a Booking.
     */
    data: XOR<BookingCreateInput, BookingUncheckedCreateInput>
  }

  /**
   * Booking createMany
   */
  export type BookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Booking createManyAndReturn
   */
  export type BookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Booking update
   */
  export type BookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to update a Booking.
     */
    data: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
    /**
     * Choose, which Booking to update.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking updateMany
   */
  export type BookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to update.
     */
    limit?: number
  }

  /**
   * Booking updateManyAndReturn
   */
  export type BookingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Booking upsert
   */
  export type BookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The filter to search for the Booking to update in case it exists.
     */
    where: BookingWhereUniqueInput
    /**
     * In case the Booking found by the `where` argument doesn't exist, create a new Booking with this data.
     */
    create: XOR<BookingCreateInput, BookingUncheckedCreateInput>
    /**
     * In case the Booking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
  }

  /**
   * Booking delete
   */
  export type BookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter which Booking to delete.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking deleteMany
   */
  export type BookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookings to delete
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to delete.
     */
    limit?: number
  }

  /**
   * Booking without action
   */
  export type BookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
  }


  /**
   * Model BiometricData
   */

  export type AggregateBiometricData = {
    _count: BiometricDataCountAggregateOutputType | null
    _avg: BiometricDataAvgAggregateOutputType | null
    _sum: BiometricDataSumAggregateOutputType | null
    _min: BiometricDataMinAggregateOutputType | null
    _max: BiometricDataMaxAggregateOutputType | null
  }

  export type BiometricDataAvgAggregateOutputType = {
    heartRate: number | null
    heartRateVariability: number | null
    stressLevel: number | null
    sleepQuality: number | null
    sleepDuration: number | null
    steps: number | null
    calories: number | null
    respiratoryRate: number | null
    skinTemperature: number | null
    bloodPressureSystolic: number | null
    bloodPressureDiastolic: number | null
    oxygenSaturation: number | null
    wellnessScore: number | null
    energyLevel: number | null
    recoveryScore: number | null
    accuracy: number | null
  }

  export type BiometricDataSumAggregateOutputType = {
    heartRate: number | null
    heartRateVariability: number | null
    stressLevel: number | null
    sleepQuality: number | null
    sleepDuration: number | null
    steps: number | null
    calories: number | null
    respiratoryRate: number | null
    skinTemperature: number | null
    bloodPressureSystolic: number | null
    bloodPressureDiastolic: number | null
    oxygenSaturation: number | null
    wellnessScore: number | null
    energyLevel: number | null
    recoveryScore: number | null
    accuracy: number | null
  }

  export type BiometricDataMinAggregateOutputType = {
    id: string | null
    userId: string | null
    heartRate: number | null
    heartRateVariability: number | null
    stressLevel: number | null
    sleepQuality: number | null
    sleepDuration: number | null
    steps: number | null
    calories: number | null
    respiratoryRate: number | null
    skinTemperature: number | null
    bloodPressureSystolic: number | null
    bloodPressureDiastolic: number | null
    oxygenSaturation: number | null
    wellnessScore: number | null
    energyLevel: number | null
    recoveryScore: number | null
    deviceType: string | null
    deviceId: string | null
    accuracy: number | null
    timestamp: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BiometricDataMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    heartRate: number | null
    heartRateVariability: number | null
    stressLevel: number | null
    sleepQuality: number | null
    sleepDuration: number | null
    steps: number | null
    calories: number | null
    respiratoryRate: number | null
    skinTemperature: number | null
    bloodPressureSystolic: number | null
    bloodPressureDiastolic: number | null
    oxygenSaturation: number | null
    wellnessScore: number | null
    energyLevel: number | null
    recoveryScore: number | null
    deviceType: string | null
    deviceId: string | null
    accuracy: number | null
    timestamp: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BiometricDataCountAggregateOutputType = {
    id: number
    userId: number
    heartRate: number
    heartRateVariability: number
    stressLevel: number
    sleepQuality: number
    sleepDuration: number
    steps: number
    calories: number
    respiratoryRate: number
    skinTemperature: number
    bloodPressureSystolic: number
    bloodPressureDiastolic: number
    oxygenSaturation: number
    wellnessScore: number
    energyLevel: number
    recoveryScore: number
    deviceType: number
    deviceId: number
    accuracy: number
    timestamp: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BiometricDataAvgAggregateInputType = {
    heartRate?: true
    heartRateVariability?: true
    stressLevel?: true
    sleepQuality?: true
    sleepDuration?: true
    steps?: true
    calories?: true
    respiratoryRate?: true
    skinTemperature?: true
    bloodPressureSystolic?: true
    bloodPressureDiastolic?: true
    oxygenSaturation?: true
    wellnessScore?: true
    energyLevel?: true
    recoveryScore?: true
    accuracy?: true
  }

  export type BiometricDataSumAggregateInputType = {
    heartRate?: true
    heartRateVariability?: true
    stressLevel?: true
    sleepQuality?: true
    sleepDuration?: true
    steps?: true
    calories?: true
    respiratoryRate?: true
    skinTemperature?: true
    bloodPressureSystolic?: true
    bloodPressureDiastolic?: true
    oxygenSaturation?: true
    wellnessScore?: true
    energyLevel?: true
    recoveryScore?: true
    accuracy?: true
  }

  export type BiometricDataMinAggregateInputType = {
    id?: true
    userId?: true
    heartRate?: true
    heartRateVariability?: true
    stressLevel?: true
    sleepQuality?: true
    sleepDuration?: true
    steps?: true
    calories?: true
    respiratoryRate?: true
    skinTemperature?: true
    bloodPressureSystolic?: true
    bloodPressureDiastolic?: true
    oxygenSaturation?: true
    wellnessScore?: true
    energyLevel?: true
    recoveryScore?: true
    deviceType?: true
    deviceId?: true
    accuracy?: true
    timestamp?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BiometricDataMaxAggregateInputType = {
    id?: true
    userId?: true
    heartRate?: true
    heartRateVariability?: true
    stressLevel?: true
    sleepQuality?: true
    sleepDuration?: true
    steps?: true
    calories?: true
    respiratoryRate?: true
    skinTemperature?: true
    bloodPressureSystolic?: true
    bloodPressureDiastolic?: true
    oxygenSaturation?: true
    wellnessScore?: true
    energyLevel?: true
    recoveryScore?: true
    deviceType?: true
    deviceId?: true
    accuracy?: true
    timestamp?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BiometricDataCountAggregateInputType = {
    id?: true
    userId?: true
    heartRate?: true
    heartRateVariability?: true
    stressLevel?: true
    sleepQuality?: true
    sleepDuration?: true
    steps?: true
    calories?: true
    respiratoryRate?: true
    skinTemperature?: true
    bloodPressureSystolic?: true
    bloodPressureDiastolic?: true
    oxygenSaturation?: true
    wellnessScore?: true
    energyLevel?: true
    recoveryScore?: true
    deviceType?: true
    deviceId?: true
    accuracy?: true
    timestamp?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BiometricDataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BiometricData to aggregate.
     */
    where?: BiometricDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BiometricData to fetch.
     */
    orderBy?: BiometricDataOrderByWithRelationInput | BiometricDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BiometricDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BiometricData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BiometricData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BiometricData
    **/
    _count?: true | BiometricDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BiometricDataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BiometricDataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BiometricDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BiometricDataMaxAggregateInputType
  }

  export type GetBiometricDataAggregateType<T extends BiometricDataAggregateArgs> = {
        [P in keyof T & keyof AggregateBiometricData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBiometricData[P]>
      : GetScalarType<T[P], AggregateBiometricData[P]>
  }




  export type BiometricDataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BiometricDataWhereInput
    orderBy?: BiometricDataOrderByWithAggregationInput | BiometricDataOrderByWithAggregationInput[]
    by: BiometricDataScalarFieldEnum[] | BiometricDataScalarFieldEnum
    having?: BiometricDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BiometricDataCountAggregateInputType | true
    _avg?: BiometricDataAvgAggregateInputType
    _sum?: BiometricDataSumAggregateInputType
    _min?: BiometricDataMinAggregateInputType
    _max?: BiometricDataMaxAggregateInputType
  }

  export type BiometricDataGroupByOutputType = {
    id: string
    userId: string
    heartRate: number | null
    heartRateVariability: number | null
    stressLevel: number | null
    sleepQuality: number | null
    sleepDuration: number | null
    steps: number | null
    calories: number | null
    respiratoryRate: number | null
    skinTemperature: number | null
    bloodPressureSystolic: number | null
    bloodPressureDiastolic: number | null
    oxygenSaturation: number | null
    wellnessScore: number | null
    energyLevel: number | null
    recoveryScore: number | null
    deviceType: string | null
    deviceId: string | null
    accuracy: number | null
    timestamp: Date
    createdAt: Date
    updatedAt: Date
    _count: BiometricDataCountAggregateOutputType | null
    _avg: BiometricDataAvgAggregateOutputType | null
    _sum: BiometricDataSumAggregateOutputType | null
    _min: BiometricDataMinAggregateOutputType | null
    _max: BiometricDataMaxAggregateOutputType | null
  }

  type GetBiometricDataGroupByPayload<T extends BiometricDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BiometricDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BiometricDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BiometricDataGroupByOutputType[P]>
            : GetScalarType<T[P], BiometricDataGroupByOutputType[P]>
        }
      >
    >


  export type BiometricDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    heartRate?: boolean
    heartRateVariability?: boolean
    stressLevel?: boolean
    sleepQuality?: boolean
    sleepDuration?: boolean
    steps?: boolean
    calories?: boolean
    respiratoryRate?: boolean
    skinTemperature?: boolean
    bloodPressureSystolic?: boolean
    bloodPressureDiastolic?: boolean
    oxygenSaturation?: boolean
    wellnessScore?: boolean
    energyLevel?: boolean
    recoveryScore?: boolean
    deviceType?: boolean
    deviceId?: boolean
    accuracy?: boolean
    timestamp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["biometricData"]>

  export type BiometricDataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    heartRate?: boolean
    heartRateVariability?: boolean
    stressLevel?: boolean
    sleepQuality?: boolean
    sleepDuration?: boolean
    steps?: boolean
    calories?: boolean
    respiratoryRate?: boolean
    skinTemperature?: boolean
    bloodPressureSystolic?: boolean
    bloodPressureDiastolic?: boolean
    oxygenSaturation?: boolean
    wellnessScore?: boolean
    energyLevel?: boolean
    recoveryScore?: boolean
    deviceType?: boolean
    deviceId?: boolean
    accuracy?: boolean
    timestamp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["biometricData"]>

  export type BiometricDataSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    heartRate?: boolean
    heartRateVariability?: boolean
    stressLevel?: boolean
    sleepQuality?: boolean
    sleepDuration?: boolean
    steps?: boolean
    calories?: boolean
    respiratoryRate?: boolean
    skinTemperature?: boolean
    bloodPressureSystolic?: boolean
    bloodPressureDiastolic?: boolean
    oxygenSaturation?: boolean
    wellnessScore?: boolean
    energyLevel?: boolean
    recoveryScore?: boolean
    deviceType?: boolean
    deviceId?: boolean
    accuracy?: boolean
    timestamp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["biometricData"]>

  export type BiometricDataSelectScalar = {
    id?: boolean
    userId?: boolean
    heartRate?: boolean
    heartRateVariability?: boolean
    stressLevel?: boolean
    sleepQuality?: boolean
    sleepDuration?: boolean
    steps?: boolean
    calories?: boolean
    respiratoryRate?: boolean
    skinTemperature?: boolean
    bloodPressureSystolic?: boolean
    bloodPressureDiastolic?: boolean
    oxygenSaturation?: boolean
    wellnessScore?: boolean
    energyLevel?: boolean
    recoveryScore?: boolean
    deviceType?: boolean
    deviceId?: boolean
    accuracy?: boolean
    timestamp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BiometricDataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "heartRate" | "heartRateVariability" | "stressLevel" | "sleepQuality" | "sleepDuration" | "steps" | "calories" | "respiratoryRate" | "skinTemperature" | "bloodPressureSystolic" | "bloodPressureDiastolic" | "oxygenSaturation" | "wellnessScore" | "energyLevel" | "recoveryScore" | "deviceType" | "deviceId" | "accuracy" | "timestamp" | "createdAt" | "updatedAt", ExtArgs["result"]["biometricData"]>
  export type BiometricDataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BiometricDataIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BiometricDataIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BiometricDataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BiometricData"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      heartRate: number | null
      heartRateVariability: number | null
      stressLevel: number | null
      sleepQuality: number | null
      sleepDuration: number | null
      steps: number | null
      calories: number | null
      respiratoryRate: number | null
      skinTemperature: number | null
      bloodPressureSystolic: number | null
      bloodPressureDiastolic: number | null
      oxygenSaturation: number | null
      wellnessScore: number | null
      energyLevel: number | null
      recoveryScore: number | null
      deviceType: string | null
      deviceId: string | null
      accuracy: number | null
      timestamp: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["biometricData"]>
    composites: {}
  }

  type BiometricDataGetPayload<S extends boolean | null | undefined | BiometricDataDefaultArgs> = $Result.GetResult<Prisma.$BiometricDataPayload, S>

  type BiometricDataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BiometricDataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BiometricDataCountAggregateInputType | true
    }

  export interface BiometricDataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BiometricData'], meta: { name: 'BiometricData' } }
    /**
     * Find zero or one BiometricData that matches the filter.
     * @param {BiometricDataFindUniqueArgs} args - Arguments to find a BiometricData
     * @example
     * // Get one BiometricData
     * const biometricData = await prisma.biometricData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BiometricDataFindUniqueArgs>(args: SelectSubset<T, BiometricDataFindUniqueArgs<ExtArgs>>): Prisma__BiometricDataClient<$Result.GetResult<Prisma.$BiometricDataPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BiometricData that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BiometricDataFindUniqueOrThrowArgs} args - Arguments to find a BiometricData
     * @example
     * // Get one BiometricData
     * const biometricData = await prisma.biometricData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BiometricDataFindUniqueOrThrowArgs>(args: SelectSubset<T, BiometricDataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BiometricDataClient<$Result.GetResult<Prisma.$BiometricDataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BiometricData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiometricDataFindFirstArgs} args - Arguments to find a BiometricData
     * @example
     * // Get one BiometricData
     * const biometricData = await prisma.biometricData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BiometricDataFindFirstArgs>(args?: SelectSubset<T, BiometricDataFindFirstArgs<ExtArgs>>): Prisma__BiometricDataClient<$Result.GetResult<Prisma.$BiometricDataPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BiometricData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiometricDataFindFirstOrThrowArgs} args - Arguments to find a BiometricData
     * @example
     * // Get one BiometricData
     * const biometricData = await prisma.biometricData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BiometricDataFindFirstOrThrowArgs>(args?: SelectSubset<T, BiometricDataFindFirstOrThrowArgs<ExtArgs>>): Prisma__BiometricDataClient<$Result.GetResult<Prisma.$BiometricDataPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BiometricData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiometricDataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BiometricData
     * const biometricData = await prisma.biometricData.findMany()
     * 
     * // Get first 10 BiometricData
     * const biometricData = await prisma.biometricData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const biometricDataWithIdOnly = await prisma.biometricData.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BiometricDataFindManyArgs>(args?: SelectSubset<T, BiometricDataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BiometricDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BiometricData.
     * @param {BiometricDataCreateArgs} args - Arguments to create a BiometricData.
     * @example
     * // Create one BiometricData
     * const BiometricData = await prisma.biometricData.create({
     *   data: {
     *     // ... data to create a BiometricData
     *   }
     * })
     * 
     */
    create<T extends BiometricDataCreateArgs>(args: SelectSubset<T, BiometricDataCreateArgs<ExtArgs>>): Prisma__BiometricDataClient<$Result.GetResult<Prisma.$BiometricDataPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BiometricData.
     * @param {BiometricDataCreateManyArgs} args - Arguments to create many BiometricData.
     * @example
     * // Create many BiometricData
     * const biometricData = await prisma.biometricData.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BiometricDataCreateManyArgs>(args?: SelectSubset<T, BiometricDataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BiometricData and returns the data saved in the database.
     * @param {BiometricDataCreateManyAndReturnArgs} args - Arguments to create many BiometricData.
     * @example
     * // Create many BiometricData
     * const biometricData = await prisma.biometricData.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BiometricData and only return the `id`
     * const biometricDataWithIdOnly = await prisma.biometricData.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BiometricDataCreateManyAndReturnArgs>(args?: SelectSubset<T, BiometricDataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BiometricDataPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BiometricData.
     * @param {BiometricDataDeleteArgs} args - Arguments to delete one BiometricData.
     * @example
     * // Delete one BiometricData
     * const BiometricData = await prisma.biometricData.delete({
     *   where: {
     *     // ... filter to delete one BiometricData
     *   }
     * })
     * 
     */
    delete<T extends BiometricDataDeleteArgs>(args: SelectSubset<T, BiometricDataDeleteArgs<ExtArgs>>): Prisma__BiometricDataClient<$Result.GetResult<Prisma.$BiometricDataPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BiometricData.
     * @param {BiometricDataUpdateArgs} args - Arguments to update one BiometricData.
     * @example
     * // Update one BiometricData
     * const biometricData = await prisma.biometricData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BiometricDataUpdateArgs>(args: SelectSubset<T, BiometricDataUpdateArgs<ExtArgs>>): Prisma__BiometricDataClient<$Result.GetResult<Prisma.$BiometricDataPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BiometricData.
     * @param {BiometricDataDeleteManyArgs} args - Arguments to filter BiometricData to delete.
     * @example
     * // Delete a few BiometricData
     * const { count } = await prisma.biometricData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BiometricDataDeleteManyArgs>(args?: SelectSubset<T, BiometricDataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BiometricData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiometricDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BiometricData
     * const biometricData = await prisma.biometricData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BiometricDataUpdateManyArgs>(args: SelectSubset<T, BiometricDataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BiometricData and returns the data updated in the database.
     * @param {BiometricDataUpdateManyAndReturnArgs} args - Arguments to update many BiometricData.
     * @example
     * // Update many BiometricData
     * const biometricData = await prisma.biometricData.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BiometricData and only return the `id`
     * const biometricDataWithIdOnly = await prisma.biometricData.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BiometricDataUpdateManyAndReturnArgs>(args: SelectSubset<T, BiometricDataUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BiometricDataPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BiometricData.
     * @param {BiometricDataUpsertArgs} args - Arguments to update or create a BiometricData.
     * @example
     * // Update or create a BiometricData
     * const biometricData = await prisma.biometricData.upsert({
     *   create: {
     *     // ... data to create a BiometricData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BiometricData we want to update
     *   }
     * })
     */
    upsert<T extends BiometricDataUpsertArgs>(args: SelectSubset<T, BiometricDataUpsertArgs<ExtArgs>>): Prisma__BiometricDataClient<$Result.GetResult<Prisma.$BiometricDataPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BiometricData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiometricDataCountArgs} args - Arguments to filter BiometricData to count.
     * @example
     * // Count the number of BiometricData
     * const count = await prisma.biometricData.count({
     *   where: {
     *     // ... the filter for the BiometricData we want to count
     *   }
     * })
    **/
    count<T extends BiometricDataCountArgs>(
      args?: Subset<T, BiometricDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BiometricDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BiometricData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiometricDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BiometricDataAggregateArgs>(args: Subset<T, BiometricDataAggregateArgs>): Prisma.PrismaPromise<GetBiometricDataAggregateType<T>>

    /**
     * Group by BiometricData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiometricDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BiometricDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BiometricDataGroupByArgs['orderBy'] }
        : { orderBy?: BiometricDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BiometricDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBiometricDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BiometricData model
   */
  readonly fields: BiometricDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BiometricData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BiometricDataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BiometricData model
   */
  interface BiometricDataFieldRefs {
    readonly id: FieldRef<"BiometricData", 'String'>
    readonly userId: FieldRef<"BiometricData", 'String'>
    readonly heartRate: FieldRef<"BiometricData", 'Int'>
    readonly heartRateVariability: FieldRef<"BiometricData", 'Float'>
    readonly stressLevel: FieldRef<"BiometricData", 'Int'>
    readonly sleepQuality: FieldRef<"BiometricData", 'Int'>
    readonly sleepDuration: FieldRef<"BiometricData", 'Float'>
    readonly steps: FieldRef<"BiometricData", 'Int'>
    readonly calories: FieldRef<"BiometricData", 'Int'>
    readonly respiratoryRate: FieldRef<"BiometricData", 'Int'>
    readonly skinTemperature: FieldRef<"BiometricData", 'Float'>
    readonly bloodPressureSystolic: FieldRef<"BiometricData", 'Int'>
    readonly bloodPressureDiastolic: FieldRef<"BiometricData", 'Int'>
    readonly oxygenSaturation: FieldRef<"BiometricData", 'Float'>
    readonly wellnessScore: FieldRef<"BiometricData", 'Float'>
    readonly energyLevel: FieldRef<"BiometricData", 'Int'>
    readonly recoveryScore: FieldRef<"BiometricData", 'Float'>
    readonly deviceType: FieldRef<"BiometricData", 'String'>
    readonly deviceId: FieldRef<"BiometricData", 'String'>
    readonly accuracy: FieldRef<"BiometricData", 'Float'>
    readonly timestamp: FieldRef<"BiometricData", 'DateTime'>
    readonly createdAt: FieldRef<"BiometricData", 'DateTime'>
    readonly updatedAt: FieldRef<"BiometricData", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BiometricData findUnique
   */
  export type BiometricDataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiometricData
     */
    select?: BiometricDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BiometricData
     */
    omit?: BiometricDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiometricDataInclude<ExtArgs> | null
    /**
     * Filter, which BiometricData to fetch.
     */
    where: BiometricDataWhereUniqueInput
  }

  /**
   * BiometricData findUniqueOrThrow
   */
  export type BiometricDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiometricData
     */
    select?: BiometricDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BiometricData
     */
    omit?: BiometricDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiometricDataInclude<ExtArgs> | null
    /**
     * Filter, which BiometricData to fetch.
     */
    where: BiometricDataWhereUniqueInput
  }

  /**
   * BiometricData findFirst
   */
  export type BiometricDataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiometricData
     */
    select?: BiometricDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BiometricData
     */
    omit?: BiometricDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiometricDataInclude<ExtArgs> | null
    /**
     * Filter, which BiometricData to fetch.
     */
    where?: BiometricDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BiometricData to fetch.
     */
    orderBy?: BiometricDataOrderByWithRelationInput | BiometricDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BiometricData.
     */
    cursor?: BiometricDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BiometricData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BiometricData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BiometricData.
     */
    distinct?: BiometricDataScalarFieldEnum | BiometricDataScalarFieldEnum[]
  }

  /**
   * BiometricData findFirstOrThrow
   */
  export type BiometricDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiometricData
     */
    select?: BiometricDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BiometricData
     */
    omit?: BiometricDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiometricDataInclude<ExtArgs> | null
    /**
     * Filter, which BiometricData to fetch.
     */
    where?: BiometricDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BiometricData to fetch.
     */
    orderBy?: BiometricDataOrderByWithRelationInput | BiometricDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BiometricData.
     */
    cursor?: BiometricDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BiometricData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BiometricData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BiometricData.
     */
    distinct?: BiometricDataScalarFieldEnum | BiometricDataScalarFieldEnum[]
  }

  /**
   * BiometricData findMany
   */
  export type BiometricDataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiometricData
     */
    select?: BiometricDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BiometricData
     */
    omit?: BiometricDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiometricDataInclude<ExtArgs> | null
    /**
     * Filter, which BiometricData to fetch.
     */
    where?: BiometricDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BiometricData to fetch.
     */
    orderBy?: BiometricDataOrderByWithRelationInput | BiometricDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BiometricData.
     */
    cursor?: BiometricDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BiometricData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BiometricData.
     */
    skip?: number
    distinct?: BiometricDataScalarFieldEnum | BiometricDataScalarFieldEnum[]
  }

  /**
   * BiometricData create
   */
  export type BiometricDataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiometricData
     */
    select?: BiometricDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BiometricData
     */
    omit?: BiometricDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiometricDataInclude<ExtArgs> | null
    /**
     * The data needed to create a BiometricData.
     */
    data: XOR<BiometricDataCreateInput, BiometricDataUncheckedCreateInput>
  }

  /**
   * BiometricData createMany
   */
  export type BiometricDataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BiometricData.
     */
    data: BiometricDataCreateManyInput | BiometricDataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BiometricData createManyAndReturn
   */
  export type BiometricDataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiometricData
     */
    select?: BiometricDataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BiometricData
     */
    omit?: BiometricDataOmit<ExtArgs> | null
    /**
     * The data used to create many BiometricData.
     */
    data: BiometricDataCreateManyInput | BiometricDataCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiometricDataIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BiometricData update
   */
  export type BiometricDataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiometricData
     */
    select?: BiometricDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BiometricData
     */
    omit?: BiometricDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiometricDataInclude<ExtArgs> | null
    /**
     * The data needed to update a BiometricData.
     */
    data: XOR<BiometricDataUpdateInput, BiometricDataUncheckedUpdateInput>
    /**
     * Choose, which BiometricData to update.
     */
    where: BiometricDataWhereUniqueInput
  }

  /**
   * BiometricData updateMany
   */
  export type BiometricDataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BiometricData.
     */
    data: XOR<BiometricDataUpdateManyMutationInput, BiometricDataUncheckedUpdateManyInput>
    /**
     * Filter which BiometricData to update
     */
    where?: BiometricDataWhereInput
    /**
     * Limit how many BiometricData to update.
     */
    limit?: number
  }

  /**
   * BiometricData updateManyAndReturn
   */
  export type BiometricDataUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiometricData
     */
    select?: BiometricDataSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BiometricData
     */
    omit?: BiometricDataOmit<ExtArgs> | null
    /**
     * The data used to update BiometricData.
     */
    data: XOR<BiometricDataUpdateManyMutationInput, BiometricDataUncheckedUpdateManyInput>
    /**
     * Filter which BiometricData to update
     */
    where?: BiometricDataWhereInput
    /**
     * Limit how many BiometricData to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiometricDataIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BiometricData upsert
   */
  export type BiometricDataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiometricData
     */
    select?: BiometricDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BiometricData
     */
    omit?: BiometricDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiometricDataInclude<ExtArgs> | null
    /**
     * The filter to search for the BiometricData to update in case it exists.
     */
    where: BiometricDataWhereUniqueInput
    /**
     * In case the BiometricData found by the `where` argument doesn't exist, create a new BiometricData with this data.
     */
    create: XOR<BiometricDataCreateInput, BiometricDataUncheckedCreateInput>
    /**
     * In case the BiometricData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BiometricDataUpdateInput, BiometricDataUncheckedUpdateInput>
  }

  /**
   * BiometricData delete
   */
  export type BiometricDataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiometricData
     */
    select?: BiometricDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BiometricData
     */
    omit?: BiometricDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiometricDataInclude<ExtArgs> | null
    /**
     * Filter which BiometricData to delete.
     */
    where: BiometricDataWhereUniqueInput
  }

  /**
   * BiometricData deleteMany
   */
  export type BiometricDataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BiometricData to delete
     */
    where?: BiometricDataWhereInput
    /**
     * Limit how many BiometricData to delete.
     */
    limit?: number
  }

  /**
   * BiometricData without action
   */
  export type BiometricDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiometricData
     */
    select?: BiometricDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BiometricData
     */
    omit?: BiometricDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiometricDataInclude<ExtArgs> | null
  }


  /**
   * Model MoodEntry
   */

  export type AggregateMoodEntry = {
    _count: MoodEntryCountAggregateOutputType | null
    _avg: MoodEntryAvgAggregateOutputType | null
    _sum: MoodEntrySumAggregateOutputType | null
    _min: MoodEntryMinAggregateOutputType | null
    _max: MoodEntryMaxAggregateOutputType | null
  }

  export type MoodEntryAvgAggregateOutputType = {
    confidence: number | null
    valence: number | null
    arousal: number | null
  }

  export type MoodEntrySumAggregateOutputType = {
    confidence: number | null
    valence: number | null
    arousal: number | null
  }

  export type MoodEntryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    mood: string | null
    confidence: number | null
    source: string | null
    valence: number | null
    arousal: number | null
    location: string | null
    weather: string | null
    timeOfDay: string | null
    activity: string | null
    timestamp: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MoodEntryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    mood: string | null
    confidence: number | null
    source: string | null
    valence: number | null
    arousal: number | null
    location: string | null
    weather: string | null
    timeOfDay: string | null
    activity: string | null
    timestamp: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MoodEntryCountAggregateOutputType = {
    id: number
    userId: number
    mood: number
    confidence: number
    source: number
    emotions: number
    valence: number
    arousal: number
    location: number
    weather: number
    timeOfDay: number
    activity: number
    voiceFeatures: number
    timestamp: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MoodEntryAvgAggregateInputType = {
    confidence?: true
    valence?: true
    arousal?: true
  }

  export type MoodEntrySumAggregateInputType = {
    confidence?: true
    valence?: true
    arousal?: true
  }

  export type MoodEntryMinAggregateInputType = {
    id?: true
    userId?: true
    mood?: true
    confidence?: true
    source?: true
    valence?: true
    arousal?: true
    location?: true
    weather?: true
    timeOfDay?: true
    activity?: true
    timestamp?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MoodEntryMaxAggregateInputType = {
    id?: true
    userId?: true
    mood?: true
    confidence?: true
    source?: true
    valence?: true
    arousal?: true
    location?: true
    weather?: true
    timeOfDay?: true
    activity?: true
    timestamp?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MoodEntryCountAggregateInputType = {
    id?: true
    userId?: true
    mood?: true
    confidence?: true
    source?: true
    emotions?: true
    valence?: true
    arousal?: true
    location?: true
    weather?: true
    timeOfDay?: true
    activity?: true
    voiceFeatures?: true
    timestamp?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MoodEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MoodEntry to aggregate.
     */
    where?: MoodEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MoodEntries to fetch.
     */
    orderBy?: MoodEntryOrderByWithRelationInput | MoodEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MoodEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MoodEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MoodEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MoodEntries
    **/
    _count?: true | MoodEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MoodEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MoodEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MoodEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MoodEntryMaxAggregateInputType
  }

  export type GetMoodEntryAggregateType<T extends MoodEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateMoodEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMoodEntry[P]>
      : GetScalarType<T[P], AggregateMoodEntry[P]>
  }




  export type MoodEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MoodEntryWhereInput
    orderBy?: MoodEntryOrderByWithAggregationInput | MoodEntryOrderByWithAggregationInput[]
    by: MoodEntryScalarFieldEnum[] | MoodEntryScalarFieldEnum
    having?: MoodEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MoodEntryCountAggregateInputType | true
    _avg?: MoodEntryAvgAggregateInputType
    _sum?: MoodEntrySumAggregateInputType
    _min?: MoodEntryMinAggregateInputType
    _max?: MoodEntryMaxAggregateInputType
  }

  export type MoodEntryGroupByOutputType = {
    id: string
    userId: string
    mood: string
    confidence: number
    source: string
    emotions: JsonValue | null
    valence: number | null
    arousal: number | null
    location: string | null
    weather: string | null
    timeOfDay: string | null
    activity: string | null
    voiceFeatures: JsonValue | null
    timestamp: Date
    createdAt: Date
    updatedAt: Date
    _count: MoodEntryCountAggregateOutputType | null
    _avg: MoodEntryAvgAggregateOutputType | null
    _sum: MoodEntrySumAggregateOutputType | null
    _min: MoodEntryMinAggregateOutputType | null
    _max: MoodEntryMaxAggregateOutputType | null
  }

  type GetMoodEntryGroupByPayload<T extends MoodEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MoodEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MoodEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MoodEntryGroupByOutputType[P]>
            : GetScalarType<T[P], MoodEntryGroupByOutputType[P]>
        }
      >
    >


  export type MoodEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    mood?: boolean
    confidence?: boolean
    source?: boolean
    emotions?: boolean
    valence?: boolean
    arousal?: boolean
    location?: boolean
    weather?: boolean
    timeOfDay?: boolean
    activity?: boolean
    voiceFeatures?: boolean
    timestamp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moodEntry"]>

  export type MoodEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    mood?: boolean
    confidence?: boolean
    source?: boolean
    emotions?: boolean
    valence?: boolean
    arousal?: boolean
    location?: boolean
    weather?: boolean
    timeOfDay?: boolean
    activity?: boolean
    voiceFeatures?: boolean
    timestamp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moodEntry"]>

  export type MoodEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    mood?: boolean
    confidence?: boolean
    source?: boolean
    emotions?: boolean
    valence?: boolean
    arousal?: boolean
    location?: boolean
    weather?: boolean
    timeOfDay?: boolean
    activity?: boolean
    voiceFeatures?: boolean
    timestamp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moodEntry"]>

  export type MoodEntrySelectScalar = {
    id?: boolean
    userId?: boolean
    mood?: boolean
    confidence?: boolean
    source?: boolean
    emotions?: boolean
    valence?: boolean
    arousal?: boolean
    location?: boolean
    weather?: boolean
    timeOfDay?: boolean
    activity?: boolean
    voiceFeatures?: boolean
    timestamp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MoodEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "mood" | "confidence" | "source" | "emotions" | "valence" | "arousal" | "location" | "weather" | "timeOfDay" | "activity" | "voiceFeatures" | "timestamp" | "createdAt" | "updatedAt", ExtArgs["result"]["moodEntry"]>
  export type MoodEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MoodEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MoodEntryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MoodEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MoodEntry"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      mood: string
      confidence: number
      source: string
      emotions: Prisma.JsonValue | null
      valence: number | null
      arousal: number | null
      location: string | null
      weather: string | null
      timeOfDay: string | null
      activity: string | null
      voiceFeatures: Prisma.JsonValue | null
      timestamp: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["moodEntry"]>
    composites: {}
  }

  type MoodEntryGetPayload<S extends boolean | null | undefined | MoodEntryDefaultArgs> = $Result.GetResult<Prisma.$MoodEntryPayload, S>

  type MoodEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MoodEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MoodEntryCountAggregateInputType | true
    }

  export interface MoodEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MoodEntry'], meta: { name: 'MoodEntry' } }
    /**
     * Find zero or one MoodEntry that matches the filter.
     * @param {MoodEntryFindUniqueArgs} args - Arguments to find a MoodEntry
     * @example
     * // Get one MoodEntry
     * const moodEntry = await prisma.moodEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MoodEntryFindUniqueArgs>(args: SelectSubset<T, MoodEntryFindUniqueArgs<ExtArgs>>): Prisma__MoodEntryClient<$Result.GetResult<Prisma.$MoodEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MoodEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MoodEntryFindUniqueOrThrowArgs} args - Arguments to find a MoodEntry
     * @example
     * // Get one MoodEntry
     * const moodEntry = await prisma.moodEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MoodEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, MoodEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MoodEntryClient<$Result.GetResult<Prisma.$MoodEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MoodEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoodEntryFindFirstArgs} args - Arguments to find a MoodEntry
     * @example
     * // Get one MoodEntry
     * const moodEntry = await prisma.moodEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MoodEntryFindFirstArgs>(args?: SelectSubset<T, MoodEntryFindFirstArgs<ExtArgs>>): Prisma__MoodEntryClient<$Result.GetResult<Prisma.$MoodEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MoodEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoodEntryFindFirstOrThrowArgs} args - Arguments to find a MoodEntry
     * @example
     * // Get one MoodEntry
     * const moodEntry = await prisma.moodEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MoodEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, MoodEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__MoodEntryClient<$Result.GetResult<Prisma.$MoodEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MoodEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoodEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MoodEntries
     * const moodEntries = await prisma.moodEntry.findMany()
     * 
     * // Get first 10 MoodEntries
     * const moodEntries = await prisma.moodEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moodEntryWithIdOnly = await prisma.moodEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MoodEntryFindManyArgs>(args?: SelectSubset<T, MoodEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoodEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MoodEntry.
     * @param {MoodEntryCreateArgs} args - Arguments to create a MoodEntry.
     * @example
     * // Create one MoodEntry
     * const MoodEntry = await prisma.moodEntry.create({
     *   data: {
     *     // ... data to create a MoodEntry
     *   }
     * })
     * 
     */
    create<T extends MoodEntryCreateArgs>(args: SelectSubset<T, MoodEntryCreateArgs<ExtArgs>>): Prisma__MoodEntryClient<$Result.GetResult<Prisma.$MoodEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MoodEntries.
     * @param {MoodEntryCreateManyArgs} args - Arguments to create many MoodEntries.
     * @example
     * // Create many MoodEntries
     * const moodEntry = await prisma.moodEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MoodEntryCreateManyArgs>(args?: SelectSubset<T, MoodEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MoodEntries and returns the data saved in the database.
     * @param {MoodEntryCreateManyAndReturnArgs} args - Arguments to create many MoodEntries.
     * @example
     * // Create many MoodEntries
     * const moodEntry = await prisma.moodEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MoodEntries and only return the `id`
     * const moodEntryWithIdOnly = await prisma.moodEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MoodEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, MoodEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoodEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MoodEntry.
     * @param {MoodEntryDeleteArgs} args - Arguments to delete one MoodEntry.
     * @example
     * // Delete one MoodEntry
     * const MoodEntry = await prisma.moodEntry.delete({
     *   where: {
     *     // ... filter to delete one MoodEntry
     *   }
     * })
     * 
     */
    delete<T extends MoodEntryDeleteArgs>(args: SelectSubset<T, MoodEntryDeleteArgs<ExtArgs>>): Prisma__MoodEntryClient<$Result.GetResult<Prisma.$MoodEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MoodEntry.
     * @param {MoodEntryUpdateArgs} args - Arguments to update one MoodEntry.
     * @example
     * // Update one MoodEntry
     * const moodEntry = await prisma.moodEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MoodEntryUpdateArgs>(args: SelectSubset<T, MoodEntryUpdateArgs<ExtArgs>>): Prisma__MoodEntryClient<$Result.GetResult<Prisma.$MoodEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MoodEntries.
     * @param {MoodEntryDeleteManyArgs} args - Arguments to filter MoodEntries to delete.
     * @example
     * // Delete a few MoodEntries
     * const { count } = await prisma.moodEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MoodEntryDeleteManyArgs>(args?: SelectSubset<T, MoodEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MoodEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoodEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MoodEntries
     * const moodEntry = await prisma.moodEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MoodEntryUpdateManyArgs>(args: SelectSubset<T, MoodEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MoodEntries and returns the data updated in the database.
     * @param {MoodEntryUpdateManyAndReturnArgs} args - Arguments to update many MoodEntries.
     * @example
     * // Update many MoodEntries
     * const moodEntry = await prisma.moodEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MoodEntries and only return the `id`
     * const moodEntryWithIdOnly = await prisma.moodEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MoodEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, MoodEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoodEntryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MoodEntry.
     * @param {MoodEntryUpsertArgs} args - Arguments to update or create a MoodEntry.
     * @example
     * // Update or create a MoodEntry
     * const moodEntry = await prisma.moodEntry.upsert({
     *   create: {
     *     // ... data to create a MoodEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MoodEntry we want to update
     *   }
     * })
     */
    upsert<T extends MoodEntryUpsertArgs>(args: SelectSubset<T, MoodEntryUpsertArgs<ExtArgs>>): Prisma__MoodEntryClient<$Result.GetResult<Prisma.$MoodEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MoodEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoodEntryCountArgs} args - Arguments to filter MoodEntries to count.
     * @example
     * // Count the number of MoodEntries
     * const count = await prisma.moodEntry.count({
     *   where: {
     *     // ... the filter for the MoodEntries we want to count
     *   }
     * })
    **/
    count<T extends MoodEntryCountArgs>(
      args?: Subset<T, MoodEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MoodEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MoodEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoodEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MoodEntryAggregateArgs>(args: Subset<T, MoodEntryAggregateArgs>): Prisma.PrismaPromise<GetMoodEntryAggregateType<T>>

    /**
     * Group by MoodEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoodEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MoodEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MoodEntryGroupByArgs['orderBy'] }
        : { orderBy?: MoodEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MoodEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMoodEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MoodEntry model
   */
  readonly fields: MoodEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MoodEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MoodEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MoodEntry model
   */
  interface MoodEntryFieldRefs {
    readonly id: FieldRef<"MoodEntry", 'String'>
    readonly userId: FieldRef<"MoodEntry", 'String'>
    readonly mood: FieldRef<"MoodEntry", 'String'>
    readonly confidence: FieldRef<"MoodEntry", 'Float'>
    readonly source: FieldRef<"MoodEntry", 'String'>
    readonly emotions: FieldRef<"MoodEntry", 'Json'>
    readonly valence: FieldRef<"MoodEntry", 'Float'>
    readonly arousal: FieldRef<"MoodEntry", 'Float'>
    readonly location: FieldRef<"MoodEntry", 'String'>
    readonly weather: FieldRef<"MoodEntry", 'String'>
    readonly timeOfDay: FieldRef<"MoodEntry", 'String'>
    readonly activity: FieldRef<"MoodEntry", 'String'>
    readonly voiceFeatures: FieldRef<"MoodEntry", 'Json'>
    readonly timestamp: FieldRef<"MoodEntry", 'DateTime'>
    readonly createdAt: FieldRef<"MoodEntry", 'DateTime'>
    readonly updatedAt: FieldRef<"MoodEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MoodEntry findUnique
   */
  export type MoodEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodEntry
     */
    select?: MoodEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoodEntry
     */
    omit?: MoodEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodEntryInclude<ExtArgs> | null
    /**
     * Filter, which MoodEntry to fetch.
     */
    where: MoodEntryWhereUniqueInput
  }

  /**
   * MoodEntry findUniqueOrThrow
   */
  export type MoodEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodEntry
     */
    select?: MoodEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoodEntry
     */
    omit?: MoodEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodEntryInclude<ExtArgs> | null
    /**
     * Filter, which MoodEntry to fetch.
     */
    where: MoodEntryWhereUniqueInput
  }

  /**
   * MoodEntry findFirst
   */
  export type MoodEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodEntry
     */
    select?: MoodEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoodEntry
     */
    omit?: MoodEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodEntryInclude<ExtArgs> | null
    /**
     * Filter, which MoodEntry to fetch.
     */
    where?: MoodEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MoodEntries to fetch.
     */
    orderBy?: MoodEntryOrderByWithRelationInput | MoodEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MoodEntries.
     */
    cursor?: MoodEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MoodEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MoodEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MoodEntries.
     */
    distinct?: MoodEntryScalarFieldEnum | MoodEntryScalarFieldEnum[]
  }

  /**
   * MoodEntry findFirstOrThrow
   */
  export type MoodEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodEntry
     */
    select?: MoodEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoodEntry
     */
    omit?: MoodEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodEntryInclude<ExtArgs> | null
    /**
     * Filter, which MoodEntry to fetch.
     */
    where?: MoodEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MoodEntries to fetch.
     */
    orderBy?: MoodEntryOrderByWithRelationInput | MoodEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MoodEntries.
     */
    cursor?: MoodEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MoodEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MoodEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MoodEntries.
     */
    distinct?: MoodEntryScalarFieldEnum | MoodEntryScalarFieldEnum[]
  }

  /**
   * MoodEntry findMany
   */
  export type MoodEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodEntry
     */
    select?: MoodEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoodEntry
     */
    omit?: MoodEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodEntryInclude<ExtArgs> | null
    /**
     * Filter, which MoodEntries to fetch.
     */
    where?: MoodEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MoodEntries to fetch.
     */
    orderBy?: MoodEntryOrderByWithRelationInput | MoodEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MoodEntries.
     */
    cursor?: MoodEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MoodEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MoodEntries.
     */
    skip?: number
    distinct?: MoodEntryScalarFieldEnum | MoodEntryScalarFieldEnum[]
  }

  /**
   * MoodEntry create
   */
  export type MoodEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodEntry
     */
    select?: MoodEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoodEntry
     */
    omit?: MoodEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a MoodEntry.
     */
    data: XOR<MoodEntryCreateInput, MoodEntryUncheckedCreateInput>
  }

  /**
   * MoodEntry createMany
   */
  export type MoodEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MoodEntries.
     */
    data: MoodEntryCreateManyInput | MoodEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MoodEntry createManyAndReturn
   */
  export type MoodEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodEntry
     */
    select?: MoodEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MoodEntry
     */
    omit?: MoodEntryOmit<ExtArgs> | null
    /**
     * The data used to create many MoodEntries.
     */
    data: MoodEntryCreateManyInput | MoodEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MoodEntry update
   */
  export type MoodEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodEntry
     */
    select?: MoodEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoodEntry
     */
    omit?: MoodEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a MoodEntry.
     */
    data: XOR<MoodEntryUpdateInput, MoodEntryUncheckedUpdateInput>
    /**
     * Choose, which MoodEntry to update.
     */
    where: MoodEntryWhereUniqueInput
  }

  /**
   * MoodEntry updateMany
   */
  export type MoodEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MoodEntries.
     */
    data: XOR<MoodEntryUpdateManyMutationInput, MoodEntryUncheckedUpdateManyInput>
    /**
     * Filter which MoodEntries to update
     */
    where?: MoodEntryWhereInput
    /**
     * Limit how many MoodEntries to update.
     */
    limit?: number
  }

  /**
   * MoodEntry updateManyAndReturn
   */
  export type MoodEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodEntry
     */
    select?: MoodEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MoodEntry
     */
    omit?: MoodEntryOmit<ExtArgs> | null
    /**
     * The data used to update MoodEntries.
     */
    data: XOR<MoodEntryUpdateManyMutationInput, MoodEntryUncheckedUpdateManyInput>
    /**
     * Filter which MoodEntries to update
     */
    where?: MoodEntryWhereInput
    /**
     * Limit how many MoodEntries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodEntryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MoodEntry upsert
   */
  export type MoodEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodEntry
     */
    select?: MoodEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoodEntry
     */
    omit?: MoodEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the MoodEntry to update in case it exists.
     */
    where: MoodEntryWhereUniqueInput
    /**
     * In case the MoodEntry found by the `where` argument doesn't exist, create a new MoodEntry with this data.
     */
    create: XOR<MoodEntryCreateInput, MoodEntryUncheckedCreateInput>
    /**
     * In case the MoodEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MoodEntryUpdateInput, MoodEntryUncheckedUpdateInput>
  }

  /**
   * MoodEntry delete
   */
  export type MoodEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodEntry
     */
    select?: MoodEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoodEntry
     */
    omit?: MoodEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodEntryInclude<ExtArgs> | null
    /**
     * Filter which MoodEntry to delete.
     */
    where: MoodEntryWhereUniqueInput
  }

  /**
   * MoodEntry deleteMany
   */
  export type MoodEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MoodEntries to delete
     */
    where?: MoodEntryWhereInput
    /**
     * Limit how many MoodEntries to delete.
     */
    limit?: number
  }

  /**
   * MoodEntry without action
   */
  export type MoodEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodEntry
     */
    select?: MoodEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoodEntry
     */
    omit?: MoodEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodEntryInclude<ExtArgs> | null
  }


  /**
   * Model StressPrediction
   */

  export type AggregateStressPrediction = {
    _count: StressPredictionCountAggregateOutputType | null
    _avg: StressPredictionAvgAggregateOutputType | null
    _sum: StressPredictionSumAggregateOutputType | null
    _min: StressPredictionMinAggregateOutputType | null
    _max: StressPredictionMaxAggregateOutputType | null
  }

  export type StressPredictionAvgAggregateOutputType = {
    predictedStressLevel: number | null
    confidence: number | null
    actualStressLevel: number | null
  }

  export type StressPredictionSumAggregateOutputType = {
    predictedStressLevel: number | null
    confidence: number | null
    actualStressLevel: number | null
  }

  export type StressPredictionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    predictedStressLevel: number | null
    confidence: number | null
    predictedAt: Date | null
    modelVersion: string | null
    actualStressLevel: number | null
    wasAccurate: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StressPredictionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    predictedStressLevel: number | null
    confidence: number | null
    predictedAt: Date | null
    modelVersion: string | null
    actualStressLevel: number | null
    wasAccurate: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StressPredictionCountAggregateOutputType = {
    id: number
    userId: number
    predictedStressLevel: number
    confidence: number
    predictedAt: number
    modelVersion: number
    triggers: number
    riskFactors: number
    recommendedInterventions: number
    preventionStrategies: number
    actualStressLevel: number
    wasAccurate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StressPredictionAvgAggregateInputType = {
    predictedStressLevel?: true
    confidence?: true
    actualStressLevel?: true
  }

  export type StressPredictionSumAggregateInputType = {
    predictedStressLevel?: true
    confidence?: true
    actualStressLevel?: true
  }

  export type StressPredictionMinAggregateInputType = {
    id?: true
    userId?: true
    predictedStressLevel?: true
    confidence?: true
    predictedAt?: true
    modelVersion?: true
    actualStressLevel?: true
    wasAccurate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StressPredictionMaxAggregateInputType = {
    id?: true
    userId?: true
    predictedStressLevel?: true
    confidence?: true
    predictedAt?: true
    modelVersion?: true
    actualStressLevel?: true
    wasAccurate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StressPredictionCountAggregateInputType = {
    id?: true
    userId?: true
    predictedStressLevel?: true
    confidence?: true
    predictedAt?: true
    modelVersion?: true
    triggers?: true
    riskFactors?: true
    recommendedInterventions?: true
    preventionStrategies?: true
    actualStressLevel?: true
    wasAccurate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StressPredictionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StressPrediction to aggregate.
     */
    where?: StressPredictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StressPredictions to fetch.
     */
    orderBy?: StressPredictionOrderByWithRelationInput | StressPredictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StressPredictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StressPredictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StressPredictions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StressPredictions
    **/
    _count?: true | StressPredictionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StressPredictionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StressPredictionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StressPredictionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StressPredictionMaxAggregateInputType
  }

  export type GetStressPredictionAggregateType<T extends StressPredictionAggregateArgs> = {
        [P in keyof T & keyof AggregateStressPrediction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStressPrediction[P]>
      : GetScalarType<T[P], AggregateStressPrediction[P]>
  }




  export type StressPredictionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StressPredictionWhereInput
    orderBy?: StressPredictionOrderByWithAggregationInput | StressPredictionOrderByWithAggregationInput[]
    by: StressPredictionScalarFieldEnum[] | StressPredictionScalarFieldEnum
    having?: StressPredictionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StressPredictionCountAggregateInputType | true
    _avg?: StressPredictionAvgAggregateInputType
    _sum?: StressPredictionSumAggregateInputType
    _min?: StressPredictionMinAggregateInputType
    _max?: StressPredictionMaxAggregateInputType
  }

  export type StressPredictionGroupByOutputType = {
    id: string
    userId: string
    predictedStressLevel: number
    confidence: number
    predictedAt: Date
    modelVersion: string | null
    triggers: JsonValue | null
    riskFactors: JsonValue | null
    recommendedInterventions: JsonValue | null
    preventionStrategies: JsonValue | null
    actualStressLevel: number | null
    wasAccurate: boolean | null
    createdAt: Date
    updatedAt: Date
    _count: StressPredictionCountAggregateOutputType | null
    _avg: StressPredictionAvgAggregateOutputType | null
    _sum: StressPredictionSumAggregateOutputType | null
    _min: StressPredictionMinAggregateOutputType | null
    _max: StressPredictionMaxAggregateOutputType | null
  }

  type GetStressPredictionGroupByPayload<T extends StressPredictionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StressPredictionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StressPredictionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StressPredictionGroupByOutputType[P]>
            : GetScalarType<T[P], StressPredictionGroupByOutputType[P]>
        }
      >
    >


  export type StressPredictionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    predictedStressLevel?: boolean
    confidence?: boolean
    predictedAt?: boolean
    modelVersion?: boolean
    triggers?: boolean
    riskFactors?: boolean
    recommendedInterventions?: boolean
    preventionStrategies?: boolean
    actualStressLevel?: boolean
    wasAccurate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stressPrediction"]>

  export type StressPredictionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    predictedStressLevel?: boolean
    confidence?: boolean
    predictedAt?: boolean
    modelVersion?: boolean
    triggers?: boolean
    riskFactors?: boolean
    recommendedInterventions?: boolean
    preventionStrategies?: boolean
    actualStressLevel?: boolean
    wasAccurate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stressPrediction"]>

  export type StressPredictionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    predictedStressLevel?: boolean
    confidence?: boolean
    predictedAt?: boolean
    modelVersion?: boolean
    triggers?: boolean
    riskFactors?: boolean
    recommendedInterventions?: boolean
    preventionStrategies?: boolean
    actualStressLevel?: boolean
    wasAccurate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stressPrediction"]>

  export type StressPredictionSelectScalar = {
    id?: boolean
    userId?: boolean
    predictedStressLevel?: boolean
    confidence?: boolean
    predictedAt?: boolean
    modelVersion?: boolean
    triggers?: boolean
    riskFactors?: boolean
    recommendedInterventions?: boolean
    preventionStrategies?: boolean
    actualStressLevel?: boolean
    wasAccurate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StressPredictionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "predictedStressLevel" | "confidence" | "predictedAt" | "modelVersion" | "triggers" | "riskFactors" | "recommendedInterventions" | "preventionStrategies" | "actualStressLevel" | "wasAccurate" | "createdAt" | "updatedAt", ExtArgs["result"]["stressPrediction"]>
  export type StressPredictionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type StressPredictionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type StressPredictionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $StressPredictionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StressPrediction"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      predictedStressLevel: number
      confidence: number
      predictedAt: Date
      modelVersion: string | null
      triggers: Prisma.JsonValue | null
      riskFactors: Prisma.JsonValue | null
      recommendedInterventions: Prisma.JsonValue | null
      preventionStrategies: Prisma.JsonValue | null
      actualStressLevel: number | null
      wasAccurate: boolean | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["stressPrediction"]>
    composites: {}
  }

  type StressPredictionGetPayload<S extends boolean | null | undefined | StressPredictionDefaultArgs> = $Result.GetResult<Prisma.$StressPredictionPayload, S>

  type StressPredictionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StressPredictionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StressPredictionCountAggregateInputType | true
    }

  export interface StressPredictionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StressPrediction'], meta: { name: 'StressPrediction' } }
    /**
     * Find zero or one StressPrediction that matches the filter.
     * @param {StressPredictionFindUniqueArgs} args - Arguments to find a StressPrediction
     * @example
     * // Get one StressPrediction
     * const stressPrediction = await prisma.stressPrediction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StressPredictionFindUniqueArgs>(args: SelectSubset<T, StressPredictionFindUniqueArgs<ExtArgs>>): Prisma__StressPredictionClient<$Result.GetResult<Prisma.$StressPredictionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StressPrediction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StressPredictionFindUniqueOrThrowArgs} args - Arguments to find a StressPrediction
     * @example
     * // Get one StressPrediction
     * const stressPrediction = await prisma.stressPrediction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StressPredictionFindUniqueOrThrowArgs>(args: SelectSubset<T, StressPredictionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StressPredictionClient<$Result.GetResult<Prisma.$StressPredictionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StressPrediction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StressPredictionFindFirstArgs} args - Arguments to find a StressPrediction
     * @example
     * // Get one StressPrediction
     * const stressPrediction = await prisma.stressPrediction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StressPredictionFindFirstArgs>(args?: SelectSubset<T, StressPredictionFindFirstArgs<ExtArgs>>): Prisma__StressPredictionClient<$Result.GetResult<Prisma.$StressPredictionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StressPrediction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StressPredictionFindFirstOrThrowArgs} args - Arguments to find a StressPrediction
     * @example
     * // Get one StressPrediction
     * const stressPrediction = await prisma.stressPrediction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StressPredictionFindFirstOrThrowArgs>(args?: SelectSubset<T, StressPredictionFindFirstOrThrowArgs<ExtArgs>>): Prisma__StressPredictionClient<$Result.GetResult<Prisma.$StressPredictionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StressPredictions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StressPredictionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StressPredictions
     * const stressPredictions = await prisma.stressPrediction.findMany()
     * 
     * // Get first 10 StressPredictions
     * const stressPredictions = await prisma.stressPrediction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stressPredictionWithIdOnly = await prisma.stressPrediction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StressPredictionFindManyArgs>(args?: SelectSubset<T, StressPredictionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StressPredictionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StressPrediction.
     * @param {StressPredictionCreateArgs} args - Arguments to create a StressPrediction.
     * @example
     * // Create one StressPrediction
     * const StressPrediction = await prisma.stressPrediction.create({
     *   data: {
     *     // ... data to create a StressPrediction
     *   }
     * })
     * 
     */
    create<T extends StressPredictionCreateArgs>(args: SelectSubset<T, StressPredictionCreateArgs<ExtArgs>>): Prisma__StressPredictionClient<$Result.GetResult<Prisma.$StressPredictionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StressPredictions.
     * @param {StressPredictionCreateManyArgs} args - Arguments to create many StressPredictions.
     * @example
     * // Create many StressPredictions
     * const stressPrediction = await prisma.stressPrediction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StressPredictionCreateManyArgs>(args?: SelectSubset<T, StressPredictionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StressPredictions and returns the data saved in the database.
     * @param {StressPredictionCreateManyAndReturnArgs} args - Arguments to create many StressPredictions.
     * @example
     * // Create many StressPredictions
     * const stressPrediction = await prisma.stressPrediction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StressPredictions and only return the `id`
     * const stressPredictionWithIdOnly = await prisma.stressPrediction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StressPredictionCreateManyAndReturnArgs>(args?: SelectSubset<T, StressPredictionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StressPredictionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StressPrediction.
     * @param {StressPredictionDeleteArgs} args - Arguments to delete one StressPrediction.
     * @example
     * // Delete one StressPrediction
     * const StressPrediction = await prisma.stressPrediction.delete({
     *   where: {
     *     // ... filter to delete one StressPrediction
     *   }
     * })
     * 
     */
    delete<T extends StressPredictionDeleteArgs>(args: SelectSubset<T, StressPredictionDeleteArgs<ExtArgs>>): Prisma__StressPredictionClient<$Result.GetResult<Prisma.$StressPredictionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StressPrediction.
     * @param {StressPredictionUpdateArgs} args - Arguments to update one StressPrediction.
     * @example
     * // Update one StressPrediction
     * const stressPrediction = await prisma.stressPrediction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StressPredictionUpdateArgs>(args: SelectSubset<T, StressPredictionUpdateArgs<ExtArgs>>): Prisma__StressPredictionClient<$Result.GetResult<Prisma.$StressPredictionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StressPredictions.
     * @param {StressPredictionDeleteManyArgs} args - Arguments to filter StressPredictions to delete.
     * @example
     * // Delete a few StressPredictions
     * const { count } = await prisma.stressPrediction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StressPredictionDeleteManyArgs>(args?: SelectSubset<T, StressPredictionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StressPredictions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StressPredictionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StressPredictions
     * const stressPrediction = await prisma.stressPrediction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StressPredictionUpdateManyArgs>(args: SelectSubset<T, StressPredictionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StressPredictions and returns the data updated in the database.
     * @param {StressPredictionUpdateManyAndReturnArgs} args - Arguments to update many StressPredictions.
     * @example
     * // Update many StressPredictions
     * const stressPrediction = await prisma.stressPrediction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StressPredictions and only return the `id`
     * const stressPredictionWithIdOnly = await prisma.stressPrediction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StressPredictionUpdateManyAndReturnArgs>(args: SelectSubset<T, StressPredictionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StressPredictionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StressPrediction.
     * @param {StressPredictionUpsertArgs} args - Arguments to update or create a StressPrediction.
     * @example
     * // Update or create a StressPrediction
     * const stressPrediction = await prisma.stressPrediction.upsert({
     *   create: {
     *     // ... data to create a StressPrediction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StressPrediction we want to update
     *   }
     * })
     */
    upsert<T extends StressPredictionUpsertArgs>(args: SelectSubset<T, StressPredictionUpsertArgs<ExtArgs>>): Prisma__StressPredictionClient<$Result.GetResult<Prisma.$StressPredictionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StressPredictions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StressPredictionCountArgs} args - Arguments to filter StressPredictions to count.
     * @example
     * // Count the number of StressPredictions
     * const count = await prisma.stressPrediction.count({
     *   where: {
     *     // ... the filter for the StressPredictions we want to count
     *   }
     * })
    **/
    count<T extends StressPredictionCountArgs>(
      args?: Subset<T, StressPredictionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StressPredictionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StressPrediction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StressPredictionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StressPredictionAggregateArgs>(args: Subset<T, StressPredictionAggregateArgs>): Prisma.PrismaPromise<GetStressPredictionAggregateType<T>>

    /**
     * Group by StressPrediction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StressPredictionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StressPredictionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StressPredictionGroupByArgs['orderBy'] }
        : { orderBy?: StressPredictionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StressPredictionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStressPredictionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StressPrediction model
   */
  readonly fields: StressPredictionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StressPrediction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StressPredictionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StressPrediction model
   */
  interface StressPredictionFieldRefs {
    readonly id: FieldRef<"StressPrediction", 'String'>
    readonly userId: FieldRef<"StressPrediction", 'String'>
    readonly predictedStressLevel: FieldRef<"StressPrediction", 'Int'>
    readonly confidence: FieldRef<"StressPrediction", 'Float'>
    readonly predictedAt: FieldRef<"StressPrediction", 'DateTime'>
    readonly modelVersion: FieldRef<"StressPrediction", 'String'>
    readonly triggers: FieldRef<"StressPrediction", 'Json'>
    readonly riskFactors: FieldRef<"StressPrediction", 'Json'>
    readonly recommendedInterventions: FieldRef<"StressPrediction", 'Json'>
    readonly preventionStrategies: FieldRef<"StressPrediction", 'Json'>
    readonly actualStressLevel: FieldRef<"StressPrediction", 'Int'>
    readonly wasAccurate: FieldRef<"StressPrediction", 'Boolean'>
    readonly createdAt: FieldRef<"StressPrediction", 'DateTime'>
    readonly updatedAt: FieldRef<"StressPrediction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StressPrediction findUnique
   */
  export type StressPredictionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StressPrediction
     */
    select?: StressPredictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StressPrediction
     */
    omit?: StressPredictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StressPredictionInclude<ExtArgs> | null
    /**
     * Filter, which StressPrediction to fetch.
     */
    where: StressPredictionWhereUniqueInput
  }

  /**
   * StressPrediction findUniqueOrThrow
   */
  export type StressPredictionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StressPrediction
     */
    select?: StressPredictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StressPrediction
     */
    omit?: StressPredictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StressPredictionInclude<ExtArgs> | null
    /**
     * Filter, which StressPrediction to fetch.
     */
    where: StressPredictionWhereUniqueInput
  }

  /**
   * StressPrediction findFirst
   */
  export type StressPredictionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StressPrediction
     */
    select?: StressPredictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StressPrediction
     */
    omit?: StressPredictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StressPredictionInclude<ExtArgs> | null
    /**
     * Filter, which StressPrediction to fetch.
     */
    where?: StressPredictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StressPredictions to fetch.
     */
    orderBy?: StressPredictionOrderByWithRelationInput | StressPredictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StressPredictions.
     */
    cursor?: StressPredictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StressPredictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StressPredictions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StressPredictions.
     */
    distinct?: StressPredictionScalarFieldEnum | StressPredictionScalarFieldEnum[]
  }

  /**
   * StressPrediction findFirstOrThrow
   */
  export type StressPredictionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StressPrediction
     */
    select?: StressPredictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StressPrediction
     */
    omit?: StressPredictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StressPredictionInclude<ExtArgs> | null
    /**
     * Filter, which StressPrediction to fetch.
     */
    where?: StressPredictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StressPredictions to fetch.
     */
    orderBy?: StressPredictionOrderByWithRelationInput | StressPredictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StressPredictions.
     */
    cursor?: StressPredictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StressPredictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StressPredictions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StressPredictions.
     */
    distinct?: StressPredictionScalarFieldEnum | StressPredictionScalarFieldEnum[]
  }

  /**
   * StressPrediction findMany
   */
  export type StressPredictionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StressPrediction
     */
    select?: StressPredictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StressPrediction
     */
    omit?: StressPredictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StressPredictionInclude<ExtArgs> | null
    /**
     * Filter, which StressPredictions to fetch.
     */
    where?: StressPredictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StressPredictions to fetch.
     */
    orderBy?: StressPredictionOrderByWithRelationInput | StressPredictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StressPredictions.
     */
    cursor?: StressPredictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StressPredictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StressPredictions.
     */
    skip?: number
    distinct?: StressPredictionScalarFieldEnum | StressPredictionScalarFieldEnum[]
  }

  /**
   * StressPrediction create
   */
  export type StressPredictionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StressPrediction
     */
    select?: StressPredictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StressPrediction
     */
    omit?: StressPredictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StressPredictionInclude<ExtArgs> | null
    /**
     * The data needed to create a StressPrediction.
     */
    data: XOR<StressPredictionCreateInput, StressPredictionUncheckedCreateInput>
  }

  /**
   * StressPrediction createMany
   */
  export type StressPredictionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StressPredictions.
     */
    data: StressPredictionCreateManyInput | StressPredictionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StressPrediction createManyAndReturn
   */
  export type StressPredictionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StressPrediction
     */
    select?: StressPredictionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StressPrediction
     */
    omit?: StressPredictionOmit<ExtArgs> | null
    /**
     * The data used to create many StressPredictions.
     */
    data: StressPredictionCreateManyInput | StressPredictionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StressPredictionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StressPrediction update
   */
  export type StressPredictionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StressPrediction
     */
    select?: StressPredictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StressPrediction
     */
    omit?: StressPredictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StressPredictionInclude<ExtArgs> | null
    /**
     * The data needed to update a StressPrediction.
     */
    data: XOR<StressPredictionUpdateInput, StressPredictionUncheckedUpdateInput>
    /**
     * Choose, which StressPrediction to update.
     */
    where: StressPredictionWhereUniqueInput
  }

  /**
   * StressPrediction updateMany
   */
  export type StressPredictionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StressPredictions.
     */
    data: XOR<StressPredictionUpdateManyMutationInput, StressPredictionUncheckedUpdateManyInput>
    /**
     * Filter which StressPredictions to update
     */
    where?: StressPredictionWhereInput
    /**
     * Limit how many StressPredictions to update.
     */
    limit?: number
  }

  /**
   * StressPrediction updateManyAndReturn
   */
  export type StressPredictionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StressPrediction
     */
    select?: StressPredictionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StressPrediction
     */
    omit?: StressPredictionOmit<ExtArgs> | null
    /**
     * The data used to update StressPredictions.
     */
    data: XOR<StressPredictionUpdateManyMutationInput, StressPredictionUncheckedUpdateManyInput>
    /**
     * Filter which StressPredictions to update
     */
    where?: StressPredictionWhereInput
    /**
     * Limit how many StressPredictions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StressPredictionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StressPrediction upsert
   */
  export type StressPredictionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StressPrediction
     */
    select?: StressPredictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StressPrediction
     */
    omit?: StressPredictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StressPredictionInclude<ExtArgs> | null
    /**
     * The filter to search for the StressPrediction to update in case it exists.
     */
    where: StressPredictionWhereUniqueInput
    /**
     * In case the StressPrediction found by the `where` argument doesn't exist, create a new StressPrediction with this data.
     */
    create: XOR<StressPredictionCreateInput, StressPredictionUncheckedCreateInput>
    /**
     * In case the StressPrediction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StressPredictionUpdateInput, StressPredictionUncheckedUpdateInput>
  }

  /**
   * StressPrediction delete
   */
  export type StressPredictionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StressPrediction
     */
    select?: StressPredictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StressPrediction
     */
    omit?: StressPredictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StressPredictionInclude<ExtArgs> | null
    /**
     * Filter which StressPrediction to delete.
     */
    where: StressPredictionWhereUniqueInput
  }

  /**
   * StressPrediction deleteMany
   */
  export type StressPredictionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StressPredictions to delete
     */
    where?: StressPredictionWhereInput
    /**
     * Limit how many StressPredictions to delete.
     */
    limit?: number
  }

  /**
   * StressPrediction without action
   */
  export type StressPredictionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StressPrediction
     */
    select?: StressPredictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StressPrediction
     */
    omit?: StressPredictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StressPredictionInclude<ExtArgs> | null
  }


  /**
   * Model WellnessChallenge
   */

  export type AggregateWellnessChallenge = {
    _count: WellnessChallengeCountAggregateOutputType | null
    _avg: WellnessChallengeAvgAggregateOutputType | null
    _sum: WellnessChallengeSumAggregateOutputType | null
    _min: WellnessChallengeMinAggregateOutputType | null
    _max: WellnessChallengeMaxAggregateOutputType | null
  }

  export type WellnessChallengeAvgAggregateOutputType = {
    duration: number | null
    maxParticipants: number | null
  }

  export type WellnessChallengeSumAggregateOutputType = {
    duration: number | null
    maxParticipants: number | null
  }

  export type WellnessChallengeMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    type: string | null
    duration: number | null
    reward: string | null
    isActive: boolean | null
    startDate: Date | null
    endDate: Date | null
    maxParticipants: number | null
    isPublic: boolean | null
    teamBased: boolean | null
    aiGenerated: boolean | null
    adaptiveDifficulty: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WellnessChallengeMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    type: string | null
    duration: number | null
    reward: string | null
    isActive: boolean | null
    startDate: Date | null
    endDate: Date | null
    maxParticipants: number | null
    isPublic: boolean | null
    teamBased: boolean | null
    aiGenerated: boolean | null
    adaptiveDifficulty: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WellnessChallengeCountAggregateOutputType = {
    id: number
    title: number
    description: number
    type: number
    duration: number
    target: number
    reward: number
    isActive: number
    startDate: number
    endDate: number
    maxParticipants: number
    isPublic: number
    teamBased: number
    aiGenerated: number
    adaptiveDifficulty: number
    personalizedGoals: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WellnessChallengeAvgAggregateInputType = {
    duration?: true
    maxParticipants?: true
  }

  export type WellnessChallengeSumAggregateInputType = {
    duration?: true
    maxParticipants?: true
  }

  export type WellnessChallengeMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    duration?: true
    reward?: true
    isActive?: true
    startDate?: true
    endDate?: true
    maxParticipants?: true
    isPublic?: true
    teamBased?: true
    aiGenerated?: true
    adaptiveDifficulty?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WellnessChallengeMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    duration?: true
    reward?: true
    isActive?: true
    startDate?: true
    endDate?: true
    maxParticipants?: true
    isPublic?: true
    teamBased?: true
    aiGenerated?: true
    adaptiveDifficulty?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WellnessChallengeCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    duration?: true
    target?: true
    reward?: true
    isActive?: true
    startDate?: true
    endDate?: true
    maxParticipants?: true
    isPublic?: true
    teamBased?: true
    aiGenerated?: true
    adaptiveDifficulty?: true
    personalizedGoals?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WellnessChallengeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WellnessChallenge to aggregate.
     */
    where?: WellnessChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WellnessChallenges to fetch.
     */
    orderBy?: WellnessChallengeOrderByWithRelationInput | WellnessChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WellnessChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WellnessChallenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WellnessChallenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WellnessChallenges
    **/
    _count?: true | WellnessChallengeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WellnessChallengeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WellnessChallengeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WellnessChallengeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WellnessChallengeMaxAggregateInputType
  }

  export type GetWellnessChallengeAggregateType<T extends WellnessChallengeAggregateArgs> = {
        [P in keyof T & keyof AggregateWellnessChallenge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWellnessChallenge[P]>
      : GetScalarType<T[P], AggregateWellnessChallenge[P]>
  }




  export type WellnessChallengeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WellnessChallengeWhereInput
    orderBy?: WellnessChallengeOrderByWithAggregationInput | WellnessChallengeOrderByWithAggregationInput[]
    by: WellnessChallengeScalarFieldEnum[] | WellnessChallengeScalarFieldEnum
    having?: WellnessChallengeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WellnessChallengeCountAggregateInputType | true
    _avg?: WellnessChallengeAvgAggregateInputType
    _sum?: WellnessChallengeSumAggregateInputType
    _min?: WellnessChallengeMinAggregateInputType
    _max?: WellnessChallengeMaxAggregateInputType
  }

  export type WellnessChallengeGroupByOutputType = {
    id: string
    title: string
    description: string
    type: string
    duration: number
    target: JsonValue
    reward: string | null
    isActive: boolean
    startDate: Date
    endDate: Date
    maxParticipants: number | null
    isPublic: boolean
    teamBased: boolean
    aiGenerated: boolean
    adaptiveDifficulty: boolean
    personalizedGoals: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: WellnessChallengeCountAggregateOutputType | null
    _avg: WellnessChallengeAvgAggregateOutputType | null
    _sum: WellnessChallengeSumAggregateOutputType | null
    _min: WellnessChallengeMinAggregateOutputType | null
    _max: WellnessChallengeMaxAggregateOutputType | null
  }

  type GetWellnessChallengeGroupByPayload<T extends WellnessChallengeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WellnessChallengeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WellnessChallengeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WellnessChallengeGroupByOutputType[P]>
            : GetScalarType<T[P], WellnessChallengeGroupByOutputType[P]>
        }
      >
    >


  export type WellnessChallengeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    duration?: boolean
    target?: boolean
    reward?: boolean
    isActive?: boolean
    startDate?: boolean
    endDate?: boolean
    maxParticipants?: boolean
    isPublic?: boolean
    teamBased?: boolean
    aiGenerated?: boolean
    adaptiveDifficulty?: boolean
    personalizedGoals?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    participants?: boolean | WellnessChallenge$participantsArgs<ExtArgs>
    _count?: boolean | WellnessChallengeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wellnessChallenge"]>

  export type WellnessChallengeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    duration?: boolean
    target?: boolean
    reward?: boolean
    isActive?: boolean
    startDate?: boolean
    endDate?: boolean
    maxParticipants?: boolean
    isPublic?: boolean
    teamBased?: boolean
    aiGenerated?: boolean
    adaptiveDifficulty?: boolean
    personalizedGoals?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["wellnessChallenge"]>

  export type WellnessChallengeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    duration?: boolean
    target?: boolean
    reward?: boolean
    isActive?: boolean
    startDate?: boolean
    endDate?: boolean
    maxParticipants?: boolean
    isPublic?: boolean
    teamBased?: boolean
    aiGenerated?: boolean
    adaptiveDifficulty?: boolean
    personalizedGoals?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["wellnessChallenge"]>

  export type WellnessChallengeSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    duration?: boolean
    target?: boolean
    reward?: boolean
    isActive?: boolean
    startDate?: boolean
    endDate?: boolean
    maxParticipants?: boolean
    isPublic?: boolean
    teamBased?: boolean
    aiGenerated?: boolean
    adaptiveDifficulty?: boolean
    personalizedGoals?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WellnessChallengeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "type" | "duration" | "target" | "reward" | "isActive" | "startDate" | "endDate" | "maxParticipants" | "isPublic" | "teamBased" | "aiGenerated" | "adaptiveDifficulty" | "personalizedGoals" | "createdAt" | "updatedAt", ExtArgs["result"]["wellnessChallenge"]>
  export type WellnessChallengeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participants?: boolean | WellnessChallenge$participantsArgs<ExtArgs>
    _count?: boolean | WellnessChallengeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WellnessChallengeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type WellnessChallengeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $WellnessChallengePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WellnessChallenge"
    objects: {
      participants: Prisma.$ChallengeParticipantPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      type: string
      duration: number
      target: Prisma.JsonValue
      reward: string | null
      isActive: boolean
      startDate: Date
      endDate: Date
      maxParticipants: number | null
      isPublic: boolean
      teamBased: boolean
      aiGenerated: boolean
      adaptiveDifficulty: boolean
      personalizedGoals: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["wellnessChallenge"]>
    composites: {}
  }

  type WellnessChallengeGetPayload<S extends boolean | null | undefined | WellnessChallengeDefaultArgs> = $Result.GetResult<Prisma.$WellnessChallengePayload, S>

  type WellnessChallengeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WellnessChallengeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WellnessChallengeCountAggregateInputType | true
    }

  export interface WellnessChallengeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WellnessChallenge'], meta: { name: 'WellnessChallenge' } }
    /**
     * Find zero or one WellnessChallenge that matches the filter.
     * @param {WellnessChallengeFindUniqueArgs} args - Arguments to find a WellnessChallenge
     * @example
     * // Get one WellnessChallenge
     * const wellnessChallenge = await prisma.wellnessChallenge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WellnessChallengeFindUniqueArgs>(args: SelectSubset<T, WellnessChallengeFindUniqueArgs<ExtArgs>>): Prisma__WellnessChallengeClient<$Result.GetResult<Prisma.$WellnessChallengePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WellnessChallenge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WellnessChallengeFindUniqueOrThrowArgs} args - Arguments to find a WellnessChallenge
     * @example
     * // Get one WellnessChallenge
     * const wellnessChallenge = await prisma.wellnessChallenge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WellnessChallengeFindUniqueOrThrowArgs>(args: SelectSubset<T, WellnessChallengeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WellnessChallengeClient<$Result.GetResult<Prisma.$WellnessChallengePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WellnessChallenge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellnessChallengeFindFirstArgs} args - Arguments to find a WellnessChallenge
     * @example
     * // Get one WellnessChallenge
     * const wellnessChallenge = await prisma.wellnessChallenge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WellnessChallengeFindFirstArgs>(args?: SelectSubset<T, WellnessChallengeFindFirstArgs<ExtArgs>>): Prisma__WellnessChallengeClient<$Result.GetResult<Prisma.$WellnessChallengePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WellnessChallenge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellnessChallengeFindFirstOrThrowArgs} args - Arguments to find a WellnessChallenge
     * @example
     * // Get one WellnessChallenge
     * const wellnessChallenge = await prisma.wellnessChallenge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WellnessChallengeFindFirstOrThrowArgs>(args?: SelectSubset<T, WellnessChallengeFindFirstOrThrowArgs<ExtArgs>>): Prisma__WellnessChallengeClient<$Result.GetResult<Prisma.$WellnessChallengePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WellnessChallenges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellnessChallengeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WellnessChallenges
     * const wellnessChallenges = await prisma.wellnessChallenge.findMany()
     * 
     * // Get first 10 WellnessChallenges
     * const wellnessChallenges = await prisma.wellnessChallenge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wellnessChallengeWithIdOnly = await prisma.wellnessChallenge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WellnessChallengeFindManyArgs>(args?: SelectSubset<T, WellnessChallengeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WellnessChallengePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WellnessChallenge.
     * @param {WellnessChallengeCreateArgs} args - Arguments to create a WellnessChallenge.
     * @example
     * // Create one WellnessChallenge
     * const WellnessChallenge = await prisma.wellnessChallenge.create({
     *   data: {
     *     // ... data to create a WellnessChallenge
     *   }
     * })
     * 
     */
    create<T extends WellnessChallengeCreateArgs>(args: SelectSubset<T, WellnessChallengeCreateArgs<ExtArgs>>): Prisma__WellnessChallengeClient<$Result.GetResult<Prisma.$WellnessChallengePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WellnessChallenges.
     * @param {WellnessChallengeCreateManyArgs} args - Arguments to create many WellnessChallenges.
     * @example
     * // Create many WellnessChallenges
     * const wellnessChallenge = await prisma.wellnessChallenge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WellnessChallengeCreateManyArgs>(args?: SelectSubset<T, WellnessChallengeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WellnessChallenges and returns the data saved in the database.
     * @param {WellnessChallengeCreateManyAndReturnArgs} args - Arguments to create many WellnessChallenges.
     * @example
     * // Create many WellnessChallenges
     * const wellnessChallenge = await prisma.wellnessChallenge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WellnessChallenges and only return the `id`
     * const wellnessChallengeWithIdOnly = await prisma.wellnessChallenge.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WellnessChallengeCreateManyAndReturnArgs>(args?: SelectSubset<T, WellnessChallengeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WellnessChallengePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WellnessChallenge.
     * @param {WellnessChallengeDeleteArgs} args - Arguments to delete one WellnessChallenge.
     * @example
     * // Delete one WellnessChallenge
     * const WellnessChallenge = await prisma.wellnessChallenge.delete({
     *   where: {
     *     // ... filter to delete one WellnessChallenge
     *   }
     * })
     * 
     */
    delete<T extends WellnessChallengeDeleteArgs>(args: SelectSubset<T, WellnessChallengeDeleteArgs<ExtArgs>>): Prisma__WellnessChallengeClient<$Result.GetResult<Prisma.$WellnessChallengePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WellnessChallenge.
     * @param {WellnessChallengeUpdateArgs} args - Arguments to update one WellnessChallenge.
     * @example
     * // Update one WellnessChallenge
     * const wellnessChallenge = await prisma.wellnessChallenge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WellnessChallengeUpdateArgs>(args: SelectSubset<T, WellnessChallengeUpdateArgs<ExtArgs>>): Prisma__WellnessChallengeClient<$Result.GetResult<Prisma.$WellnessChallengePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WellnessChallenges.
     * @param {WellnessChallengeDeleteManyArgs} args - Arguments to filter WellnessChallenges to delete.
     * @example
     * // Delete a few WellnessChallenges
     * const { count } = await prisma.wellnessChallenge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WellnessChallengeDeleteManyArgs>(args?: SelectSubset<T, WellnessChallengeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WellnessChallenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellnessChallengeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WellnessChallenges
     * const wellnessChallenge = await prisma.wellnessChallenge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WellnessChallengeUpdateManyArgs>(args: SelectSubset<T, WellnessChallengeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WellnessChallenges and returns the data updated in the database.
     * @param {WellnessChallengeUpdateManyAndReturnArgs} args - Arguments to update many WellnessChallenges.
     * @example
     * // Update many WellnessChallenges
     * const wellnessChallenge = await prisma.wellnessChallenge.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WellnessChallenges and only return the `id`
     * const wellnessChallengeWithIdOnly = await prisma.wellnessChallenge.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WellnessChallengeUpdateManyAndReturnArgs>(args: SelectSubset<T, WellnessChallengeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WellnessChallengePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WellnessChallenge.
     * @param {WellnessChallengeUpsertArgs} args - Arguments to update or create a WellnessChallenge.
     * @example
     * // Update or create a WellnessChallenge
     * const wellnessChallenge = await prisma.wellnessChallenge.upsert({
     *   create: {
     *     // ... data to create a WellnessChallenge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WellnessChallenge we want to update
     *   }
     * })
     */
    upsert<T extends WellnessChallengeUpsertArgs>(args: SelectSubset<T, WellnessChallengeUpsertArgs<ExtArgs>>): Prisma__WellnessChallengeClient<$Result.GetResult<Prisma.$WellnessChallengePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WellnessChallenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellnessChallengeCountArgs} args - Arguments to filter WellnessChallenges to count.
     * @example
     * // Count the number of WellnessChallenges
     * const count = await prisma.wellnessChallenge.count({
     *   where: {
     *     // ... the filter for the WellnessChallenges we want to count
     *   }
     * })
    **/
    count<T extends WellnessChallengeCountArgs>(
      args?: Subset<T, WellnessChallengeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WellnessChallengeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WellnessChallenge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellnessChallengeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WellnessChallengeAggregateArgs>(args: Subset<T, WellnessChallengeAggregateArgs>): Prisma.PrismaPromise<GetWellnessChallengeAggregateType<T>>

    /**
     * Group by WellnessChallenge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellnessChallengeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WellnessChallengeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WellnessChallengeGroupByArgs['orderBy'] }
        : { orderBy?: WellnessChallengeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WellnessChallengeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWellnessChallengeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WellnessChallenge model
   */
  readonly fields: WellnessChallengeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WellnessChallenge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WellnessChallengeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    participants<T extends WellnessChallenge$participantsArgs<ExtArgs> = {}>(args?: Subset<T, WellnessChallenge$participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WellnessChallenge model
   */
  interface WellnessChallengeFieldRefs {
    readonly id: FieldRef<"WellnessChallenge", 'String'>
    readonly title: FieldRef<"WellnessChallenge", 'String'>
    readonly description: FieldRef<"WellnessChallenge", 'String'>
    readonly type: FieldRef<"WellnessChallenge", 'String'>
    readonly duration: FieldRef<"WellnessChallenge", 'Int'>
    readonly target: FieldRef<"WellnessChallenge", 'Json'>
    readonly reward: FieldRef<"WellnessChallenge", 'String'>
    readonly isActive: FieldRef<"WellnessChallenge", 'Boolean'>
    readonly startDate: FieldRef<"WellnessChallenge", 'DateTime'>
    readonly endDate: FieldRef<"WellnessChallenge", 'DateTime'>
    readonly maxParticipants: FieldRef<"WellnessChallenge", 'Int'>
    readonly isPublic: FieldRef<"WellnessChallenge", 'Boolean'>
    readonly teamBased: FieldRef<"WellnessChallenge", 'Boolean'>
    readonly aiGenerated: FieldRef<"WellnessChallenge", 'Boolean'>
    readonly adaptiveDifficulty: FieldRef<"WellnessChallenge", 'Boolean'>
    readonly personalizedGoals: FieldRef<"WellnessChallenge", 'Json'>
    readonly createdAt: FieldRef<"WellnessChallenge", 'DateTime'>
    readonly updatedAt: FieldRef<"WellnessChallenge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WellnessChallenge findUnique
   */
  export type WellnessChallengeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellnessChallenge
     */
    select?: WellnessChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellnessChallenge
     */
    omit?: WellnessChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellnessChallengeInclude<ExtArgs> | null
    /**
     * Filter, which WellnessChallenge to fetch.
     */
    where: WellnessChallengeWhereUniqueInput
  }

  /**
   * WellnessChallenge findUniqueOrThrow
   */
  export type WellnessChallengeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellnessChallenge
     */
    select?: WellnessChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellnessChallenge
     */
    omit?: WellnessChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellnessChallengeInclude<ExtArgs> | null
    /**
     * Filter, which WellnessChallenge to fetch.
     */
    where: WellnessChallengeWhereUniqueInput
  }

  /**
   * WellnessChallenge findFirst
   */
  export type WellnessChallengeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellnessChallenge
     */
    select?: WellnessChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellnessChallenge
     */
    omit?: WellnessChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellnessChallengeInclude<ExtArgs> | null
    /**
     * Filter, which WellnessChallenge to fetch.
     */
    where?: WellnessChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WellnessChallenges to fetch.
     */
    orderBy?: WellnessChallengeOrderByWithRelationInput | WellnessChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WellnessChallenges.
     */
    cursor?: WellnessChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WellnessChallenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WellnessChallenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WellnessChallenges.
     */
    distinct?: WellnessChallengeScalarFieldEnum | WellnessChallengeScalarFieldEnum[]
  }

  /**
   * WellnessChallenge findFirstOrThrow
   */
  export type WellnessChallengeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellnessChallenge
     */
    select?: WellnessChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellnessChallenge
     */
    omit?: WellnessChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellnessChallengeInclude<ExtArgs> | null
    /**
     * Filter, which WellnessChallenge to fetch.
     */
    where?: WellnessChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WellnessChallenges to fetch.
     */
    orderBy?: WellnessChallengeOrderByWithRelationInput | WellnessChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WellnessChallenges.
     */
    cursor?: WellnessChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WellnessChallenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WellnessChallenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WellnessChallenges.
     */
    distinct?: WellnessChallengeScalarFieldEnum | WellnessChallengeScalarFieldEnum[]
  }

  /**
   * WellnessChallenge findMany
   */
  export type WellnessChallengeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellnessChallenge
     */
    select?: WellnessChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellnessChallenge
     */
    omit?: WellnessChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellnessChallengeInclude<ExtArgs> | null
    /**
     * Filter, which WellnessChallenges to fetch.
     */
    where?: WellnessChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WellnessChallenges to fetch.
     */
    orderBy?: WellnessChallengeOrderByWithRelationInput | WellnessChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WellnessChallenges.
     */
    cursor?: WellnessChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WellnessChallenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WellnessChallenges.
     */
    skip?: number
    distinct?: WellnessChallengeScalarFieldEnum | WellnessChallengeScalarFieldEnum[]
  }

  /**
   * WellnessChallenge create
   */
  export type WellnessChallengeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellnessChallenge
     */
    select?: WellnessChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellnessChallenge
     */
    omit?: WellnessChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellnessChallengeInclude<ExtArgs> | null
    /**
     * The data needed to create a WellnessChallenge.
     */
    data: XOR<WellnessChallengeCreateInput, WellnessChallengeUncheckedCreateInput>
  }

  /**
   * WellnessChallenge createMany
   */
  export type WellnessChallengeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WellnessChallenges.
     */
    data: WellnessChallengeCreateManyInput | WellnessChallengeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WellnessChallenge createManyAndReturn
   */
  export type WellnessChallengeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellnessChallenge
     */
    select?: WellnessChallengeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WellnessChallenge
     */
    omit?: WellnessChallengeOmit<ExtArgs> | null
    /**
     * The data used to create many WellnessChallenges.
     */
    data: WellnessChallengeCreateManyInput | WellnessChallengeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WellnessChallenge update
   */
  export type WellnessChallengeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellnessChallenge
     */
    select?: WellnessChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellnessChallenge
     */
    omit?: WellnessChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellnessChallengeInclude<ExtArgs> | null
    /**
     * The data needed to update a WellnessChallenge.
     */
    data: XOR<WellnessChallengeUpdateInput, WellnessChallengeUncheckedUpdateInput>
    /**
     * Choose, which WellnessChallenge to update.
     */
    where: WellnessChallengeWhereUniqueInput
  }

  /**
   * WellnessChallenge updateMany
   */
  export type WellnessChallengeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WellnessChallenges.
     */
    data: XOR<WellnessChallengeUpdateManyMutationInput, WellnessChallengeUncheckedUpdateManyInput>
    /**
     * Filter which WellnessChallenges to update
     */
    where?: WellnessChallengeWhereInput
    /**
     * Limit how many WellnessChallenges to update.
     */
    limit?: number
  }

  /**
   * WellnessChallenge updateManyAndReturn
   */
  export type WellnessChallengeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellnessChallenge
     */
    select?: WellnessChallengeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WellnessChallenge
     */
    omit?: WellnessChallengeOmit<ExtArgs> | null
    /**
     * The data used to update WellnessChallenges.
     */
    data: XOR<WellnessChallengeUpdateManyMutationInput, WellnessChallengeUncheckedUpdateManyInput>
    /**
     * Filter which WellnessChallenges to update
     */
    where?: WellnessChallengeWhereInput
    /**
     * Limit how many WellnessChallenges to update.
     */
    limit?: number
  }

  /**
   * WellnessChallenge upsert
   */
  export type WellnessChallengeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellnessChallenge
     */
    select?: WellnessChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellnessChallenge
     */
    omit?: WellnessChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellnessChallengeInclude<ExtArgs> | null
    /**
     * The filter to search for the WellnessChallenge to update in case it exists.
     */
    where: WellnessChallengeWhereUniqueInput
    /**
     * In case the WellnessChallenge found by the `where` argument doesn't exist, create a new WellnessChallenge with this data.
     */
    create: XOR<WellnessChallengeCreateInput, WellnessChallengeUncheckedCreateInput>
    /**
     * In case the WellnessChallenge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WellnessChallengeUpdateInput, WellnessChallengeUncheckedUpdateInput>
  }

  /**
   * WellnessChallenge delete
   */
  export type WellnessChallengeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellnessChallenge
     */
    select?: WellnessChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellnessChallenge
     */
    omit?: WellnessChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellnessChallengeInclude<ExtArgs> | null
    /**
     * Filter which WellnessChallenge to delete.
     */
    where: WellnessChallengeWhereUniqueInput
  }

  /**
   * WellnessChallenge deleteMany
   */
  export type WellnessChallengeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WellnessChallenges to delete
     */
    where?: WellnessChallengeWhereInput
    /**
     * Limit how many WellnessChallenges to delete.
     */
    limit?: number
  }

  /**
   * WellnessChallenge.participants
   */
  export type WellnessChallenge$participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeParticipant
     */
    select?: ChallengeParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeParticipant
     */
    omit?: ChallengeParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeParticipantInclude<ExtArgs> | null
    where?: ChallengeParticipantWhereInput
    orderBy?: ChallengeParticipantOrderByWithRelationInput | ChallengeParticipantOrderByWithRelationInput[]
    cursor?: ChallengeParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChallengeParticipantScalarFieldEnum | ChallengeParticipantScalarFieldEnum[]
  }

  /**
   * WellnessChallenge without action
   */
  export type WellnessChallengeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellnessChallenge
     */
    select?: WellnessChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellnessChallenge
     */
    omit?: WellnessChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellnessChallengeInclude<ExtArgs> | null
  }


  /**
   * Model ChallengeParticipant
   */

  export type AggregateChallengeParticipant = {
    _count: ChallengeParticipantCountAggregateOutputType | null
    _avg: ChallengeParticipantAvgAggregateOutputType | null
    _sum: ChallengeParticipantSumAggregateOutputType | null
    _min: ChallengeParticipantMinAggregateOutputType | null
    _max: ChallengeParticipantMaxAggregateOutputType | null
  }

  export type ChallengeParticipantAvgAggregateOutputType = {
    currentStreak: number | null
    bestStreak: number | null
    rank: number | null
  }

  export type ChallengeParticipantSumAggregateOutputType = {
    currentStreak: number | null
    bestStreak: number | null
    rank: number | null
  }

  export type ChallengeParticipantMinAggregateOutputType = {
    id: string | null
    userId: string | null
    challengeId: string | null
    completed: boolean | null
    currentStreak: number | null
    bestStreak: number | null
    rank: number | null
    joinedAt: Date | null
    completedAt: Date | null
  }

  export type ChallengeParticipantMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    challengeId: string | null
    completed: boolean | null
    currentStreak: number | null
    bestStreak: number | null
    rank: number | null
    joinedAt: Date | null
    completedAt: Date | null
  }

  export type ChallengeParticipantCountAggregateOutputType = {
    id: number
    userId: number
    challengeId: number
    progress: number
    completed: number
    currentStreak: number
    bestStreak: number
    rank: number
    joinedAt: number
    completedAt: number
    _all: number
  }


  export type ChallengeParticipantAvgAggregateInputType = {
    currentStreak?: true
    bestStreak?: true
    rank?: true
  }

  export type ChallengeParticipantSumAggregateInputType = {
    currentStreak?: true
    bestStreak?: true
    rank?: true
  }

  export type ChallengeParticipantMinAggregateInputType = {
    id?: true
    userId?: true
    challengeId?: true
    completed?: true
    currentStreak?: true
    bestStreak?: true
    rank?: true
    joinedAt?: true
    completedAt?: true
  }

  export type ChallengeParticipantMaxAggregateInputType = {
    id?: true
    userId?: true
    challengeId?: true
    completed?: true
    currentStreak?: true
    bestStreak?: true
    rank?: true
    joinedAt?: true
    completedAt?: true
  }

  export type ChallengeParticipantCountAggregateInputType = {
    id?: true
    userId?: true
    challengeId?: true
    progress?: true
    completed?: true
    currentStreak?: true
    bestStreak?: true
    rank?: true
    joinedAt?: true
    completedAt?: true
    _all?: true
  }

  export type ChallengeParticipantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeParticipant to aggregate.
     */
    where?: ChallengeParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeParticipants to fetch.
     */
    orderBy?: ChallengeParticipantOrderByWithRelationInput | ChallengeParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChallengeParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChallengeParticipants
    **/
    _count?: true | ChallengeParticipantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChallengeParticipantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChallengeParticipantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChallengeParticipantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChallengeParticipantMaxAggregateInputType
  }

  export type GetChallengeParticipantAggregateType<T extends ChallengeParticipantAggregateArgs> = {
        [P in keyof T & keyof AggregateChallengeParticipant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChallengeParticipant[P]>
      : GetScalarType<T[P], AggregateChallengeParticipant[P]>
  }




  export type ChallengeParticipantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeParticipantWhereInput
    orderBy?: ChallengeParticipantOrderByWithAggregationInput | ChallengeParticipantOrderByWithAggregationInput[]
    by: ChallengeParticipantScalarFieldEnum[] | ChallengeParticipantScalarFieldEnum
    having?: ChallengeParticipantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChallengeParticipantCountAggregateInputType | true
    _avg?: ChallengeParticipantAvgAggregateInputType
    _sum?: ChallengeParticipantSumAggregateInputType
    _min?: ChallengeParticipantMinAggregateInputType
    _max?: ChallengeParticipantMaxAggregateInputType
  }

  export type ChallengeParticipantGroupByOutputType = {
    id: string
    userId: string
    challengeId: string
    progress: JsonValue
    completed: boolean
    currentStreak: number
    bestStreak: number
    rank: number | null
    joinedAt: Date
    completedAt: Date | null
    _count: ChallengeParticipantCountAggregateOutputType | null
    _avg: ChallengeParticipantAvgAggregateOutputType | null
    _sum: ChallengeParticipantSumAggregateOutputType | null
    _min: ChallengeParticipantMinAggregateOutputType | null
    _max: ChallengeParticipantMaxAggregateOutputType | null
  }

  type GetChallengeParticipantGroupByPayload<T extends ChallengeParticipantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChallengeParticipantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChallengeParticipantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChallengeParticipantGroupByOutputType[P]>
            : GetScalarType<T[P], ChallengeParticipantGroupByOutputType[P]>
        }
      >
    >


  export type ChallengeParticipantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    challengeId?: boolean
    progress?: boolean
    completed?: boolean
    currentStreak?: boolean
    bestStreak?: boolean
    rank?: boolean
    joinedAt?: boolean
    completedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    challenge?: boolean | WellnessChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeParticipant"]>

  export type ChallengeParticipantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    challengeId?: boolean
    progress?: boolean
    completed?: boolean
    currentStreak?: boolean
    bestStreak?: boolean
    rank?: boolean
    joinedAt?: boolean
    completedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    challenge?: boolean | WellnessChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeParticipant"]>

  export type ChallengeParticipantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    challengeId?: boolean
    progress?: boolean
    completed?: boolean
    currentStreak?: boolean
    bestStreak?: boolean
    rank?: boolean
    joinedAt?: boolean
    completedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    challenge?: boolean | WellnessChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeParticipant"]>

  export type ChallengeParticipantSelectScalar = {
    id?: boolean
    userId?: boolean
    challengeId?: boolean
    progress?: boolean
    completed?: boolean
    currentStreak?: boolean
    bestStreak?: boolean
    rank?: boolean
    joinedAt?: boolean
    completedAt?: boolean
  }

  export type ChallengeParticipantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "challengeId" | "progress" | "completed" | "currentStreak" | "bestStreak" | "rank" | "joinedAt" | "completedAt", ExtArgs["result"]["challengeParticipant"]>
  export type ChallengeParticipantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    challenge?: boolean | WellnessChallengeDefaultArgs<ExtArgs>
  }
  export type ChallengeParticipantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    challenge?: boolean | WellnessChallengeDefaultArgs<ExtArgs>
  }
  export type ChallengeParticipantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    challenge?: boolean | WellnessChallengeDefaultArgs<ExtArgs>
  }

  export type $ChallengeParticipantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChallengeParticipant"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      challenge: Prisma.$WellnessChallengePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      challengeId: string
      progress: Prisma.JsonValue
      completed: boolean
      currentStreak: number
      bestStreak: number
      rank: number | null
      joinedAt: Date
      completedAt: Date | null
    }, ExtArgs["result"]["challengeParticipant"]>
    composites: {}
  }

  type ChallengeParticipantGetPayload<S extends boolean | null | undefined | ChallengeParticipantDefaultArgs> = $Result.GetResult<Prisma.$ChallengeParticipantPayload, S>

  type ChallengeParticipantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChallengeParticipantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChallengeParticipantCountAggregateInputType | true
    }

  export interface ChallengeParticipantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChallengeParticipant'], meta: { name: 'ChallengeParticipant' } }
    /**
     * Find zero or one ChallengeParticipant that matches the filter.
     * @param {ChallengeParticipantFindUniqueArgs} args - Arguments to find a ChallengeParticipant
     * @example
     * // Get one ChallengeParticipant
     * const challengeParticipant = await prisma.challengeParticipant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChallengeParticipantFindUniqueArgs>(args: SelectSubset<T, ChallengeParticipantFindUniqueArgs<ExtArgs>>): Prisma__ChallengeParticipantClient<$Result.GetResult<Prisma.$ChallengeParticipantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChallengeParticipant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChallengeParticipantFindUniqueOrThrowArgs} args - Arguments to find a ChallengeParticipant
     * @example
     * // Get one ChallengeParticipant
     * const challengeParticipant = await prisma.challengeParticipant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChallengeParticipantFindUniqueOrThrowArgs>(args: SelectSubset<T, ChallengeParticipantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChallengeParticipantClient<$Result.GetResult<Prisma.$ChallengeParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengeParticipant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeParticipantFindFirstArgs} args - Arguments to find a ChallengeParticipant
     * @example
     * // Get one ChallengeParticipant
     * const challengeParticipant = await prisma.challengeParticipant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChallengeParticipantFindFirstArgs>(args?: SelectSubset<T, ChallengeParticipantFindFirstArgs<ExtArgs>>): Prisma__ChallengeParticipantClient<$Result.GetResult<Prisma.$ChallengeParticipantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengeParticipant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeParticipantFindFirstOrThrowArgs} args - Arguments to find a ChallengeParticipant
     * @example
     * // Get one ChallengeParticipant
     * const challengeParticipant = await prisma.challengeParticipant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChallengeParticipantFindFirstOrThrowArgs>(args?: SelectSubset<T, ChallengeParticipantFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChallengeParticipantClient<$Result.GetResult<Prisma.$ChallengeParticipantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChallengeParticipants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeParticipantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChallengeParticipants
     * const challengeParticipants = await prisma.challengeParticipant.findMany()
     * 
     * // Get first 10 ChallengeParticipants
     * const challengeParticipants = await prisma.challengeParticipant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const challengeParticipantWithIdOnly = await prisma.challengeParticipant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChallengeParticipantFindManyArgs>(args?: SelectSubset<T, ChallengeParticipantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChallengeParticipant.
     * @param {ChallengeParticipantCreateArgs} args - Arguments to create a ChallengeParticipant.
     * @example
     * // Create one ChallengeParticipant
     * const ChallengeParticipant = await prisma.challengeParticipant.create({
     *   data: {
     *     // ... data to create a ChallengeParticipant
     *   }
     * })
     * 
     */
    create<T extends ChallengeParticipantCreateArgs>(args: SelectSubset<T, ChallengeParticipantCreateArgs<ExtArgs>>): Prisma__ChallengeParticipantClient<$Result.GetResult<Prisma.$ChallengeParticipantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChallengeParticipants.
     * @param {ChallengeParticipantCreateManyArgs} args - Arguments to create many ChallengeParticipants.
     * @example
     * // Create many ChallengeParticipants
     * const challengeParticipant = await prisma.challengeParticipant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChallengeParticipantCreateManyArgs>(args?: SelectSubset<T, ChallengeParticipantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChallengeParticipants and returns the data saved in the database.
     * @param {ChallengeParticipantCreateManyAndReturnArgs} args - Arguments to create many ChallengeParticipants.
     * @example
     * // Create many ChallengeParticipants
     * const challengeParticipant = await prisma.challengeParticipant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChallengeParticipants and only return the `id`
     * const challengeParticipantWithIdOnly = await prisma.challengeParticipant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChallengeParticipantCreateManyAndReturnArgs>(args?: SelectSubset<T, ChallengeParticipantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeParticipantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChallengeParticipant.
     * @param {ChallengeParticipantDeleteArgs} args - Arguments to delete one ChallengeParticipant.
     * @example
     * // Delete one ChallengeParticipant
     * const ChallengeParticipant = await prisma.challengeParticipant.delete({
     *   where: {
     *     // ... filter to delete one ChallengeParticipant
     *   }
     * })
     * 
     */
    delete<T extends ChallengeParticipantDeleteArgs>(args: SelectSubset<T, ChallengeParticipantDeleteArgs<ExtArgs>>): Prisma__ChallengeParticipantClient<$Result.GetResult<Prisma.$ChallengeParticipantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChallengeParticipant.
     * @param {ChallengeParticipantUpdateArgs} args - Arguments to update one ChallengeParticipant.
     * @example
     * // Update one ChallengeParticipant
     * const challengeParticipant = await prisma.challengeParticipant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChallengeParticipantUpdateArgs>(args: SelectSubset<T, ChallengeParticipantUpdateArgs<ExtArgs>>): Prisma__ChallengeParticipantClient<$Result.GetResult<Prisma.$ChallengeParticipantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChallengeParticipants.
     * @param {ChallengeParticipantDeleteManyArgs} args - Arguments to filter ChallengeParticipants to delete.
     * @example
     * // Delete a few ChallengeParticipants
     * const { count } = await prisma.challengeParticipant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChallengeParticipantDeleteManyArgs>(args?: SelectSubset<T, ChallengeParticipantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeParticipantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChallengeParticipants
     * const challengeParticipant = await prisma.challengeParticipant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChallengeParticipantUpdateManyArgs>(args: SelectSubset<T, ChallengeParticipantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeParticipants and returns the data updated in the database.
     * @param {ChallengeParticipantUpdateManyAndReturnArgs} args - Arguments to update many ChallengeParticipants.
     * @example
     * // Update many ChallengeParticipants
     * const challengeParticipant = await prisma.challengeParticipant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChallengeParticipants and only return the `id`
     * const challengeParticipantWithIdOnly = await prisma.challengeParticipant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChallengeParticipantUpdateManyAndReturnArgs>(args: SelectSubset<T, ChallengeParticipantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeParticipantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChallengeParticipant.
     * @param {ChallengeParticipantUpsertArgs} args - Arguments to update or create a ChallengeParticipant.
     * @example
     * // Update or create a ChallengeParticipant
     * const challengeParticipant = await prisma.challengeParticipant.upsert({
     *   create: {
     *     // ... data to create a ChallengeParticipant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChallengeParticipant we want to update
     *   }
     * })
     */
    upsert<T extends ChallengeParticipantUpsertArgs>(args: SelectSubset<T, ChallengeParticipantUpsertArgs<ExtArgs>>): Prisma__ChallengeParticipantClient<$Result.GetResult<Prisma.$ChallengeParticipantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChallengeParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeParticipantCountArgs} args - Arguments to filter ChallengeParticipants to count.
     * @example
     * // Count the number of ChallengeParticipants
     * const count = await prisma.challengeParticipant.count({
     *   where: {
     *     // ... the filter for the ChallengeParticipants we want to count
     *   }
     * })
    **/
    count<T extends ChallengeParticipantCountArgs>(
      args?: Subset<T, ChallengeParticipantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChallengeParticipantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChallengeParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeParticipantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChallengeParticipantAggregateArgs>(args: Subset<T, ChallengeParticipantAggregateArgs>): Prisma.PrismaPromise<GetChallengeParticipantAggregateType<T>>

    /**
     * Group by ChallengeParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeParticipantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChallengeParticipantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChallengeParticipantGroupByArgs['orderBy'] }
        : { orderBy?: ChallengeParticipantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChallengeParticipantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChallengeParticipantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChallengeParticipant model
   */
  readonly fields: ChallengeParticipantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChallengeParticipant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChallengeParticipantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    challenge<T extends WellnessChallengeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WellnessChallengeDefaultArgs<ExtArgs>>): Prisma__WellnessChallengeClient<$Result.GetResult<Prisma.$WellnessChallengePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChallengeParticipant model
   */
  interface ChallengeParticipantFieldRefs {
    readonly id: FieldRef<"ChallengeParticipant", 'String'>
    readonly userId: FieldRef<"ChallengeParticipant", 'String'>
    readonly challengeId: FieldRef<"ChallengeParticipant", 'String'>
    readonly progress: FieldRef<"ChallengeParticipant", 'Json'>
    readonly completed: FieldRef<"ChallengeParticipant", 'Boolean'>
    readonly currentStreak: FieldRef<"ChallengeParticipant", 'Int'>
    readonly bestStreak: FieldRef<"ChallengeParticipant", 'Int'>
    readonly rank: FieldRef<"ChallengeParticipant", 'Int'>
    readonly joinedAt: FieldRef<"ChallengeParticipant", 'DateTime'>
    readonly completedAt: FieldRef<"ChallengeParticipant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChallengeParticipant findUnique
   */
  export type ChallengeParticipantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeParticipant
     */
    select?: ChallengeParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeParticipant
     */
    omit?: ChallengeParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeParticipant to fetch.
     */
    where: ChallengeParticipantWhereUniqueInput
  }

  /**
   * ChallengeParticipant findUniqueOrThrow
   */
  export type ChallengeParticipantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeParticipant
     */
    select?: ChallengeParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeParticipant
     */
    omit?: ChallengeParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeParticipant to fetch.
     */
    where: ChallengeParticipantWhereUniqueInput
  }

  /**
   * ChallengeParticipant findFirst
   */
  export type ChallengeParticipantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeParticipant
     */
    select?: ChallengeParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeParticipant
     */
    omit?: ChallengeParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeParticipant to fetch.
     */
    where?: ChallengeParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeParticipants to fetch.
     */
    orderBy?: ChallengeParticipantOrderByWithRelationInput | ChallengeParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeParticipants.
     */
    cursor?: ChallengeParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeParticipants.
     */
    distinct?: ChallengeParticipantScalarFieldEnum | ChallengeParticipantScalarFieldEnum[]
  }

  /**
   * ChallengeParticipant findFirstOrThrow
   */
  export type ChallengeParticipantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeParticipant
     */
    select?: ChallengeParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeParticipant
     */
    omit?: ChallengeParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeParticipant to fetch.
     */
    where?: ChallengeParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeParticipants to fetch.
     */
    orderBy?: ChallengeParticipantOrderByWithRelationInput | ChallengeParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeParticipants.
     */
    cursor?: ChallengeParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeParticipants.
     */
    distinct?: ChallengeParticipantScalarFieldEnum | ChallengeParticipantScalarFieldEnum[]
  }

  /**
   * ChallengeParticipant findMany
   */
  export type ChallengeParticipantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeParticipant
     */
    select?: ChallengeParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeParticipant
     */
    omit?: ChallengeParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeParticipants to fetch.
     */
    where?: ChallengeParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeParticipants to fetch.
     */
    orderBy?: ChallengeParticipantOrderByWithRelationInput | ChallengeParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChallengeParticipants.
     */
    cursor?: ChallengeParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeParticipants.
     */
    skip?: number
    distinct?: ChallengeParticipantScalarFieldEnum | ChallengeParticipantScalarFieldEnum[]
  }

  /**
   * ChallengeParticipant create
   */
  export type ChallengeParticipantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeParticipant
     */
    select?: ChallengeParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeParticipant
     */
    omit?: ChallengeParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeParticipantInclude<ExtArgs> | null
    /**
     * The data needed to create a ChallengeParticipant.
     */
    data: XOR<ChallengeParticipantCreateInput, ChallengeParticipantUncheckedCreateInput>
  }

  /**
   * ChallengeParticipant createMany
   */
  export type ChallengeParticipantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChallengeParticipants.
     */
    data: ChallengeParticipantCreateManyInput | ChallengeParticipantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChallengeParticipant createManyAndReturn
   */
  export type ChallengeParticipantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeParticipant
     */
    select?: ChallengeParticipantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeParticipant
     */
    omit?: ChallengeParticipantOmit<ExtArgs> | null
    /**
     * The data used to create many ChallengeParticipants.
     */
    data: ChallengeParticipantCreateManyInput | ChallengeParticipantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeParticipantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChallengeParticipant update
   */
  export type ChallengeParticipantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeParticipant
     */
    select?: ChallengeParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeParticipant
     */
    omit?: ChallengeParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeParticipantInclude<ExtArgs> | null
    /**
     * The data needed to update a ChallengeParticipant.
     */
    data: XOR<ChallengeParticipantUpdateInput, ChallengeParticipantUncheckedUpdateInput>
    /**
     * Choose, which ChallengeParticipant to update.
     */
    where: ChallengeParticipantWhereUniqueInput
  }

  /**
   * ChallengeParticipant updateMany
   */
  export type ChallengeParticipantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChallengeParticipants.
     */
    data: XOR<ChallengeParticipantUpdateManyMutationInput, ChallengeParticipantUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeParticipants to update
     */
    where?: ChallengeParticipantWhereInput
    /**
     * Limit how many ChallengeParticipants to update.
     */
    limit?: number
  }

  /**
   * ChallengeParticipant updateManyAndReturn
   */
  export type ChallengeParticipantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeParticipant
     */
    select?: ChallengeParticipantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeParticipant
     */
    omit?: ChallengeParticipantOmit<ExtArgs> | null
    /**
     * The data used to update ChallengeParticipants.
     */
    data: XOR<ChallengeParticipantUpdateManyMutationInput, ChallengeParticipantUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeParticipants to update
     */
    where?: ChallengeParticipantWhereInput
    /**
     * Limit how many ChallengeParticipants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeParticipantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChallengeParticipant upsert
   */
  export type ChallengeParticipantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeParticipant
     */
    select?: ChallengeParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeParticipant
     */
    omit?: ChallengeParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeParticipantInclude<ExtArgs> | null
    /**
     * The filter to search for the ChallengeParticipant to update in case it exists.
     */
    where: ChallengeParticipantWhereUniqueInput
    /**
     * In case the ChallengeParticipant found by the `where` argument doesn't exist, create a new ChallengeParticipant with this data.
     */
    create: XOR<ChallengeParticipantCreateInput, ChallengeParticipantUncheckedCreateInput>
    /**
     * In case the ChallengeParticipant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChallengeParticipantUpdateInput, ChallengeParticipantUncheckedUpdateInput>
  }

  /**
   * ChallengeParticipant delete
   */
  export type ChallengeParticipantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeParticipant
     */
    select?: ChallengeParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeParticipant
     */
    omit?: ChallengeParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeParticipantInclude<ExtArgs> | null
    /**
     * Filter which ChallengeParticipant to delete.
     */
    where: ChallengeParticipantWhereUniqueInput
  }

  /**
   * ChallengeParticipant deleteMany
   */
  export type ChallengeParticipantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeParticipants to delete
     */
    where?: ChallengeParticipantWhereInput
    /**
     * Limit how many ChallengeParticipants to delete.
     */
    limit?: number
  }

  /**
   * ChallengeParticipant without action
   */
  export type ChallengeParticipantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeParticipant
     */
    select?: ChallengeParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeParticipant
     */
    omit?: ChallengeParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeParticipantInclude<ExtArgs> | null
  }


  /**
   * Model AIRecommendation
   */

  export type AggregateAIRecommendation = {
    _count: AIRecommendationCountAggregateOutputType | null
    _avg: AIRecommendationAvgAggregateOutputType | null
    _sum: AIRecommendationSumAggregateOutputType | null
    _min: AIRecommendationMinAggregateOutputType | null
    _max: AIRecommendationMaxAggregateOutputType | null
  }

  export type AIRecommendationAvgAggregateOutputType = {
    priority: number | null
    duration: number | null
    effectivenessScore: number | null
  }

  export type AIRecommendationSumAggregateOutputType = {
    priority: number | null
    duration: number | null
    effectivenessScore: number | null
  }

  export type AIRecommendationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    title: string | null
    description: string | null
    priority: number | null
    reasoning: string | null
    actionUrl: string | null
    duration: number | null
    intensity: string | null
    effectivenessScore: number | null
    isRead: boolean | null
    isCompleted: boolean | null
    createdAt: Date | null
    expiresAt: Date | null
    completedAt: Date | null
  }

  export type AIRecommendationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    title: string | null
    description: string | null
    priority: number | null
    reasoning: string | null
    actionUrl: string | null
    duration: number | null
    intensity: string | null
    effectivenessScore: number | null
    isRead: boolean | null
    isCompleted: boolean | null
    createdAt: Date | null
    expiresAt: Date | null
    completedAt: Date | null
  }

  export type AIRecommendationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    title: number
    description: number
    priority: number
    reasoning: number
    actionUrl: number
    duration: number
    intensity: number
    triggeredBy: number
    biometricState: number
    effectivenessScore: number
    isRead: number
    isCompleted: number
    createdAt: number
    expiresAt: number
    completedAt: number
    _all: number
  }


  export type AIRecommendationAvgAggregateInputType = {
    priority?: true
    duration?: true
    effectivenessScore?: true
  }

  export type AIRecommendationSumAggregateInputType = {
    priority?: true
    duration?: true
    effectivenessScore?: true
  }

  export type AIRecommendationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    description?: true
    priority?: true
    reasoning?: true
    actionUrl?: true
    duration?: true
    intensity?: true
    effectivenessScore?: true
    isRead?: true
    isCompleted?: true
    createdAt?: true
    expiresAt?: true
    completedAt?: true
  }

  export type AIRecommendationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    description?: true
    priority?: true
    reasoning?: true
    actionUrl?: true
    duration?: true
    intensity?: true
    effectivenessScore?: true
    isRead?: true
    isCompleted?: true
    createdAt?: true
    expiresAt?: true
    completedAt?: true
  }

  export type AIRecommendationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    description?: true
    priority?: true
    reasoning?: true
    actionUrl?: true
    duration?: true
    intensity?: true
    triggeredBy?: true
    biometricState?: true
    effectivenessScore?: true
    isRead?: true
    isCompleted?: true
    createdAt?: true
    expiresAt?: true
    completedAt?: true
    _all?: true
  }

  export type AIRecommendationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIRecommendation to aggregate.
     */
    where?: AIRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIRecommendations to fetch.
     */
    orderBy?: AIRecommendationOrderByWithRelationInput | AIRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIRecommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIRecommendations
    **/
    _count?: true | AIRecommendationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AIRecommendationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AIRecommendationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIRecommendationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIRecommendationMaxAggregateInputType
  }

  export type GetAIRecommendationAggregateType<T extends AIRecommendationAggregateArgs> = {
        [P in keyof T & keyof AggregateAIRecommendation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIRecommendation[P]>
      : GetScalarType<T[P], AggregateAIRecommendation[P]>
  }




  export type AIRecommendationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIRecommendationWhereInput
    orderBy?: AIRecommendationOrderByWithAggregationInput | AIRecommendationOrderByWithAggregationInput[]
    by: AIRecommendationScalarFieldEnum[] | AIRecommendationScalarFieldEnum
    having?: AIRecommendationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIRecommendationCountAggregateInputType | true
    _avg?: AIRecommendationAvgAggregateInputType
    _sum?: AIRecommendationSumAggregateInputType
    _min?: AIRecommendationMinAggregateInputType
    _max?: AIRecommendationMaxAggregateInputType
  }

  export type AIRecommendationGroupByOutputType = {
    id: string
    userId: string
    type: string
    title: string
    description: string
    priority: number
    reasoning: string
    actionUrl: string | null
    duration: number | null
    intensity: string | null
    triggeredBy: JsonValue | null
    biometricState: JsonValue | null
    effectivenessScore: number | null
    isRead: boolean
    isCompleted: boolean
    createdAt: Date
    expiresAt: Date | null
    completedAt: Date | null
    _count: AIRecommendationCountAggregateOutputType | null
    _avg: AIRecommendationAvgAggregateOutputType | null
    _sum: AIRecommendationSumAggregateOutputType | null
    _min: AIRecommendationMinAggregateOutputType | null
    _max: AIRecommendationMaxAggregateOutputType | null
  }

  type GetAIRecommendationGroupByPayload<T extends AIRecommendationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIRecommendationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIRecommendationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIRecommendationGroupByOutputType[P]>
            : GetScalarType<T[P], AIRecommendationGroupByOutputType[P]>
        }
      >
    >


  export type AIRecommendationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    priority?: boolean
    reasoning?: boolean
    actionUrl?: boolean
    duration?: boolean
    intensity?: boolean
    triggeredBy?: boolean
    biometricState?: boolean
    effectivenessScore?: boolean
    isRead?: boolean
    isCompleted?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    completedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIRecommendation"]>

  export type AIRecommendationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    priority?: boolean
    reasoning?: boolean
    actionUrl?: boolean
    duration?: boolean
    intensity?: boolean
    triggeredBy?: boolean
    biometricState?: boolean
    effectivenessScore?: boolean
    isRead?: boolean
    isCompleted?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    completedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIRecommendation"]>

  export type AIRecommendationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    priority?: boolean
    reasoning?: boolean
    actionUrl?: boolean
    duration?: boolean
    intensity?: boolean
    triggeredBy?: boolean
    biometricState?: boolean
    effectivenessScore?: boolean
    isRead?: boolean
    isCompleted?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    completedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIRecommendation"]>

  export type AIRecommendationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    priority?: boolean
    reasoning?: boolean
    actionUrl?: boolean
    duration?: boolean
    intensity?: boolean
    triggeredBy?: boolean
    biometricState?: boolean
    effectivenessScore?: boolean
    isRead?: boolean
    isCompleted?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    completedAt?: boolean
  }

  export type AIRecommendationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "title" | "description" | "priority" | "reasoning" | "actionUrl" | "duration" | "intensity" | "triggeredBy" | "biometricState" | "effectivenessScore" | "isRead" | "isCompleted" | "createdAt" | "expiresAt" | "completedAt", ExtArgs["result"]["aIRecommendation"]>
  export type AIRecommendationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AIRecommendationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AIRecommendationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AIRecommendationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIRecommendation"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      title: string
      description: string
      priority: number
      reasoning: string
      actionUrl: string | null
      duration: number | null
      intensity: string | null
      triggeredBy: Prisma.JsonValue | null
      biometricState: Prisma.JsonValue | null
      effectivenessScore: number | null
      isRead: boolean
      isCompleted: boolean
      createdAt: Date
      expiresAt: Date | null
      completedAt: Date | null
    }, ExtArgs["result"]["aIRecommendation"]>
    composites: {}
  }

  type AIRecommendationGetPayload<S extends boolean | null | undefined | AIRecommendationDefaultArgs> = $Result.GetResult<Prisma.$AIRecommendationPayload, S>

  type AIRecommendationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIRecommendationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AIRecommendationCountAggregateInputType | true
    }

  export interface AIRecommendationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIRecommendation'], meta: { name: 'AIRecommendation' } }
    /**
     * Find zero or one AIRecommendation that matches the filter.
     * @param {AIRecommendationFindUniqueArgs} args - Arguments to find a AIRecommendation
     * @example
     * // Get one AIRecommendation
     * const aIRecommendation = await prisma.aIRecommendation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIRecommendationFindUniqueArgs>(args: SelectSubset<T, AIRecommendationFindUniqueArgs<ExtArgs>>): Prisma__AIRecommendationClient<$Result.GetResult<Prisma.$AIRecommendationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AIRecommendation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIRecommendationFindUniqueOrThrowArgs} args - Arguments to find a AIRecommendation
     * @example
     * // Get one AIRecommendation
     * const aIRecommendation = await prisma.aIRecommendation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIRecommendationFindUniqueOrThrowArgs>(args: SelectSubset<T, AIRecommendationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIRecommendationClient<$Result.GetResult<Prisma.$AIRecommendationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIRecommendation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIRecommendationFindFirstArgs} args - Arguments to find a AIRecommendation
     * @example
     * // Get one AIRecommendation
     * const aIRecommendation = await prisma.aIRecommendation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIRecommendationFindFirstArgs>(args?: SelectSubset<T, AIRecommendationFindFirstArgs<ExtArgs>>): Prisma__AIRecommendationClient<$Result.GetResult<Prisma.$AIRecommendationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIRecommendation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIRecommendationFindFirstOrThrowArgs} args - Arguments to find a AIRecommendation
     * @example
     * // Get one AIRecommendation
     * const aIRecommendation = await prisma.aIRecommendation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIRecommendationFindFirstOrThrowArgs>(args?: SelectSubset<T, AIRecommendationFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIRecommendationClient<$Result.GetResult<Prisma.$AIRecommendationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AIRecommendations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIRecommendationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIRecommendations
     * const aIRecommendations = await prisma.aIRecommendation.findMany()
     * 
     * // Get first 10 AIRecommendations
     * const aIRecommendations = await prisma.aIRecommendation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIRecommendationWithIdOnly = await prisma.aIRecommendation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIRecommendationFindManyArgs>(args?: SelectSubset<T, AIRecommendationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIRecommendationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AIRecommendation.
     * @param {AIRecommendationCreateArgs} args - Arguments to create a AIRecommendation.
     * @example
     * // Create one AIRecommendation
     * const AIRecommendation = await prisma.aIRecommendation.create({
     *   data: {
     *     // ... data to create a AIRecommendation
     *   }
     * })
     * 
     */
    create<T extends AIRecommendationCreateArgs>(args: SelectSubset<T, AIRecommendationCreateArgs<ExtArgs>>): Prisma__AIRecommendationClient<$Result.GetResult<Prisma.$AIRecommendationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AIRecommendations.
     * @param {AIRecommendationCreateManyArgs} args - Arguments to create many AIRecommendations.
     * @example
     * // Create many AIRecommendations
     * const aIRecommendation = await prisma.aIRecommendation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIRecommendationCreateManyArgs>(args?: SelectSubset<T, AIRecommendationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIRecommendations and returns the data saved in the database.
     * @param {AIRecommendationCreateManyAndReturnArgs} args - Arguments to create many AIRecommendations.
     * @example
     * // Create many AIRecommendations
     * const aIRecommendation = await prisma.aIRecommendation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIRecommendations and only return the `id`
     * const aIRecommendationWithIdOnly = await prisma.aIRecommendation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIRecommendationCreateManyAndReturnArgs>(args?: SelectSubset<T, AIRecommendationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIRecommendationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AIRecommendation.
     * @param {AIRecommendationDeleteArgs} args - Arguments to delete one AIRecommendation.
     * @example
     * // Delete one AIRecommendation
     * const AIRecommendation = await prisma.aIRecommendation.delete({
     *   where: {
     *     // ... filter to delete one AIRecommendation
     *   }
     * })
     * 
     */
    delete<T extends AIRecommendationDeleteArgs>(args: SelectSubset<T, AIRecommendationDeleteArgs<ExtArgs>>): Prisma__AIRecommendationClient<$Result.GetResult<Prisma.$AIRecommendationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AIRecommendation.
     * @param {AIRecommendationUpdateArgs} args - Arguments to update one AIRecommendation.
     * @example
     * // Update one AIRecommendation
     * const aIRecommendation = await prisma.aIRecommendation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIRecommendationUpdateArgs>(args: SelectSubset<T, AIRecommendationUpdateArgs<ExtArgs>>): Prisma__AIRecommendationClient<$Result.GetResult<Prisma.$AIRecommendationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AIRecommendations.
     * @param {AIRecommendationDeleteManyArgs} args - Arguments to filter AIRecommendations to delete.
     * @example
     * // Delete a few AIRecommendations
     * const { count } = await prisma.aIRecommendation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIRecommendationDeleteManyArgs>(args?: SelectSubset<T, AIRecommendationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIRecommendations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIRecommendationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIRecommendations
     * const aIRecommendation = await prisma.aIRecommendation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIRecommendationUpdateManyArgs>(args: SelectSubset<T, AIRecommendationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIRecommendations and returns the data updated in the database.
     * @param {AIRecommendationUpdateManyAndReturnArgs} args - Arguments to update many AIRecommendations.
     * @example
     * // Update many AIRecommendations
     * const aIRecommendation = await prisma.aIRecommendation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AIRecommendations and only return the `id`
     * const aIRecommendationWithIdOnly = await prisma.aIRecommendation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AIRecommendationUpdateManyAndReturnArgs>(args: SelectSubset<T, AIRecommendationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIRecommendationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AIRecommendation.
     * @param {AIRecommendationUpsertArgs} args - Arguments to update or create a AIRecommendation.
     * @example
     * // Update or create a AIRecommendation
     * const aIRecommendation = await prisma.aIRecommendation.upsert({
     *   create: {
     *     // ... data to create a AIRecommendation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIRecommendation we want to update
     *   }
     * })
     */
    upsert<T extends AIRecommendationUpsertArgs>(args: SelectSubset<T, AIRecommendationUpsertArgs<ExtArgs>>): Prisma__AIRecommendationClient<$Result.GetResult<Prisma.$AIRecommendationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AIRecommendations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIRecommendationCountArgs} args - Arguments to filter AIRecommendations to count.
     * @example
     * // Count the number of AIRecommendations
     * const count = await prisma.aIRecommendation.count({
     *   where: {
     *     // ... the filter for the AIRecommendations we want to count
     *   }
     * })
    **/
    count<T extends AIRecommendationCountArgs>(
      args?: Subset<T, AIRecommendationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIRecommendationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIRecommendation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIRecommendationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIRecommendationAggregateArgs>(args: Subset<T, AIRecommendationAggregateArgs>): Prisma.PrismaPromise<GetAIRecommendationAggregateType<T>>

    /**
     * Group by AIRecommendation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIRecommendationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIRecommendationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIRecommendationGroupByArgs['orderBy'] }
        : { orderBy?: AIRecommendationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIRecommendationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIRecommendationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIRecommendation model
   */
  readonly fields: AIRecommendationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIRecommendation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIRecommendationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIRecommendation model
   */
  interface AIRecommendationFieldRefs {
    readonly id: FieldRef<"AIRecommendation", 'String'>
    readonly userId: FieldRef<"AIRecommendation", 'String'>
    readonly type: FieldRef<"AIRecommendation", 'String'>
    readonly title: FieldRef<"AIRecommendation", 'String'>
    readonly description: FieldRef<"AIRecommendation", 'String'>
    readonly priority: FieldRef<"AIRecommendation", 'Int'>
    readonly reasoning: FieldRef<"AIRecommendation", 'String'>
    readonly actionUrl: FieldRef<"AIRecommendation", 'String'>
    readonly duration: FieldRef<"AIRecommendation", 'Int'>
    readonly intensity: FieldRef<"AIRecommendation", 'String'>
    readonly triggeredBy: FieldRef<"AIRecommendation", 'Json'>
    readonly biometricState: FieldRef<"AIRecommendation", 'Json'>
    readonly effectivenessScore: FieldRef<"AIRecommendation", 'Float'>
    readonly isRead: FieldRef<"AIRecommendation", 'Boolean'>
    readonly isCompleted: FieldRef<"AIRecommendation", 'Boolean'>
    readonly createdAt: FieldRef<"AIRecommendation", 'DateTime'>
    readonly expiresAt: FieldRef<"AIRecommendation", 'DateTime'>
    readonly completedAt: FieldRef<"AIRecommendation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AIRecommendation findUnique
   */
  export type AIRecommendationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRecommendation
     */
    select?: AIRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRecommendation
     */
    omit?: AIRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which AIRecommendation to fetch.
     */
    where: AIRecommendationWhereUniqueInput
  }

  /**
   * AIRecommendation findUniqueOrThrow
   */
  export type AIRecommendationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRecommendation
     */
    select?: AIRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRecommendation
     */
    omit?: AIRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which AIRecommendation to fetch.
     */
    where: AIRecommendationWhereUniqueInput
  }

  /**
   * AIRecommendation findFirst
   */
  export type AIRecommendationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRecommendation
     */
    select?: AIRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRecommendation
     */
    omit?: AIRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which AIRecommendation to fetch.
     */
    where?: AIRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIRecommendations to fetch.
     */
    orderBy?: AIRecommendationOrderByWithRelationInput | AIRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIRecommendations.
     */
    cursor?: AIRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIRecommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIRecommendations.
     */
    distinct?: AIRecommendationScalarFieldEnum | AIRecommendationScalarFieldEnum[]
  }

  /**
   * AIRecommendation findFirstOrThrow
   */
  export type AIRecommendationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRecommendation
     */
    select?: AIRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRecommendation
     */
    omit?: AIRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which AIRecommendation to fetch.
     */
    where?: AIRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIRecommendations to fetch.
     */
    orderBy?: AIRecommendationOrderByWithRelationInput | AIRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIRecommendations.
     */
    cursor?: AIRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIRecommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIRecommendations.
     */
    distinct?: AIRecommendationScalarFieldEnum | AIRecommendationScalarFieldEnum[]
  }

  /**
   * AIRecommendation findMany
   */
  export type AIRecommendationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRecommendation
     */
    select?: AIRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRecommendation
     */
    omit?: AIRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which AIRecommendations to fetch.
     */
    where?: AIRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIRecommendations to fetch.
     */
    orderBy?: AIRecommendationOrderByWithRelationInput | AIRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIRecommendations.
     */
    cursor?: AIRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIRecommendations.
     */
    skip?: number
    distinct?: AIRecommendationScalarFieldEnum | AIRecommendationScalarFieldEnum[]
  }

  /**
   * AIRecommendation create
   */
  export type AIRecommendationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRecommendation
     */
    select?: AIRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRecommendation
     */
    omit?: AIRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRecommendationInclude<ExtArgs> | null
    /**
     * The data needed to create a AIRecommendation.
     */
    data: XOR<AIRecommendationCreateInput, AIRecommendationUncheckedCreateInput>
  }

  /**
   * AIRecommendation createMany
   */
  export type AIRecommendationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIRecommendations.
     */
    data: AIRecommendationCreateManyInput | AIRecommendationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIRecommendation createManyAndReturn
   */
  export type AIRecommendationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRecommendation
     */
    select?: AIRecommendationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIRecommendation
     */
    omit?: AIRecommendationOmit<ExtArgs> | null
    /**
     * The data used to create many AIRecommendations.
     */
    data: AIRecommendationCreateManyInput | AIRecommendationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRecommendationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIRecommendation update
   */
  export type AIRecommendationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRecommendation
     */
    select?: AIRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRecommendation
     */
    omit?: AIRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRecommendationInclude<ExtArgs> | null
    /**
     * The data needed to update a AIRecommendation.
     */
    data: XOR<AIRecommendationUpdateInput, AIRecommendationUncheckedUpdateInput>
    /**
     * Choose, which AIRecommendation to update.
     */
    where: AIRecommendationWhereUniqueInput
  }

  /**
   * AIRecommendation updateMany
   */
  export type AIRecommendationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIRecommendations.
     */
    data: XOR<AIRecommendationUpdateManyMutationInput, AIRecommendationUncheckedUpdateManyInput>
    /**
     * Filter which AIRecommendations to update
     */
    where?: AIRecommendationWhereInput
    /**
     * Limit how many AIRecommendations to update.
     */
    limit?: number
  }

  /**
   * AIRecommendation updateManyAndReturn
   */
  export type AIRecommendationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRecommendation
     */
    select?: AIRecommendationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIRecommendation
     */
    omit?: AIRecommendationOmit<ExtArgs> | null
    /**
     * The data used to update AIRecommendations.
     */
    data: XOR<AIRecommendationUpdateManyMutationInput, AIRecommendationUncheckedUpdateManyInput>
    /**
     * Filter which AIRecommendations to update
     */
    where?: AIRecommendationWhereInput
    /**
     * Limit how many AIRecommendations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRecommendationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIRecommendation upsert
   */
  export type AIRecommendationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRecommendation
     */
    select?: AIRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRecommendation
     */
    omit?: AIRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRecommendationInclude<ExtArgs> | null
    /**
     * The filter to search for the AIRecommendation to update in case it exists.
     */
    where: AIRecommendationWhereUniqueInput
    /**
     * In case the AIRecommendation found by the `where` argument doesn't exist, create a new AIRecommendation with this data.
     */
    create: XOR<AIRecommendationCreateInput, AIRecommendationUncheckedCreateInput>
    /**
     * In case the AIRecommendation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIRecommendationUpdateInput, AIRecommendationUncheckedUpdateInput>
  }

  /**
   * AIRecommendation delete
   */
  export type AIRecommendationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRecommendation
     */
    select?: AIRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRecommendation
     */
    omit?: AIRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRecommendationInclude<ExtArgs> | null
    /**
     * Filter which AIRecommendation to delete.
     */
    where: AIRecommendationWhereUniqueInput
  }

  /**
   * AIRecommendation deleteMany
   */
  export type AIRecommendationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIRecommendations to delete
     */
    where?: AIRecommendationWhereInput
    /**
     * Limit how many AIRecommendations to delete.
     */
    limit?: number
  }

  /**
   * AIRecommendation without action
   */
  export type AIRecommendationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRecommendation
     */
    select?: AIRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRecommendation
     */
    omit?: AIRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRecommendationInclude<ExtArgs> | null
  }


  /**
   * Model DeviceConnection
   */

  export type AggregateDeviceConnection = {
    _count: DeviceConnectionCountAggregateOutputType | null
    _avg: DeviceConnectionAvgAggregateOutputType | null
    _sum: DeviceConnectionSumAggregateOutputType | null
    _min: DeviceConnectionMinAggregateOutputType | null
    _max: DeviceConnectionMaxAggregateOutputType | null
  }

  export type DeviceConnectionAvgAggregateOutputType = {
    syncInterval: number | null
    reliability: number | null
    batteryLevel: number | null
    signalStrength: number | null
  }

  export type DeviceConnectionSumAggregateOutputType = {
    syncInterval: number | null
    reliability: number | null
    batteryLevel: number | null
    signalStrength: number | null
  }

  export type DeviceConnectionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    deviceType: string | null
    deviceId: string | null
    deviceName: string | null
    isConnected: boolean | null
    lastSync: Date | null
    syncInterval: number | null
    reliability: number | null
    batteryLevel: number | null
    signalStrength: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeviceConnectionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    deviceType: string | null
    deviceId: string | null
    deviceName: string | null
    isConnected: boolean | null
    lastSync: Date | null
    syncInterval: number | null
    reliability: number | null
    batteryLevel: number | null
    signalStrength: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeviceConnectionCountAggregateOutputType = {
    id: number
    userId: number
    deviceType: number
    deviceId: number
    deviceName: number
    isConnected: number
    lastSync: number
    syncInterval: number
    reliability: number
    batteryLevel: number
    signalStrength: number
    permissions: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DeviceConnectionAvgAggregateInputType = {
    syncInterval?: true
    reliability?: true
    batteryLevel?: true
    signalStrength?: true
  }

  export type DeviceConnectionSumAggregateInputType = {
    syncInterval?: true
    reliability?: true
    batteryLevel?: true
    signalStrength?: true
  }

  export type DeviceConnectionMinAggregateInputType = {
    id?: true
    userId?: true
    deviceType?: true
    deviceId?: true
    deviceName?: true
    isConnected?: true
    lastSync?: true
    syncInterval?: true
    reliability?: true
    batteryLevel?: true
    signalStrength?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeviceConnectionMaxAggregateInputType = {
    id?: true
    userId?: true
    deviceType?: true
    deviceId?: true
    deviceName?: true
    isConnected?: true
    lastSync?: true
    syncInterval?: true
    reliability?: true
    batteryLevel?: true
    signalStrength?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeviceConnectionCountAggregateInputType = {
    id?: true
    userId?: true
    deviceType?: true
    deviceId?: true
    deviceName?: true
    isConnected?: true
    lastSync?: true
    syncInterval?: true
    reliability?: true
    batteryLevel?: true
    signalStrength?: true
    permissions?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DeviceConnectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceConnection to aggregate.
     */
    where?: DeviceConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceConnections to fetch.
     */
    orderBy?: DeviceConnectionOrderByWithRelationInput | DeviceConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceConnections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceConnections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeviceConnections
    **/
    _count?: true | DeviceConnectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeviceConnectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeviceConnectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceConnectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceConnectionMaxAggregateInputType
  }

  export type GetDeviceConnectionAggregateType<T extends DeviceConnectionAggregateArgs> = {
        [P in keyof T & keyof AggregateDeviceConnection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeviceConnection[P]>
      : GetScalarType<T[P], AggregateDeviceConnection[P]>
  }




  export type DeviceConnectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceConnectionWhereInput
    orderBy?: DeviceConnectionOrderByWithAggregationInput | DeviceConnectionOrderByWithAggregationInput[]
    by: DeviceConnectionScalarFieldEnum[] | DeviceConnectionScalarFieldEnum
    having?: DeviceConnectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceConnectionCountAggregateInputType | true
    _avg?: DeviceConnectionAvgAggregateInputType
    _sum?: DeviceConnectionSumAggregateInputType
    _min?: DeviceConnectionMinAggregateInputType
    _max?: DeviceConnectionMaxAggregateInputType
  }

  export type DeviceConnectionGroupByOutputType = {
    id: string
    userId: string
    deviceType: string
    deviceId: string
    deviceName: string | null
    isConnected: boolean
    lastSync: Date | null
    syncInterval: number | null
    reliability: number | null
    batteryLevel: number | null
    signalStrength: number | null
    permissions: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: DeviceConnectionCountAggregateOutputType | null
    _avg: DeviceConnectionAvgAggregateOutputType | null
    _sum: DeviceConnectionSumAggregateOutputType | null
    _min: DeviceConnectionMinAggregateOutputType | null
    _max: DeviceConnectionMaxAggregateOutputType | null
  }

  type GetDeviceConnectionGroupByPayload<T extends DeviceConnectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceConnectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceConnectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceConnectionGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceConnectionGroupByOutputType[P]>
        }
      >
    >


  export type DeviceConnectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    deviceType?: boolean
    deviceId?: boolean
    deviceName?: boolean
    isConnected?: boolean
    lastSync?: boolean
    syncInterval?: boolean
    reliability?: boolean
    batteryLevel?: boolean
    signalStrength?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceConnection"]>

  export type DeviceConnectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    deviceType?: boolean
    deviceId?: boolean
    deviceName?: boolean
    isConnected?: boolean
    lastSync?: boolean
    syncInterval?: boolean
    reliability?: boolean
    batteryLevel?: boolean
    signalStrength?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceConnection"]>

  export type DeviceConnectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    deviceType?: boolean
    deviceId?: boolean
    deviceName?: boolean
    isConnected?: boolean
    lastSync?: boolean
    syncInterval?: boolean
    reliability?: boolean
    batteryLevel?: boolean
    signalStrength?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceConnection"]>

  export type DeviceConnectionSelectScalar = {
    id?: boolean
    userId?: boolean
    deviceType?: boolean
    deviceId?: boolean
    deviceName?: boolean
    isConnected?: boolean
    lastSync?: boolean
    syncInterval?: boolean
    reliability?: boolean
    batteryLevel?: boolean
    signalStrength?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DeviceConnectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "deviceType" | "deviceId" | "deviceName" | "isConnected" | "lastSync" | "syncInterval" | "reliability" | "batteryLevel" | "signalStrength" | "permissions" | "createdAt" | "updatedAt", ExtArgs["result"]["deviceConnection"]>
  export type DeviceConnectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DeviceConnectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DeviceConnectionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DeviceConnectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeviceConnection"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      deviceType: string
      deviceId: string
      deviceName: string | null
      isConnected: boolean
      lastSync: Date | null
      syncInterval: number | null
      reliability: number | null
      batteryLevel: number | null
      signalStrength: number | null
      permissions: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["deviceConnection"]>
    composites: {}
  }

  type DeviceConnectionGetPayload<S extends boolean | null | undefined | DeviceConnectionDefaultArgs> = $Result.GetResult<Prisma.$DeviceConnectionPayload, S>

  type DeviceConnectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeviceConnectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeviceConnectionCountAggregateInputType | true
    }

  export interface DeviceConnectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeviceConnection'], meta: { name: 'DeviceConnection' } }
    /**
     * Find zero or one DeviceConnection that matches the filter.
     * @param {DeviceConnectionFindUniqueArgs} args - Arguments to find a DeviceConnection
     * @example
     * // Get one DeviceConnection
     * const deviceConnection = await prisma.deviceConnection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceConnectionFindUniqueArgs>(args: SelectSubset<T, DeviceConnectionFindUniqueArgs<ExtArgs>>): Prisma__DeviceConnectionClient<$Result.GetResult<Prisma.$DeviceConnectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeviceConnection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeviceConnectionFindUniqueOrThrowArgs} args - Arguments to find a DeviceConnection
     * @example
     * // Get one DeviceConnection
     * const deviceConnection = await prisma.deviceConnection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceConnectionFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceConnectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceConnectionClient<$Result.GetResult<Prisma.$DeviceConnectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceConnection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceConnectionFindFirstArgs} args - Arguments to find a DeviceConnection
     * @example
     * // Get one DeviceConnection
     * const deviceConnection = await prisma.deviceConnection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceConnectionFindFirstArgs>(args?: SelectSubset<T, DeviceConnectionFindFirstArgs<ExtArgs>>): Prisma__DeviceConnectionClient<$Result.GetResult<Prisma.$DeviceConnectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceConnection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceConnectionFindFirstOrThrowArgs} args - Arguments to find a DeviceConnection
     * @example
     * // Get one DeviceConnection
     * const deviceConnection = await prisma.deviceConnection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceConnectionFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceConnectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceConnectionClient<$Result.GetResult<Prisma.$DeviceConnectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeviceConnections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceConnectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeviceConnections
     * const deviceConnections = await prisma.deviceConnection.findMany()
     * 
     * // Get first 10 DeviceConnections
     * const deviceConnections = await prisma.deviceConnection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceConnectionWithIdOnly = await prisma.deviceConnection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeviceConnectionFindManyArgs>(args?: SelectSubset<T, DeviceConnectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceConnectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeviceConnection.
     * @param {DeviceConnectionCreateArgs} args - Arguments to create a DeviceConnection.
     * @example
     * // Create one DeviceConnection
     * const DeviceConnection = await prisma.deviceConnection.create({
     *   data: {
     *     // ... data to create a DeviceConnection
     *   }
     * })
     * 
     */
    create<T extends DeviceConnectionCreateArgs>(args: SelectSubset<T, DeviceConnectionCreateArgs<ExtArgs>>): Prisma__DeviceConnectionClient<$Result.GetResult<Prisma.$DeviceConnectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeviceConnections.
     * @param {DeviceConnectionCreateManyArgs} args - Arguments to create many DeviceConnections.
     * @example
     * // Create many DeviceConnections
     * const deviceConnection = await prisma.deviceConnection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceConnectionCreateManyArgs>(args?: SelectSubset<T, DeviceConnectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeviceConnections and returns the data saved in the database.
     * @param {DeviceConnectionCreateManyAndReturnArgs} args - Arguments to create many DeviceConnections.
     * @example
     * // Create many DeviceConnections
     * const deviceConnection = await prisma.deviceConnection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeviceConnections and only return the `id`
     * const deviceConnectionWithIdOnly = await prisma.deviceConnection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeviceConnectionCreateManyAndReturnArgs>(args?: SelectSubset<T, DeviceConnectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceConnectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeviceConnection.
     * @param {DeviceConnectionDeleteArgs} args - Arguments to delete one DeviceConnection.
     * @example
     * // Delete one DeviceConnection
     * const DeviceConnection = await prisma.deviceConnection.delete({
     *   where: {
     *     // ... filter to delete one DeviceConnection
     *   }
     * })
     * 
     */
    delete<T extends DeviceConnectionDeleteArgs>(args: SelectSubset<T, DeviceConnectionDeleteArgs<ExtArgs>>): Prisma__DeviceConnectionClient<$Result.GetResult<Prisma.$DeviceConnectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeviceConnection.
     * @param {DeviceConnectionUpdateArgs} args - Arguments to update one DeviceConnection.
     * @example
     * // Update one DeviceConnection
     * const deviceConnection = await prisma.deviceConnection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceConnectionUpdateArgs>(args: SelectSubset<T, DeviceConnectionUpdateArgs<ExtArgs>>): Prisma__DeviceConnectionClient<$Result.GetResult<Prisma.$DeviceConnectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeviceConnections.
     * @param {DeviceConnectionDeleteManyArgs} args - Arguments to filter DeviceConnections to delete.
     * @example
     * // Delete a few DeviceConnections
     * const { count } = await prisma.deviceConnection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceConnectionDeleteManyArgs>(args?: SelectSubset<T, DeviceConnectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceConnections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceConnectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeviceConnections
     * const deviceConnection = await prisma.deviceConnection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceConnectionUpdateManyArgs>(args: SelectSubset<T, DeviceConnectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceConnections and returns the data updated in the database.
     * @param {DeviceConnectionUpdateManyAndReturnArgs} args - Arguments to update many DeviceConnections.
     * @example
     * // Update many DeviceConnections
     * const deviceConnection = await prisma.deviceConnection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeviceConnections and only return the `id`
     * const deviceConnectionWithIdOnly = await prisma.deviceConnection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeviceConnectionUpdateManyAndReturnArgs>(args: SelectSubset<T, DeviceConnectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceConnectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeviceConnection.
     * @param {DeviceConnectionUpsertArgs} args - Arguments to update or create a DeviceConnection.
     * @example
     * // Update or create a DeviceConnection
     * const deviceConnection = await prisma.deviceConnection.upsert({
     *   create: {
     *     // ... data to create a DeviceConnection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeviceConnection we want to update
     *   }
     * })
     */
    upsert<T extends DeviceConnectionUpsertArgs>(args: SelectSubset<T, DeviceConnectionUpsertArgs<ExtArgs>>): Prisma__DeviceConnectionClient<$Result.GetResult<Prisma.$DeviceConnectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeviceConnections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceConnectionCountArgs} args - Arguments to filter DeviceConnections to count.
     * @example
     * // Count the number of DeviceConnections
     * const count = await prisma.deviceConnection.count({
     *   where: {
     *     // ... the filter for the DeviceConnections we want to count
     *   }
     * })
    **/
    count<T extends DeviceConnectionCountArgs>(
      args?: Subset<T, DeviceConnectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceConnectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeviceConnection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceConnectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceConnectionAggregateArgs>(args: Subset<T, DeviceConnectionAggregateArgs>): Prisma.PrismaPromise<GetDeviceConnectionAggregateType<T>>

    /**
     * Group by DeviceConnection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceConnectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceConnectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceConnectionGroupByArgs['orderBy'] }
        : { orderBy?: DeviceConnectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceConnectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceConnectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeviceConnection model
   */
  readonly fields: DeviceConnectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeviceConnection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceConnectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeviceConnection model
   */
  interface DeviceConnectionFieldRefs {
    readonly id: FieldRef<"DeviceConnection", 'String'>
    readonly userId: FieldRef<"DeviceConnection", 'String'>
    readonly deviceType: FieldRef<"DeviceConnection", 'String'>
    readonly deviceId: FieldRef<"DeviceConnection", 'String'>
    readonly deviceName: FieldRef<"DeviceConnection", 'String'>
    readonly isConnected: FieldRef<"DeviceConnection", 'Boolean'>
    readonly lastSync: FieldRef<"DeviceConnection", 'DateTime'>
    readonly syncInterval: FieldRef<"DeviceConnection", 'Int'>
    readonly reliability: FieldRef<"DeviceConnection", 'Float'>
    readonly batteryLevel: FieldRef<"DeviceConnection", 'Int'>
    readonly signalStrength: FieldRef<"DeviceConnection", 'Float'>
    readonly permissions: FieldRef<"DeviceConnection", 'Json'>
    readonly createdAt: FieldRef<"DeviceConnection", 'DateTime'>
    readonly updatedAt: FieldRef<"DeviceConnection", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DeviceConnection findUnique
   */
  export type DeviceConnectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceConnection
     */
    select?: DeviceConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceConnection
     */
    omit?: DeviceConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceConnectionInclude<ExtArgs> | null
    /**
     * Filter, which DeviceConnection to fetch.
     */
    where: DeviceConnectionWhereUniqueInput
  }

  /**
   * DeviceConnection findUniqueOrThrow
   */
  export type DeviceConnectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceConnection
     */
    select?: DeviceConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceConnection
     */
    omit?: DeviceConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceConnectionInclude<ExtArgs> | null
    /**
     * Filter, which DeviceConnection to fetch.
     */
    where: DeviceConnectionWhereUniqueInput
  }

  /**
   * DeviceConnection findFirst
   */
  export type DeviceConnectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceConnection
     */
    select?: DeviceConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceConnection
     */
    omit?: DeviceConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceConnectionInclude<ExtArgs> | null
    /**
     * Filter, which DeviceConnection to fetch.
     */
    where?: DeviceConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceConnections to fetch.
     */
    orderBy?: DeviceConnectionOrderByWithRelationInput | DeviceConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceConnections.
     */
    cursor?: DeviceConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceConnections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceConnections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceConnections.
     */
    distinct?: DeviceConnectionScalarFieldEnum | DeviceConnectionScalarFieldEnum[]
  }

  /**
   * DeviceConnection findFirstOrThrow
   */
  export type DeviceConnectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceConnection
     */
    select?: DeviceConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceConnection
     */
    omit?: DeviceConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceConnectionInclude<ExtArgs> | null
    /**
     * Filter, which DeviceConnection to fetch.
     */
    where?: DeviceConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceConnections to fetch.
     */
    orderBy?: DeviceConnectionOrderByWithRelationInput | DeviceConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceConnections.
     */
    cursor?: DeviceConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceConnections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceConnections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceConnections.
     */
    distinct?: DeviceConnectionScalarFieldEnum | DeviceConnectionScalarFieldEnum[]
  }

  /**
   * DeviceConnection findMany
   */
  export type DeviceConnectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceConnection
     */
    select?: DeviceConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceConnection
     */
    omit?: DeviceConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceConnectionInclude<ExtArgs> | null
    /**
     * Filter, which DeviceConnections to fetch.
     */
    where?: DeviceConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceConnections to fetch.
     */
    orderBy?: DeviceConnectionOrderByWithRelationInput | DeviceConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeviceConnections.
     */
    cursor?: DeviceConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceConnections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceConnections.
     */
    skip?: number
    distinct?: DeviceConnectionScalarFieldEnum | DeviceConnectionScalarFieldEnum[]
  }

  /**
   * DeviceConnection create
   */
  export type DeviceConnectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceConnection
     */
    select?: DeviceConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceConnection
     */
    omit?: DeviceConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceConnectionInclude<ExtArgs> | null
    /**
     * The data needed to create a DeviceConnection.
     */
    data: XOR<DeviceConnectionCreateInput, DeviceConnectionUncheckedCreateInput>
  }

  /**
   * DeviceConnection createMany
   */
  export type DeviceConnectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeviceConnections.
     */
    data: DeviceConnectionCreateManyInput | DeviceConnectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeviceConnection createManyAndReturn
   */
  export type DeviceConnectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceConnection
     */
    select?: DeviceConnectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceConnection
     */
    omit?: DeviceConnectionOmit<ExtArgs> | null
    /**
     * The data used to create many DeviceConnections.
     */
    data: DeviceConnectionCreateManyInput | DeviceConnectionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceConnectionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeviceConnection update
   */
  export type DeviceConnectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceConnection
     */
    select?: DeviceConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceConnection
     */
    omit?: DeviceConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceConnectionInclude<ExtArgs> | null
    /**
     * The data needed to update a DeviceConnection.
     */
    data: XOR<DeviceConnectionUpdateInput, DeviceConnectionUncheckedUpdateInput>
    /**
     * Choose, which DeviceConnection to update.
     */
    where: DeviceConnectionWhereUniqueInput
  }

  /**
   * DeviceConnection updateMany
   */
  export type DeviceConnectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeviceConnections.
     */
    data: XOR<DeviceConnectionUpdateManyMutationInput, DeviceConnectionUncheckedUpdateManyInput>
    /**
     * Filter which DeviceConnections to update
     */
    where?: DeviceConnectionWhereInput
    /**
     * Limit how many DeviceConnections to update.
     */
    limit?: number
  }

  /**
   * DeviceConnection updateManyAndReturn
   */
  export type DeviceConnectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceConnection
     */
    select?: DeviceConnectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceConnection
     */
    omit?: DeviceConnectionOmit<ExtArgs> | null
    /**
     * The data used to update DeviceConnections.
     */
    data: XOR<DeviceConnectionUpdateManyMutationInput, DeviceConnectionUncheckedUpdateManyInput>
    /**
     * Filter which DeviceConnections to update
     */
    where?: DeviceConnectionWhereInput
    /**
     * Limit how many DeviceConnections to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceConnectionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeviceConnection upsert
   */
  export type DeviceConnectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceConnection
     */
    select?: DeviceConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceConnection
     */
    omit?: DeviceConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceConnectionInclude<ExtArgs> | null
    /**
     * The filter to search for the DeviceConnection to update in case it exists.
     */
    where: DeviceConnectionWhereUniqueInput
    /**
     * In case the DeviceConnection found by the `where` argument doesn't exist, create a new DeviceConnection with this data.
     */
    create: XOR<DeviceConnectionCreateInput, DeviceConnectionUncheckedCreateInput>
    /**
     * In case the DeviceConnection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceConnectionUpdateInput, DeviceConnectionUncheckedUpdateInput>
  }

  /**
   * DeviceConnection delete
   */
  export type DeviceConnectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceConnection
     */
    select?: DeviceConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceConnection
     */
    omit?: DeviceConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceConnectionInclude<ExtArgs> | null
    /**
     * Filter which DeviceConnection to delete.
     */
    where: DeviceConnectionWhereUniqueInput
  }

  /**
   * DeviceConnection deleteMany
   */
  export type DeviceConnectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceConnections to delete
     */
    where?: DeviceConnectionWhereInput
    /**
     * Limit how many DeviceConnections to delete.
     */
    limit?: number
  }

  /**
   * DeviceConnection without action
   */
  export type DeviceConnectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceConnection
     */
    select?: DeviceConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceConnection
     */
    omit?: DeviceConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceConnectionInclude<ExtArgs> | null
  }


  /**
   * Model WellnessSession
   */

  export type AggregateWellnessSession = {
    _count: WellnessSessionCountAggregateOutputType | null
    _avg: WellnessSessionAvgAggregateOutputType | null
    _sum: WellnessSessionSumAggregateOutputType | null
    _min: WellnessSessionMinAggregateOutputType | null
    _max: WellnessSessionMaxAggregateOutputType | null
  }

  export type WellnessSessionAvgAggregateOutputType = {
    duration: number | null
    startingStress: number | null
    endingStress: number | null
    avgHeartRate: number | null
    stressReduction: number | null
    userRating: number | null
    completionRate: number | null
  }

  export type WellnessSessionSumAggregateOutputType = {
    duration: number | null
    startingStress: number | null
    endingStress: number | null
    avgHeartRate: number | null
    stressReduction: number | null
    userRating: number | null
    completionRate: number | null
  }

  export type WellnessSessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    sessionType: string | null
    title: string | null
    duration: number | null
    startingStress: number | null
    endingStress: number | null
    avgHeartRate: number | null
    stressReduction: number | null
    userRating: number | null
    completionRate: number | null
    startedAt: Date | null
    completedAt: Date | null
  }

  export type WellnessSessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    sessionType: string | null
    title: string | null
    duration: number | null
    startingStress: number | null
    endingStress: number | null
    avgHeartRate: number | null
    stressReduction: number | null
    userRating: number | null
    completionRate: number | null
    startedAt: Date | null
    completedAt: Date | null
  }

  export type WellnessSessionCountAggregateOutputType = {
    id: number
    userId: number
    sessionType: number
    title: number
    duration: number
    startingStress: number
    endingStress: number
    adaptations: number
    avgHeartRate: number
    stressReduction: number
    userRating: number
    completionRate: number
    startedAt: number
    completedAt: number
    _all: number
  }


  export type WellnessSessionAvgAggregateInputType = {
    duration?: true
    startingStress?: true
    endingStress?: true
    avgHeartRate?: true
    stressReduction?: true
    userRating?: true
    completionRate?: true
  }

  export type WellnessSessionSumAggregateInputType = {
    duration?: true
    startingStress?: true
    endingStress?: true
    avgHeartRate?: true
    stressReduction?: true
    userRating?: true
    completionRate?: true
  }

  export type WellnessSessionMinAggregateInputType = {
    id?: true
    userId?: true
    sessionType?: true
    title?: true
    duration?: true
    startingStress?: true
    endingStress?: true
    avgHeartRate?: true
    stressReduction?: true
    userRating?: true
    completionRate?: true
    startedAt?: true
    completedAt?: true
  }

  export type WellnessSessionMaxAggregateInputType = {
    id?: true
    userId?: true
    sessionType?: true
    title?: true
    duration?: true
    startingStress?: true
    endingStress?: true
    avgHeartRate?: true
    stressReduction?: true
    userRating?: true
    completionRate?: true
    startedAt?: true
    completedAt?: true
  }

  export type WellnessSessionCountAggregateInputType = {
    id?: true
    userId?: true
    sessionType?: true
    title?: true
    duration?: true
    startingStress?: true
    endingStress?: true
    adaptations?: true
    avgHeartRate?: true
    stressReduction?: true
    userRating?: true
    completionRate?: true
    startedAt?: true
    completedAt?: true
    _all?: true
  }

  export type WellnessSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WellnessSession to aggregate.
     */
    where?: WellnessSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WellnessSessions to fetch.
     */
    orderBy?: WellnessSessionOrderByWithRelationInput | WellnessSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WellnessSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WellnessSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WellnessSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WellnessSessions
    **/
    _count?: true | WellnessSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WellnessSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WellnessSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WellnessSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WellnessSessionMaxAggregateInputType
  }

  export type GetWellnessSessionAggregateType<T extends WellnessSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateWellnessSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWellnessSession[P]>
      : GetScalarType<T[P], AggregateWellnessSession[P]>
  }




  export type WellnessSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WellnessSessionWhereInput
    orderBy?: WellnessSessionOrderByWithAggregationInput | WellnessSessionOrderByWithAggregationInput[]
    by: WellnessSessionScalarFieldEnum[] | WellnessSessionScalarFieldEnum
    having?: WellnessSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WellnessSessionCountAggregateInputType | true
    _avg?: WellnessSessionAvgAggregateInputType
    _sum?: WellnessSessionSumAggregateInputType
    _min?: WellnessSessionMinAggregateInputType
    _max?: WellnessSessionMaxAggregateInputType
  }

  export type WellnessSessionGroupByOutputType = {
    id: string
    userId: string
    sessionType: string
    title: string
    duration: number
    startingStress: number | null
    endingStress: number | null
    adaptations: JsonValue | null
    avgHeartRate: number | null
    stressReduction: number | null
    userRating: number | null
    completionRate: number | null
    startedAt: Date
    completedAt: Date | null
    _count: WellnessSessionCountAggregateOutputType | null
    _avg: WellnessSessionAvgAggregateOutputType | null
    _sum: WellnessSessionSumAggregateOutputType | null
    _min: WellnessSessionMinAggregateOutputType | null
    _max: WellnessSessionMaxAggregateOutputType | null
  }

  type GetWellnessSessionGroupByPayload<T extends WellnessSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WellnessSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WellnessSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WellnessSessionGroupByOutputType[P]>
            : GetScalarType<T[P], WellnessSessionGroupByOutputType[P]>
        }
      >
    >


  export type WellnessSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    sessionType?: boolean
    title?: boolean
    duration?: boolean
    startingStress?: boolean
    endingStress?: boolean
    adaptations?: boolean
    avgHeartRate?: boolean
    stressReduction?: boolean
    userRating?: boolean
    completionRate?: boolean
    startedAt?: boolean
    completedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wellnessSession"]>

  export type WellnessSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    sessionType?: boolean
    title?: boolean
    duration?: boolean
    startingStress?: boolean
    endingStress?: boolean
    adaptations?: boolean
    avgHeartRate?: boolean
    stressReduction?: boolean
    userRating?: boolean
    completionRate?: boolean
    startedAt?: boolean
    completedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wellnessSession"]>

  export type WellnessSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    sessionType?: boolean
    title?: boolean
    duration?: boolean
    startingStress?: boolean
    endingStress?: boolean
    adaptations?: boolean
    avgHeartRate?: boolean
    stressReduction?: boolean
    userRating?: boolean
    completionRate?: boolean
    startedAt?: boolean
    completedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wellnessSession"]>

  export type WellnessSessionSelectScalar = {
    id?: boolean
    userId?: boolean
    sessionType?: boolean
    title?: boolean
    duration?: boolean
    startingStress?: boolean
    endingStress?: boolean
    adaptations?: boolean
    avgHeartRate?: boolean
    stressReduction?: boolean
    userRating?: boolean
    completionRate?: boolean
    startedAt?: boolean
    completedAt?: boolean
  }

  export type WellnessSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "sessionType" | "title" | "duration" | "startingStress" | "endingStress" | "adaptations" | "avgHeartRate" | "stressReduction" | "userRating" | "completionRate" | "startedAt" | "completedAt", ExtArgs["result"]["wellnessSession"]>
  export type WellnessSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WellnessSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WellnessSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WellnessSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WellnessSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      sessionType: string
      title: string
      duration: number
      startingStress: number | null
      endingStress: number | null
      adaptations: Prisma.JsonValue | null
      avgHeartRate: number | null
      stressReduction: number | null
      userRating: number | null
      completionRate: number | null
      startedAt: Date
      completedAt: Date | null
    }, ExtArgs["result"]["wellnessSession"]>
    composites: {}
  }

  type WellnessSessionGetPayload<S extends boolean | null | undefined | WellnessSessionDefaultArgs> = $Result.GetResult<Prisma.$WellnessSessionPayload, S>

  type WellnessSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WellnessSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WellnessSessionCountAggregateInputType | true
    }

  export interface WellnessSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WellnessSession'], meta: { name: 'WellnessSession' } }
    /**
     * Find zero or one WellnessSession that matches the filter.
     * @param {WellnessSessionFindUniqueArgs} args - Arguments to find a WellnessSession
     * @example
     * // Get one WellnessSession
     * const wellnessSession = await prisma.wellnessSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WellnessSessionFindUniqueArgs>(args: SelectSubset<T, WellnessSessionFindUniqueArgs<ExtArgs>>): Prisma__WellnessSessionClient<$Result.GetResult<Prisma.$WellnessSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WellnessSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WellnessSessionFindUniqueOrThrowArgs} args - Arguments to find a WellnessSession
     * @example
     * // Get one WellnessSession
     * const wellnessSession = await prisma.wellnessSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WellnessSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, WellnessSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WellnessSessionClient<$Result.GetResult<Prisma.$WellnessSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WellnessSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellnessSessionFindFirstArgs} args - Arguments to find a WellnessSession
     * @example
     * // Get one WellnessSession
     * const wellnessSession = await prisma.wellnessSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WellnessSessionFindFirstArgs>(args?: SelectSubset<T, WellnessSessionFindFirstArgs<ExtArgs>>): Prisma__WellnessSessionClient<$Result.GetResult<Prisma.$WellnessSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WellnessSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellnessSessionFindFirstOrThrowArgs} args - Arguments to find a WellnessSession
     * @example
     * // Get one WellnessSession
     * const wellnessSession = await prisma.wellnessSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WellnessSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, WellnessSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__WellnessSessionClient<$Result.GetResult<Prisma.$WellnessSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WellnessSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellnessSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WellnessSessions
     * const wellnessSessions = await prisma.wellnessSession.findMany()
     * 
     * // Get first 10 WellnessSessions
     * const wellnessSessions = await prisma.wellnessSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wellnessSessionWithIdOnly = await prisma.wellnessSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WellnessSessionFindManyArgs>(args?: SelectSubset<T, WellnessSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WellnessSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WellnessSession.
     * @param {WellnessSessionCreateArgs} args - Arguments to create a WellnessSession.
     * @example
     * // Create one WellnessSession
     * const WellnessSession = await prisma.wellnessSession.create({
     *   data: {
     *     // ... data to create a WellnessSession
     *   }
     * })
     * 
     */
    create<T extends WellnessSessionCreateArgs>(args: SelectSubset<T, WellnessSessionCreateArgs<ExtArgs>>): Prisma__WellnessSessionClient<$Result.GetResult<Prisma.$WellnessSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WellnessSessions.
     * @param {WellnessSessionCreateManyArgs} args - Arguments to create many WellnessSessions.
     * @example
     * // Create many WellnessSessions
     * const wellnessSession = await prisma.wellnessSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WellnessSessionCreateManyArgs>(args?: SelectSubset<T, WellnessSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WellnessSessions and returns the data saved in the database.
     * @param {WellnessSessionCreateManyAndReturnArgs} args - Arguments to create many WellnessSessions.
     * @example
     * // Create many WellnessSessions
     * const wellnessSession = await prisma.wellnessSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WellnessSessions and only return the `id`
     * const wellnessSessionWithIdOnly = await prisma.wellnessSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WellnessSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, WellnessSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WellnessSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WellnessSession.
     * @param {WellnessSessionDeleteArgs} args - Arguments to delete one WellnessSession.
     * @example
     * // Delete one WellnessSession
     * const WellnessSession = await prisma.wellnessSession.delete({
     *   where: {
     *     // ... filter to delete one WellnessSession
     *   }
     * })
     * 
     */
    delete<T extends WellnessSessionDeleteArgs>(args: SelectSubset<T, WellnessSessionDeleteArgs<ExtArgs>>): Prisma__WellnessSessionClient<$Result.GetResult<Prisma.$WellnessSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WellnessSession.
     * @param {WellnessSessionUpdateArgs} args - Arguments to update one WellnessSession.
     * @example
     * // Update one WellnessSession
     * const wellnessSession = await prisma.wellnessSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WellnessSessionUpdateArgs>(args: SelectSubset<T, WellnessSessionUpdateArgs<ExtArgs>>): Prisma__WellnessSessionClient<$Result.GetResult<Prisma.$WellnessSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WellnessSessions.
     * @param {WellnessSessionDeleteManyArgs} args - Arguments to filter WellnessSessions to delete.
     * @example
     * // Delete a few WellnessSessions
     * const { count } = await prisma.wellnessSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WellnessSessionDeleteManyArgs>(args?: SelectSubset<T, WellnessSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WellnessSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellnessSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WellnessSessions
     * const wellnessSession = await prisma.wellnessSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WellnessSessionUpdateManyArgs>(args: SelectSubset<T, WellnessSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WellnessSessions and returns the data updated in the database.
     * @param {WellnessSessionUpdateManyAndReturnArgs} args - Arguments to update many WellnessSessions.
     * @example
     * // Update many WellnessSessions
     * const wellnessSession = await prisma.wellnessSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WellnessSessions and only return the `id`
     * const wellnessSessionWithIdOnly = await prisma.wellnessSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WellnessSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, WellnessSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WellnessSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WellnessSession.
     * @param {WellnessSessionUpsertArgs} args - Arguments to update or create a WellnessSession.
     * @example
     * // Update or create a WellnessSession
     * const wellnessSession = await prisma.wellnessSession.upsert({
     *   create: {
     *     // ... data to create a WellnessSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WellnessSession we want to update
     *   }
     * })
     */
    upsert<T extends WellnessSessionUpsertArgs>(args: SelectSubset<T, WellnessSessionUpsertArgs<ExtArgs>>): Prisma__WellnessSessionClient<$Result.GetResult<Prisma.$WellnessSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WellnessSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellnessSessionCountArgs} args - Arguments to filter WellnessSessions to count.
     * @example
     * // Count the number of WellnessSessions
     * const count = await prisma.wellnessSession.count({
     *   where: {
     *     // ... the filter for the WellnessSessions we want to count
     *   }
     * })
    **/
    count<T extends WellnessSessionCountArgs>(
      args?: Subset<T, WellnessSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WellnessSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WellnessSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellnessSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WellnessSessionAggregateArgs>(args: Subset<T, WellnessSessionAggregateArgs>): Prisma.PrismaPromise<GetWellnessSessionAggregateType<T>>

    /**
     * Group by WellnessSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellnessSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WellnessSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WellnessSessionGroupByArgs['orderBy'] }
        : { orderBy?: WellnessSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WellnessSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWellnessSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WellnessSession model
   */
  readonly fields: WellnessSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WellnessSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WellnessSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WellnessSession model
   */
  interface WellnessSessionFieldRefs {
    readonly id: FieldRef<"WellnessSession", 'String'>
    readonly userId: FieldRef<"WellnessSession", 'String'>
    readonly sessionType: FieldRef<"WellnessSession", 'String'>
    readonly title: FieldRef<"WellnessSession", 'String'>
    readonly duration: FieldRef<"WellnessSession", 'Int'>
    readonly startingStress: FieldRef<"WellnessSession", 'Int'>
    readonly endingStress: FieldRef<"WellnessSession", 'Int'>
    readonly adaptations: FieldRef<"WellnessSession", 'Json'>
    readonly avgHeartRate: FieldRef<"WellnessSession", 'Int'>
    readonly stressReduction: FieldRef<"WellnessSession", 'Float'>
    readonly userRating: FieldRef<"WellnessSession", 'Int'>
    readonly completionRate: FieldRef<"WellnessSession", 'Float'>
    readonly startedAt: FieldRef<"WellnessSession", 'DateTime'>
    readonly completedAt: FieldRef<"WellnessSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WellnessSession findUnique
   */
  export type WellnessSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellnessSession
     */
    select?: WellnessSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellnessSession
     */
    omit?: WellnessSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellnessSessionInclude<ExtArgs> | null
    /**
     * Filter, which WellnessSession to fetch.
     */
    where: WellnessSessionWhereUniqueInput
  }

  /**
   * WellnessSession findUniqueOrThrow
   */
  export type WellnessSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellnessSession
     */
    select?: WellnessSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellnessSession
     */
    omit?: WellnessSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellnessSessionInclude<ExtArgs> | null
    /**
     * Filter, which WellnessSession to fetch.
     */
    where: WellnessSessionWhereUniqueInput
  }

  /**
   * WellnessSession findFirst
   */
  export type WellnessSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellnessSession
     */
    select?: WellnessSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellnessSession
     */
    omit?: WellnessSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellnessSessionInclude<ExtArgs> | null
    /**
     * Filter, which WellnessSession to fetch.
     */
    where?: WellnessSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WellnessSessions to fetch.
     */
    orderBy?: WellnessSessionOrderByWithRelationInput | WellnessSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WellnessSessions.
     */
    cursor?: WellnessSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WellnessSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WellnessSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WellnessSessions.
     */
    distinct?: WellnessSessionScalarFieldEnum | WellnessSessionScalarFieldEnum[]
  }

  /**
   * WellnessSession findFirstOrThrow
   */
  export type WellnessSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellnessSession
     */
    select?: WellnessSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellnessSession
     */
    omit?: WellnessSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellnessSessionInclude<ExtArgs> | null
    /**
     * Filter, which WellnessSession to fetch.
     */
    where?: WellnessSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WellnessSessions to fetch.
     */
    orderBy?: WellnessSessionOrderByWithRelationInput | WellnessSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WellnessSessions.
     */
    cursor?: WellnessSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WellnessSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WellnessSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WellnessSessions.
     */
    distinct?: WellnessSessionScalarFieldEnum | WellnessSessionScalarFieldEnum[]
  }

  /**
   * WellnessSession findMany
   */
  export type WellnessSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellnessSession
     */
    select?: WellnessSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellnessSession
     */
    omit?: WellnessSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellnessSessionInclude<ExtArgs> | null
    /**
     * Filter, which WellnessSessions to fetch.
     */
    where?: WellnessSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WellnessSessions to fetch.
     */
    orderBy?: WellnessSessionOrderByWithRelationInput | WellnessSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WellnessSessions.
     */
    cursor?: WellnessSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WellnessSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WellnessSessions.
     */
    skip?: number
    distinct?: WellnessSessionScalarFieldEnum | WellnessSessionScalarFieldEnum[]
  }

  /**
   * WellnessSession create
   */
  export type WellnessSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellnessSession
     */
    select?: WellnessSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellnessSession
     */
    omit?: WellnessSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellnessSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a WellnessSession.
     */
    data: XOR<WellnessSessionCreateInput, WellnessSessionUncheckedCreateInput>
  }

  /**
   * WellnessSession createMany
   */
  export type WellnessSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WellnessSessions.
     */
    data: WellnessSessionCreateManyInput | WellnessSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WellnessSession createManyAndReturn
   */
  export type WellnessSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellnessSession
     */
    select?: WellnessSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WellnessSession
     */
    omit?: WellnessSessionOmit<ExtArgs> | null
    /**
     * The data used to create many WellnessSessions.
     */
    data: WellnessSessionCreateManyInput | WellnessSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellnessSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WellnessSession update
   */
  export type WellnessSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellnessSession
     */
    select?: WellnessSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellnessSession
     */
    omit?: WellnessSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellnessSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a WellnessSession.
     */
    data: XOR<WellnessSessionUpdateInput, WellnessSessionUncheckedUpdateInput>
    /**
     * Choose, which WellnessSession to update.
     */
    where: WellnessSessionWhereUniqueInput
  }

  /**
   * WellnessSession updateMany
   */
  export type WellnessSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WellnessSessions.
     */
    data: XOR<WellnessSessionUpdateManyMutationInput, WellnessSessionUncheckedUpdateManyInput>
    /**
     * Filter which WellnessSessions to update
     */
    where?: WellnessSessionWhereInput
    /**
     * Limit how many WellnessSessions to update.
     */
    limit?: number
  }

  /**
   * WellnessSession updateManyAndReturn
   */
  export type WellnessSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellnessSession
     */
    select?: WellnessSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WellnessSession
     */
    omit?: WellnessSessionOmit<ExtArgs> | null
    /**
     * The data used to update WellnessSessions.
     */
    data: XOR<WellnessSessionUpdateManyMutationInput, WellnessSessionUncheckedUpdateManyInput>
    /**
     * Filter which WellnessSessions to update
     */
    where?: WellnessSessionWhereInput
    /**
     * Limit how many WellnessSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellnessSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WellnessSession upsert
   */
  export type WellnessSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellnessSession
     */
    select?: WellnessSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellnessSession
     */
    omit?: WellnessSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellnessSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the WellnessSession to update in case it exists.
     */
    where: WellnessSessionWhereUniqueInput
    /**
     * In case the WellnessSession found by the `where` argument doesn't exist, create a new WellnessSession with this data.
     */
    create: XOR<WellnessSessionCreateInput, WellnessSessionUncheckedCreateInput>
    /**
     * In case the WellnessSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WellnessSessionUpdateInput, WellnessSessionUncheckedUpdateInput>
  }

  /**
   * WellnessSession delete
   */
  export type WellnessSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellnessSession
     */
    select?: WellnessSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellnessSession
     */
    omit?: WellnessSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellnessSessionInclude<ExtArgs> | null
    /**
     * Filter which WellnessSession to delete.
     */
    where: WellnessSessionWhereUniqueInput
  }

  /**
   * WellnessSession deleteMany
   */
  export type WellnessSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WellnessSessions to delete
     */
    where?: WellnessSessionWhereInput
    /**
     * Limit how many WellnessSessions to delete.
     */
    limit?: number
  }

  /**
   * WellnessSession without action
   */
  export type WellnessSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellnessSession
     */
    select?: WellnessSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellnessSession
     */
    omit?: WellnessSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellnessSessionInclude<ExtArgs> | null
  }


  /**
   * Model EnvironmentalData
   */

  export type AggregateEnvironmentalData = {
    _count: EnvironmentalDataCountAggregateOutputType | null
    _avg: EnvironmentalDataAvgAggregateOutputType | null
    _sum: EnvironmentalDataSumAggregateOutputType | null
    _min: EnvironmentalDataMinAggregateOutputType | null
    _max: EnvironmentalDataMaxAggregateOutputType | null
  }

  export type EnvironmentalDataAvgAggregateOutputType = {
    temperature: number | null
    humidity: number | null
    pressure: number | null
    airQuality: number | null
    lightLevel: number | null
    uvIndex: number | null
    noiseLevel: number | null
  }

  export type EnvironmentalDataSumAggregateOutputType = {
    temperature: number | null
    humidity: number | null
    pressure: number | null
    airQuality: number | null
    lightLevel: number | null
    uvIndex: number | null
    noiseLevel: number | null
  }

  export type EnvironmentalDataMinAggregateOutputType = {
    id: string | null
    userId: string | null
    location: string | null
    timezone: string | null
    temperature: number | null
    humidity: number | null
    pressure: number | null
    weather: string | null
    airQuality: number | null
    lightLevel: number | null
    uvIndex: number | null
    noiseLevel: number | null
    timestamp: Date | null
  }

  export type EnvironmentalDataMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    location: string | null
    timezone: string | null
    temperature: number | null
    humidity: number | null
    pressure: number | null
    weather: string | null
    airQuality: number | null
    lightLevel: number | null
    uvIndex: number | null
    noiseLevel: number | null
    timestamp: Date | null
  }

  export type EnvironmentalDataCountAggregateOutputType = {
    id: number
    userId: number
    location: number
    timezone: number
    temperature: number
    humidity: number
    pressure: number
    weather: number
    airQuality: number
    pollutants: number
    lightLevel: number
    uvIndex: number
    noiseLevel: number
    timestamp: number
    _all: number
  }


  export type EnvironmentalDataAvgAggregateInputType = {
    temperature?: true
    humidity?: true
    pressure?: true
    airQuality?: true
    lightLevel?: true
    uvIndex?: true
    noiseLevel?: true
  }

  export type EnvironmentalDataSumAggregateInputType = {
    temperature?: true
    humidity?: true
    pressure?: true
    airQuality?: true
    lightLevel?: true
    uvIndex?: true
    noiseLevel?: true
  }

  export type EnvironmentalDataMinAggregateInputType = {
    id?: true
    userId?: true
    location?: true
    timezone?: true
    temperature?: true
    humidity?: true
    pressure?: true
    weather?: true
    airQuality?: true
    lightLevel?: true
    uvIndex?: true
    noiseLevel?: true
    timestamp?: true
  }

  export type EnvironmentalDataMaxAggregateInputType = {
    id?: true
    userId?: true
    location?: true
    timezone?: true
    temperature?: true
    humidity?: true
    pressure?: true
    weather?: true
    airQuality?: true
    lightLevel?: true
    uvIndex?: true
    noiseLevel?: true
    timestamp?: true
  }

  export type EnvironmentalDataCountAggregateInputType = {
    id?: true
    userId?: true
    location?: true
    timezone?: true
    temperature?: true
    humidity?: true
    pressure?: true
    weather?: true
    airQuality?: true
    pollutants?: true
    lightLevel?: true
    uvIndex?: true
    noiseLevel?: true
    timestamp?: true
    _all?: true
  }

  export type EnvironmentalDataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EnvironmentalData to aggregate.
     */
    where?: EnvironmentalDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnvironmentalData to fetch.
     */
    orderBy?: EnvironmentalDataOrderByWithRelationInput | EnvironmentalDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EnvironmentalDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnvironmentalData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnvironmentalData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EnvironmentalData
    **/
    _count?: true | EnvironmentalDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EnvironmentalDataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EnvironmentalDataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnvironmentalDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnvironmentalDataMaxAggregateInputType
  }

  export type GetEnvironmentalDataAggregateType<T extends EnvironmentalDataAggregateArgs> = {
        [P in keyof T & keyof AggregateEnvironmentalData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnvironmentalData[P]>
      : GetScalarType<T[P], AggregateEnvironmentalData[P]>
  }




  export type EnvironmentalDataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnvironmentalDataWhereInput
    orderBy?: EnvironmentalDataOrderByWithAggregationInput | EnvironmentalDataOrderByWithAggregationInput[]
    by: EnvironmentalDataScalarFieldEnum[] | EnvironmentalDataScalarFieldEnum
    having?: EnvironmentalDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnvironmentalDataCountAggregateInputType | true
    _avg?: EnvironmentalDataAvgAggregateInputType
    _sum?: EnvironmentalDataSumAggregateInputType
    _min?: EnvironmentalDataMinAggregateInputType
    _max?: EnvironmentalDataMaxAggregateInputType
  }

  export type EnvironmentalDataGroupByOutputType = {
    id: string
    userId: string
    location: string | null
    timezone: string | null
    temperature: number | null
    humidity: number | null
    pressure: number | null
    weather: string | null
    airQuality: number | null
    pollutants: JsonValue | null
    lightLevel: number | null
    uvIndex: number | null
    noiseLevel: number | null
    timestamp: Date
    _count: EnvironmentalDataCountAggregateOutputType | null
    _avg: EnvironmentalDataAvgAggregateOutputType | null
    _sum: EnvironmentalDataSumAggregateOutputType | null
    _min: EnvironmentalDataMinAggregateOutputType | null
    _max: EnvironmentalDataMaxAggregateOutputType | null
  }

  type GetEnvironmentalDataGroupByPayload<T extends EnvironmentalDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnvironmentalDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnvironmentalDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnvironmentalDataGroupByOutputType[P]>
            : GetScalarType<T[P], EnvironmentalDataGroupByOutputType[P]>
        }
      >
    >


  export type EnvironmentalDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    location?: boolean
    timezone?: boolean
    temperature?: boolean
    humidity?: boolean
    pressure?: boolean
    weather?: boolean
    airQuality?: boolean
    pollutants?: boolean
    lightLevel?: boolean
    uvIndex?: boolean
    noiseLevel?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["environmentalData"]>

  export type EnvironmentalDataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    location?: boolean
    timezone?: boolean
    temperature?: boolean
    humidity?: boolean
    pressure?: boolean
    weather?: boolean
    airQuality?: boolean
    pollutants?: boolean
    lightLevel?: boolean
    uvIndex?: boolean
    noiseLevel?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["environmentalData"]>

  export type EnvironmentalDataSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    location?: boolean
    timezone?: boolean
    temperature?: boolean
    humidity?: boolean
    pressure?: boolean
    weather?: boolean
    airQuality?: boolean
    pollutants?: boolean
    lightLevel?: boolean
    uvIndex?: boolean
    noiseLevel?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["environmentalData"]>

  export type EnvironmentalDataSelectScalar = {
    id?: boolean
    userId?: boolean
    location?: boolean
    timezone?: boolean
    temperature?: boolean
    humidity?: boolean
    pressure?: boolean
    weather?: boolean
    airQuality?: boolean
    pollutants?: boolean
    lightLevel?: boolean
    uvIndex?: boolean
    noiseLevel?: boolean
    timestamp?: boolean
  }

  export type EnvironmentalDataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "location" | "timezone" | "temperature" | "humidity" | "pressure" | "weather" | "airQuality" | "pollutants" | "lightLevel" | "uvIndex" | "noiseLevel" | "timestamp", ExtArgs["result"]["environmentalData"]>
  export type EnvironmentalDataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EnvironmentalDataIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EnvironmentalDataIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EnvironmentalDataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EnvironmentalData"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      location: string | null
      timezone: string | null
      temperature: number | null
      humidity: number | null
      pressure: number | null
      weather: string | null
      airQuality: number | null
      pollutants: Prisma.JsonValue | null
      lightLevel: number | null
      uvIndex: number | null
      noiseLevel: number | null
      timestamp: Date
    }, ExtArgs["result"]["environmentalData"]>
    composites: {}
  }

  type EnvironmentalDataGetPayload<S extends boolean | null | undefined | EnvironmentalDataDefaultArgs> = $Result.GetResult<Prisma.$EnvironmentalDataPayload, S>

  type EnvironmentalDataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EnvironmentalDataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EnvironmentalDataCountAggregateInputType | true
    }

  export interface EnvironmentalDataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EnvironmentalData'], meta: { name: 'EnvironmentalData' } }
    /**
     * Find zero or one EnvironmentalData that matches the filter.
     * @param {EnvironmentalDataFindUniqueArgs} args - Arguments to find a EnvironmentalData
     * @example
     * // Get one EnvironmentalData
     * const environmentalData = await prisma.environmentalData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EnvironmentalDataFindUniqueArgs>(args: SelectSubset<T, EnvironmentalDataFindUniqueArgs<ExtArgs>>): Prisma__EnvironmentalDataClient<$Result.GetResult<Prisma.$EnvironmentalDataPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EnvironmentalData that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EnvironmentalDataFindUniqueOrThrowArgs} args - Arguments to find a EnvironmentalData
     * @example
     * // Get one EnvironmentalData
     * const environmentalData = await prisma.environmentalData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EnvironmentalDataFindUniqueOrThrowArgs>(args: SelectSubset<T, EnvironmentalDataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EnvironmentalDataClient<$Result.GetResult<Prisma.$EnvironmentalDataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EnvironmentalData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvironmentalDataFindFirstArgs} args - Arguments to find a EnvironmentalData
     * @example
     * // Get one EnvironmentalData
     * const environmentalData = await prisma.environmentalData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EnvironmentalDataFindFirstArgs>(args?: SelectSubset<T, EnvironmentalDataFindFirstArgs<ExtArgs>>): Prisma__EnvironmentalDataClient<$Result.GetResult<Prisma.$EnvironmentalDataPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EnvironmentalData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvironmentalDataFindFirstOrThrowArgs} args - Arguments to find a EnvironmentalData
     * @example
     * // Get one EnvironmentalData
     * const environmentalData = await prisma.environmentalData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EnvironmentalDataFindFirstOrThrowArgs>(args?: SelectSubset<T, EnvironmentalDataFindFirstOrThrowArgs<ExtArgs>>): Prisma__EnvironmentalDataClient<$Result.GetResult<Prisma.$EnvironmentalDataPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EnvironmentalData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvironmentalDataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EnvironmentalData
     * const environmentalData = await prisma.environmentalData.findMany()
     * 
     * // Get first 10 EnvironmentalData
     * const environmentalData = await prisma.environmentalData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const environmentalDataWithIdOnly = await prisma.environmentalData.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EnvironmentalDataFindManyArgs>(args?: SelectSubset<T, EnvironmentalDataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnvironmentalDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EnvironmentalData.
     * @param {EnvironmentalDataCreateArgs} args - Arguments to create a EnvironmentalData.
     * @example
     * // Create one EnvironmentalData
     * const EnvironmentalData = await prisma.environmentalData.create({
     *   data: {
     *     // ... data to create a EnvironmentalData
     *   }
     * })
     * 
     */
    create<T extends EnvironmentalDataCreateArgs>(args: SelectSubset<T, EnvironmentalDataCreateArgs<ExtArgs>>): Prisma__EnvironmentalDataClient<$Result.GetResult<Prisma.$EnvironmentalDataPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EnvironmentalData.
     * @param {EnvironmentalDataCreateManyArgs} args - Arguments to create many EnvironmentalData.
     * @example
     * // Create many EnvironmentalData
     * const environmentalData = await prisma.environmentalData.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EnvironmentalDataCreateManyArgs>(args?: SelectSubset<T, EnvironmentalDataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EnvironmentalData and returns the data saved in the database.
     * @param {EnvironmentalDataCreateManyAndReturnArgs} args - Arguments to create many EnvironmentalData.
     * @example
     * // Create many EnvironmentalData
     * const environmentalData = await prisma.environmentalData.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EnvironmentalData and only return the `id`
     * const environmentalDataWithIdOnly = await prisma.environmentalData.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EnvironmentalDataCreateManyAndReturnArgs>(args?: SelectSubset<T, EnvironmentalDataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnvironmentalDataPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EnvironmentalData.
     * @param {EnvironmentalDataDeleteArgs} args - Arguments to delete one EnvironmentalData.
     * @example
     * // Delete one EnvironmentalData
     * const EnvironmentalData = await prisma.environmentalData.delete({
     *   where: {
     *     // ... filter to delete one EnvironmentalData
     *   }
     * })
     * 
     */
    delete<T extends EnvironmentalDataDeleteArgs>(args: SelectSubset<T, EnvironmentalDataDeleteArgs<ExtArgs>>): Prisma__EnvironmentalDataClient<$Result.GetResult<Prisma.$EnvironmentalDataPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EnvironmentalData.
     * @param {EnvironmentalDataUpdateArgs} args - Arguments to update one EnvironmentalData.
     * @example
     * // Update one EnvironmentalData
     * const environmentalData = await prisma.environmentalData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EnvironmentalDataUpdateArgs>(args: SelectSubset<T, EnvironmentalDataUpdateArgs<ExtArgs>>): Prisma__EnvironmentalDataClient<$Result.GetResult<Prisma.$EnvironmentalDataPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EnvironmentalData.
     * @param {EnvironmentalDataDeleteManyArgs} args - Arguments to filter EnvironmentalData to delete.
     * @example
     * // Delete a few EnvironmentalData
     * const { count } = await prisma.environmentalData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EnvironmentalDataDeleteManyArgs>(args?: SelectSubset<T, EnvironmentalDataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EnvironmentalData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvironmentalDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EnvironmentalData
     * const environmentalData = await prisma.environmentalData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EnvironmentalDataUpdateManyArgs>(args: SelectSubset<T, EnvironmentalDataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EnvironmentalData and returns the data updated in the database.
     * @param {EnvironmentalDataUpdateManyAndReturnArgs} args - Arguments to update many EnvironmentalData.
     * @example
     * // Update many EnvironmentalData
     * const environmentalData = await prisma.environmentalData.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EnvironmentalData and only return the `id`
     * const environmentalDataWithIdOnly = await prisma.environmentalData.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EnvironmentalDataUpdateManyAndReturnArgs>(args: SelectSubset<T, EnvironmentalDataUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnvironmentalDataPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EnvironmentalData.
     * @param {EnvironmentalDataUpsertArgs} args - Arguments to update or create a EnvironmentalData.
     * @example
     * // Update or create a EnvironmentalData
     * const environmentalData = await prisma.environmentalData.upsert({
     *   create: {
     *     // ... data to create a EnvironmentalData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EnvironmentalData we want to update
     *   }
     * })
     */
    upsert<T extends EnvironmentalDataUpsertArgs>(args: SelectSubset<T, EnvironmentalDataUpsertArgs<ExtArgs>>): Prisma__EnvironmentalDataClient<$Result.GetResult<Prisma.$EnvironmentalDataPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EnvironmentalData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvironmentalDataCountArgs} args - Arguments to filter EnvironmentalData to count.
     * @example
     * // Count the number of EnvironmentalData
     * const count = await prisma.environmentalData.count({
     *   where: {
     *     // ... the filter for the EnvironmentalData we want to count
     *   }
     * })
    **/
    count<T extends EnvironmentalDataCountArgs>(
      args?: Subset<T, EnvironmentalDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnvironmentalDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EnvironmentalData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvironmentalDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnvironmentalDataAggregateArgs>(args: Subset<T, EnvironmentalDataAggregateArgs>): Prisma.PrismaPromise<GetEnvironmentalDataAggregateType<T>>

    /**
     * Group by EnvironmentalData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvironmentalDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EnvironmentalDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnvironmentalDataGroupByArgs['orderBy'] }
        : { orderBy?: EnvironmentalDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EnvironmentalDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnvironmentalDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EnvironmentalData model
   */
  readonly fields: EnvironmentalDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EnvironmentalData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EnvironmentalDataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EnvironmentalData model
   */
  interface EnvironmentalDataFieldRefs {
    readonly id: FieldRef<"EnvironmentalData", 'String'>
    readonly userId: FieldRef<"EnvironmentalData", 'String'>
    readonly location: FieldRef<"EnvironmentalData", 'String'>
    readonly timezone: FieldRef<"EnvironmentalData", 'String'>
    readonly temperature: FieldRef<"EnvironmentalData", 'Float'>
    readonly humidity: FieldRef<"EnvironmentalData", 'Float'>
    readonly pressure: FieldRef<"EnvironmentalData", 'Float'>
    readonly weather: FieldRef<"EnvironmentalData", 'String'>
    readonly airQuality: FieldRef<"EnvironmentalData", 'Int'>
    readonly pollutants: FieldRef<"EnvironmentalData", 'Json'>
    readonly lightLevel: FieldRef<"EnvironmentalData", 'Float'>
    readonly uvIndex: FieldRef<"EnvironmentalData", 'Float'>
    readonly noiseLevel: FieldRef<"EnvironmentalData", 'Float'>
    readonly timestamp: FieldRef<"EnvironmentalData", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EnvironmentalData findUnique
   */
  export type EnvironmentalDataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvironmentalData
     */
    select?: EnvironmentalDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnvironmentalData
     */
    omit?: EnvironmentalDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvironmentalDataInclude<ExtArgs> | null
    /**
     * Filter, which EnvironmentalData to fetch.
     */
    where: EnvironmentalDataWhereUniqueInput
  }

  /**
   * EnvironmentalData findUniqueOrThrow
   */
  export type EnvironmentalDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvironmentalData
     */
    select?: EnvironmentalDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnvironmentalData
     */
    omit?: EnvironmentalDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvironmentalDataInclude<ExtArgs> | null
    /**
     * Filter, which EnvironmentalData to fetch.
     */
    where: EnvironmentalDataWhereUniqueInput
  }

  /**
   * EnvironmentalData findFirst
   */
  export type EnvironmentalDataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvironmentalData
     */
    select?: EnvironmentalDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnvironmentalData
     */
    omit?: EnvironmentalDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvironmentalDataInclude<ExtArgs> | null
    /**
     * Filter, which EnvironmentalData to fetch.
     */
    where?: EnvironmentalDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnvironmentalData to fetch.
     */
    orderBy?: EnvironmentalDataOrderByWithRelationInput | EnvironmentalDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EnvironmentalData.
     */
    cursor?: EnvironmentalDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnvironmentalData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnvironmentalData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EnvironmentalData.
     */
    distinct?: EnvironmentalDataScalarFieldEnum | EnvironmentalDataScalarFieldEnum[]
  }

  /**
   * EnvironmentalData findFirstOrThrow
   */
  export type EnvironmentalDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvironmentalData
     */
    select?: EnvironmentalDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnvironmentalData
     */
    omit?: EnvironmentalDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvironmentalDataInclude<ExtArgs> | null
    /**
     * Filter, which EnvironmentalData to fetch.
     */
    where?: EnvironmentalDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnvironmentalData to fetch.
     */
    orderBy?: EnvironmentalDataOrderByWithRelationInput | EnvironmentalDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EnvironmentalData.
     */
    cursor?: EnvironmentalDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnvironmentalData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnvironmentalData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EnvironmentalData.
     */
    distinct?: EnvironmentalDataScalarFieldEnum | EnvironmentalDataScalarFieldEnum[]
  }

  /**
   * EnvironmentalData findMany
   */
  export type EnvironmentalDataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvironmentalData
     */
    select?: EnvironmentalDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnvironmentalData
     */
    omit?: EnvironmentalDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvironmentalDataInclude<ExtArgs> | null
    /**
     * Filter, which EnvironmentalData to fetch.
     */
    where?: EnvironmentalDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnvironmentalData to fetch.
     */
    orderBy?: EnvironmentalDataOrderByWithRelationInput | EnvironmentalDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EnvironmentalData.
     */
    cursor?: EnvironmentalDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnvironmentalData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnvironmentalData.
     */
    skip?: number
    distinct?: EnvironmentalDataScalarFieldEnum | EnvironmentalDataScalarFieldEnum[]
  }

  /**
   * EnvironmentalData create
   */
  export type EnvironmentalDataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvironmentalData
     */
    select?: EnvironmentalDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnvironmentalData
     */
    omit?: EnvironmentalDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvironmentalDataInclude<ExtArgs> | null
    /**
     * The data needed to create a EnvironmentalData.
     */
    data: XOR<EnvironmentalDataCreateInput, EnvironmentalDataUncheckedCreateInput>
  }

  /**
   * EnvironmentalData createMany
   */
  export type EnvironmentalDataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EnvironmentalData.
     */
    data: EnvironmentalDataCreateManyInput | EnvironmentalDataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EnvironmentalData createManyAndReturn
   */
  export type EnvironmentalDataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvironmentalData
     */
    select?: EnvironmentalDataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EnvironmentalData
     */
    omit?: EnvironmentalDataOmit<ExtArgs> | null
    /**
     * The data used to create many EnvironmentalData.
     */
    data: EnvironmentalDataCreateManyInput | EnvironmentalDataCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvironmentalDataIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EnvironmentalData update
   */
  export type EnvironmentalDataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvironmentalData
     */
    select?: EnvironmentalDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnvironmentalData
     */
    omit?: EnvironmentalDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvironmentalDataInclude<ExtArgs> | null
    /**
     * The data needed to update a EnvironmentalData.
     */
    data: XOR<EnvironmentalDataUpdateInput, EnvironmentalDataUncheckedUpdateInput>
    /**
     * Choose, which EnvironmentalData to update.
     */
    where: EnvironmentalDataWhereUniqueInput
  }

  /**
   * EnvironmentalData updateMany
   */
  export type EnvironmentalDataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EnvironmentalData.
     */
    data: XOR<EnvironmentalDataUpdateManyMutationInput, EnvironmentalDataUncheckedUpdateManyInput>
    /**
     * Filter which EnvironmentalData to update
     */
    where?: EnvironmentalDataWhereInput
    /**
     * Limit how many EnvironmentalData to update.
     */
    limit?: number
  }

  /**
   * EnvironmentalData updateManyAndReturn
   */
  export type EnvironmentalDataUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvironmentalData
     */
    select?: EnvironmentalDataSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EnvironmentalData
     */
    omit?: EnvironmentalDataOmit<ExtArgs> | null
    /**
     * The data used to update EnvironmentalData.
     */
    data: XOR<EnvironmentalDataUpdateManyMutationInput, EnvironmentalDataUncheckedUpdateManyInput>
    /**
     * Filter which EnvironmentalData to update
     */
    where?: EnvironmentalDataWhereInput
    /**
     * Limit how many EnvironmentalData to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvironmentalDataIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EnvironmentalData upsert
   */
  export type EnvironmentalDataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvironmentalData
     */
    select?: EnvironmentalDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnvironmentalData
     */
    omit?: EnvironmentalDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvironmentalDataInclude<ExtArgs> | null
    /**
     * The filter to search for the EnvironmentalData to update in case it exists.
     */
    where: EnvironmentalDataWhereUniqueInput
    /**
     * In case the EnvironmentalData found by the `where` argument doesn't exist, create a new EnvironmentalData with this data.
     */
    create: XOR<EnvironmentalDataCreateInput, EnvironmentalDataUncheckedCreateInput>
    /**
     * In case the EnvironmentalData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EnvironmentalDataUpdateInput, EnvironmentalDataUncheckedUpdateInput>
  }

  /**
   * EnvironmentalData delete
   */
  export type EnvironmentalDataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvironmentalData
     */
    select?: EnvironmentalDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnvironmentalData
     */
    omit?: EnvironmentalDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvironmentalDataInclude<ExtArgs> | null
    /**
     * Filter which EnvironmentalData to delete.
     */
    where: EnvironmentalDataWhereUniqueInput
  }

  /**
   * EnvironmentalData deleteMany
   */
  export type EnvironmentalDataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EnvironmentalData to delete
     */
    where?: EnvironmentalDataWhereInput
    /**
     * Limit how many EnvironmentalData to delete.
     */
    limit?: number
  }

  /**
   * EnvironmentalData without action
   */
  export type EnvironmentalDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvironmentalData
     */
    select?: EnvironmentalDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnvironmentalData
     */
    omit?: EnvironmentalDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvironmentalDataInclude<ExtArgs> | null
  }


  /**
   * Model WellnessGroup
   */

  export type AggregateWellnessGroup = {
    _count: WellnessGroupCountAggregateOutputType | null
    _avg: WellnessGroupAvgAggregateOutputType | null
    _sum: WellnessGroupSumAggregateOutputType | null
    _min: WellnessGroupMinAggregateOutputType | null
    _max: WellnessGroupMaxAggregateOutputType | null
  }

  export type WellnessGroupAvgAggregateOutputType = {
    maxMembers: number | null
  }

  export type WellnessGroupSumAggregateOutputType = {
    maxMembers: number | null
  }

  export type WellnessGroupMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: string | null
    isPublic: boolean | null
    maxMembers: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WellnessGroupMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: string | null
    isPublic: boolean | null
    maxMembers: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WellnessGroupCountAggregateOutputType = {
    id: number
    name: number
    description: number
    type: number
    isPublic: number
    maxMembers: number
    groupGoals: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WellnessGroupAvgAggregateInputType = {
    maxMembers?: true
  }

  export type WellnessGroupSumAggregateInputType = {
    maxMembers?: true
  }

  export type WellnessGroupMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    isPublic?: true
    maxMembers?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WellnessGroupMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    isPublic?: true
    maxMembers?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WellnessGroupCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    isPublic?: true
    maxMembers?: true
    groupGoals?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WellnessGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WellnessGroup to aggregate.
     */
    where?: WellnessGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WellnessGroups to fetch.
     */
    orderBy?: WellnessGroupOrderByWithRelationInput | WellnessGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WellnessGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WellnessGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WellnessGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WellnessGroups
    **/
    _count?: true | WellnessGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WellnessGroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WellnessGroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WellnessGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WellnessGroupMaxAggregateInputType
  }

  export type GetWellnessGroupAggregateType<T extends WellnessGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateWellnessGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWellnessGroup[P]>
      : GetScalarType<T[P], AggregateWellnessGroup[P]>
  }




  export type WellnessGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WellnessGroupWhereInput
    orderBy?: WellnessGroupOrderByWithAggregationInput | WellnessGroupOrderByWithAggregationInput[]
    by: WellnessGroupScalarFieldEnum[] | WellnessGroupScalarFieldEnum
    having?: WellnessGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WellnessGroupCountAggregateInputType | true
    _avg?: WellnessGroupAvgAggregateInputType
    _sum?: WellnessGroupSumAggregateInputType
    _min?: WellnessGroupMinAggregateInputType
    _max?: WellnessGroupMaxAggregateInputType
  }

  export type WellnessGroupGroupByOutputType = {
    id: string
    name: string
    description: string | null
    type: string
    isPublic: boolean
    maxMembers: number | null
    groupGoals: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: WellnessGroupCountAggregateOutputType | null
    _avg: WellnessGroupAvgAggregateOutputType | null
    _sum: WellnessGroupSumAggregateOutputType | null
    _min: WellnessGroupMinAggregateOutputType | null
    _max: WellnessGroupMaxAggregateOutputType | null
  }

  type GetWellnessGroupGroupByPayload<T extends WellnessGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WellnessGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WellnessGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WellnessGroupGroupByOutputType[P]>
            : GetScalarType<T[P], WellnessGroupGroupByOutputType[P]>
        }
      >
    >


  export type WellnessGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    isPublic?: boolean
    maxMembers?: boolean
    groupGoals?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    members?: boolean | WellnessGroup$membersArgs<ExtArgs>
    _count?: boolean | WellnessGroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wellnessGroup"]>

  export type WellnessGroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    isPublic?: boolean
    maxMembers?: boolean
    groupGoals?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["wellnessGroup"]>

  export type WellnessGroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    isPublic?: boolean
    maxMembers?: boolean
    groupGoals?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["wellnessGroup"]>

  export type WellnessGroupSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    isPublic?: boolean
    maxMembers?: boolean
    groupGoals?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WellnessGroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "type" | "isPublic" | "maxMembers" | "groupGoals" | "createdAt" | "updatedAt", ExtArgs["result"]["wellnessGroup"]>
  export type WellnessGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | WellnessGroup$membersArgs<ExtArgs>
    _count?: boolean | WellnessGroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WellnessGroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type WellnessGroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $WellnessGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WellnessGroup"
    objects: {
      members: Prisma.$GroupMembershipPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      type: string
      isPublic: boolean
      maxMembers: number | null
      groupGoals: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["wellnessGroup"]>
    composites: {}
  }

  type WellnessGroupGetPayload<S extends boolean | null | undefined | WellnessGroupDefaultArgs> = $Result.GetResult<Prisma.$WellnessGroupPayload, S>

  type WellnessGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WellnessGroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WellnessGroupCountAggregateInputType | true
    }

  export interface WellnessGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WellnessGroup'], meta: { name: 'WellnessGroup' } }
    /**
     * Find zero or one WellnessGroup that matches the filter.
     * @param {WellnessGroupFindUniqueArgs} args - Arguments to find a WellnessGroup
     * @example
     * // Get one WellnessGroup
     * const wellnessGroup = await prisma.wellnessGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WellnessGroupFindUniqueArgs>(args: SelectSubset<T, WellnessGroupFindUniqueArgs<ExtArgs>>): Prisma__WellnessGroupClient<$Result.GetResult<Prisma.$WellnessGroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WellnessGroup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WellnessGroupFindUniqueOrThrowArgs} args - Arguments to find a WellnessGroup
     * @example
     * // Get one WellnessGroup
     * const wellnessGroup = await prisma.wellnessGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WellnessGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, WellnessGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WellnessGroupClient<$Result.GetResult<Prisma.$WellnessGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WellnessGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellnessGroupFindFirstArgs} args - Arguments to find a WellnessGroup
     * @example
     * // Get one WellnessGroup
     * const wellnessGroup = await prisma.wellnessGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WellnessGroupFindFirstArgs>(args?: SelectSubset<T, WellnessGroupFindFirstArgs<ExtArgs>>): Prisma__WellnessGroupClient<$Result.GetResult<Prisma.$WellnessGroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WellnessGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellnessGroupFindFirstOrThrowArgs} args - Arguments to find a WellnessGroup
     * @example
     * // Get one WellnessGroup
     * const wellnessGroup = await prisma.wellnessGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WellnessGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, WellnessGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__WellnessGroupClient<$Result.GetResult<Prisma.$WellnessGroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WellnessGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellnessGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WellnessGroups
     * const wellnessGroups = await prisma.wellnessGroup.findMany()
     * 
     * // Get first 10 WellnessGroups
     * const wellnessGroups = await prisma.wellnessGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wellnessGroupWithIdOnly = await prisma.wellnessGroup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WellnessGroupFindManyArgs>(args?: SelectSubset<T, WellnessGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WellnessGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WellnessGroup.
     * @param {WellnessGroupCreateArgs} args - Arguments to create a WellnessGroup.
     * @example
     * // Create one WellnessGroup
     * const WellnessGroup = await prisma.wellnessGroup.create({
     *   data: {
     *     // ... data to create a WellnessGroup
     *   }
     * })
     * 
     */
    create<T extends WellnessGroupCreateArgs>(args: SelectSubset<T, WellnessGroupCreateArgs<ExtArgs>>): Prisma__WellnessGroupClient<$Result.GetResult<Prisma.$WellnessGroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WellnessGroups.
     * @param {WellnessGroupCreateManyArgs} args - Arguments to create many WellnessGroups.
     * @example
     * // Create many WellnessGroups
     * const wellnessGroup = await prisma.wellnessGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WellnessGroupCreateManyArgs>(args?: SelectSubset<T, WellnessGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WellnessGroups and returns the data saved in the database.
     * @param {WellnessGroupCreateManyAndReturnArgs} args - Arguments to create many WellnessGroups.
     * @example
     * // Create many WellnessGroups
     * const wellnessGroup = await prisma.wellnessGroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WellnessGroups and only return the `id`
     * const wellnessGroupWithIdOnly = await prisma.wellnessGroup.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WellnessGroupCreateManyAndReturnArgs>(args?: SelectSubset<T, WellnessGroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WellnessGroupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WellnessGroup.
     * @param {WellnessGroupDeleteArgs} args - Arguments to delete one WellnessGroup.
     * @example
     * // Delete one WellnessGroup
     * const WellnessGroup = await prisma.wellnessGroup.delete({
     *   where: {
     *     // ... filter to delete one WellnessGroup
     *   }
     * })
     * 
     */
    delete<T extends WellnessGroupDeleteArgs>(args: SelectSubset<T, WellnessGroupDeleteArgs<ExtArgs>>): Prisma__WellnessGroupClient<$Result.GetResult<Prisma.$WellnessGroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WellnessGroup.
     * @param {WellnessGroupUpdateArgs} args - Arguments to update one WellnessGroup.
     * @example
     * // Update one WellnessGroup
     * const wellnessGroup = await prisma.wellnessGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WellnessGroupUpdateArgs>(args: SelectSubset<T, WellnessGroupUpdateArgs<ExtArgs>>): Prisma__WellnessGroupClient<$Result.GetResult<Prisma.$WellnessGroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WellnessGroups.
     * @param {WellnessGroupDeleteManyArgs} args - Arguments to filter WellnessGroups to delete.
     * @example
     * // Delete a few WellnessGroups
     * const { count } = await prisma.wellnessGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WellnessGroupDeleteManyArgs>(args?: SelectSubset<T, WellnessGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WellnessGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellnessGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WellnessGroups
     * const wellnessGroup = await prisma.wellnessGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WellnessGroupUpdateManyArgs>(args: SelectSubset<T, WellnessGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WellnessGroups and returns the data updated in the database.
     * @param {WellnessGroupUpdateManyAndReturnArgs} args - Arguments to update many WellnessGroups.
     * @example
     * // Update many WellnessGroups
     * const wellnessGroup = await prisma.wellnessGroup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WellnessGroups and only return the `id`
     * const wellnessGroupWithIdOnly = await prisma.wellnessGroup.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WellnessGroupUpdateManyAndReturnArgs>(args: SelectSubset<T, WellnessGroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WellnessGroupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WellnessGroup.
     * @param {WellnessGroupUpsertArgs} args - Arguments to update or create a WellnessGroup.
     * @example
     * // Update or create a WellnessGroup
     * const wellnessGroup = await prisma.wellnessGroup.upsert({
     *   create: {
     *     // ... data to create a WellnessGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WellnessGroup we want to update
     *   }
     * })
     */
    upsert<T extends WellnessGroupUpsertArgs>(args: SelectSubset<T, WellnessGroupUpsertArgs<ExtArgs>>): Prisma__WellnessGroupClient<$Result.GetResult<Prisma.$WellnessGroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WellnessGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellnessGroupCountArgs} args - Arguments to filter WellnessGroups to count.
     * @example
     * // Count the number of WellnessGroups
     * const count = await prisma.wellnessGroup.count({
     *   where: {
     *     // ... the filter for the WellnessGroups we want to count
     *   }
     * })
    **/
    count<T extends WellnessGroupCountArgs>(
      args?: Subset<T, WellnessGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WellnessGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WellnessGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellnessGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WellnessGroupAggregateArgs>(args: Subset<T, WellnessGroupAggregateArgs>): Prisma.PrismaPromise<GetWellnessGroupAggregateType<T>>

    /**
     * Group by WellnessGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellnessGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WellnessGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WellnessGroupGroupByArgs['orderBy'] }
        : { orderBy?: WellnessGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WellnessGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWellnessGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WellnessGroup model
   */
  readonly fields: WellnessGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WellnessGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WellnessGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends WellnessGroup$membersArgs<ExtArgs> = {}>(args?: Subset<T, WellnessGroup$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WellnessGroup model
   */
  interface WellnessGroupFieldRefs {
    readonly id: FieldRef<"WellnessGroup", 'String'>
    readonly name: FieldRef<"WellnessGroup", 'String'>
    readonly description: FieldRef<"WellnessGroup", 'String'>
    readonly type: FieldRef<"WellnessGroup", 'String'>
    readonly isPublic: FieldRef<"WellnessGroup", 'Boolean'>
    readonly maxMembers: FieldRef<"WellnessGroup", 'Int'>
    readonly groupGoals: FieldRef<"WellnessGroup", 'Json'>
    readonly createdAt: FieldRef<"WellnessGroup", 'DateTime'>
    readonly updatedAt: FieldRef<"WellnessGroup", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WellnessGroup findUnique
   */
  export type WellnessGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellnessGroup
     */
    select?: WellnessGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellnessGroup
     */
    omit?: WellnessGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellnessGroupInclude<ExtArgs> | null
    /**
     * Filter, which WellnessGroup to fetch.
     */
    where: WellnessGroupWhereUniqueInput
  }

  /**
   * WellnessGroup findUniqueOrThrow
   */
  export type WellnessGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellnessGroup
     */
    select?: WellnessGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellnessGroup
     */
    omit?: WellnessGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellnessGroupInclude<ExtArgs> | null
    /**
     * Filter, which WellnessGroup to fetch.
     */
    where: WellnessGroupWhereUniqueInput
  }

  /**
   * WellnessGroup findFirst
   */
  export type WellnessGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellnessGroup
     */
    select?: WellnessGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellnessGroup
     */
    omit?: WellnessGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellnessGroupInclude<ExtArgs> | null
    /**
     * Filter, which WellnessGroup to fetch.
     */
    where?: WellnessGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WellnessGroups to fetch.
     */
    orderBy?: WellnessGroupOrderByWithRelationInput | WellnessGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WellnessGroups.
     */
    cursor?: WellnessGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WellnessGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WellnessGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WellnessGroups.
     */
    distinct?: WellnessGroupScalarFieldEnum | WellnessGroupScalarFieldEnum[]
  }

  /**
   * WellnessGroup findFirstOrThrow
   */
  export type WellnessGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellnessGroup
     */
    select?: WellnessGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellnessGroup
     */
    omit?: WellnessGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellnessGroupInclude<ExtArgs> | null
    /**
     * Filter, which WellnessGroup to fetch.
     */
    where?: WellnessGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WellnessGroups to fetch.
     */
    orderBy?: WellnessGroupOrderByWithRelationInput | WellnessGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WellnessGroups.
     */
    cursor?: WellnessGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WellnessGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WellnessGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WellnessGroups.
     */
    distinct?: WellnessGroupScalarFieldEnum | WellnessGroupScalarFieldEnum[]
  }

  /**
   * WellnessGroup findMany
   */
  export type WellnessGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellnessGroup
     */
    select?: WellnessGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellnessGroup
     */
    omit?: WellnessGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellnessGroupInclude<ExtArgs> | null
    /**
     * Filter, which WellnessGroups to fetch.
     */
    where?: WellnessGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WellnessGroups to fetch.
     */
    orderBy?: WellnessGroupOrderByWithRelationInput | WellnessGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WellnessGroups.
     */
    cursor?: WellnessGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WellnessGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WellnessGroups.
     */
    skip?: number
    distinct?: WellnessGroupScalarFieldEnum | WellnessGroupScalarFieldEnum[]
  }

  /**
   * WellnessGroup create
   */
  export type WellnessGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellnessGroup
     */
    select?: WellnessGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellnessGroup
     */
    omit?: WellnessGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellnessGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a WellnessGroup.
     */
    data: XOR<WellnessGroupCreateInput, WellnessGroupUncheckedCreateInput>
  }

  /**
   * WellnessGroup createMany
   */
  export type WellnessGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WellnessGroups.
     */
    data: WellnessGroupCreateManyInput | WellnessGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WellnessGroup createManyAndReturn
   */
  export type WellnessGroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellnessGroup
     */
    select?: WellnessGroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WellnessGroup
     */
    omit?: WellnessGroupOmit<ExtArgs> | null
    /**
     * The data used to create many WellnessGroups.
     */
    data: WellnessGroupCreateManyInput | WellnessGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WellnessGroup update
   */
  export type WellnessGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellnessGroup
     */
    select?: WellnessGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellnessGroup
     */
    omit?: WellnessGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellnessGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a WellnessGroup.
     */
    data: XOR<WellnessGroupUpdateInput, WellnessGroupUncheckedUpdateInput>
    /**
     * Choose, which WellnessGroup to update.
     */
    where: WellnessGroupWhereUniqueInput
  }

  /**
   * WellnessGroup updateMany
   */
  export type WellnessGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WellnessGroups.
     */
    data: XOR<WellnessGroupUpdateManyMutationInput, WellnessGroupUncheckedUpdateManyInput>
    /**
     * Filter which WellnessGroups to update
     */
    where?: WellnessGroupWhereInput
    /**
     * Limit how many WellnessGroups to update.
     */
    limit?: number
  }

  /**
   * WellnessGroup updateManyAndReturn
   */
  export type WellnessGroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellnessGroup
     */
    select?: WellnessGroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WellnessGroup
     */
    omit?: WellnessGroupOmit<ExtArgs> | null
    /**
     * The data used to update WellnessGroups.
     */
    data: XOR<WellnessGroupUpdateManyMutationInput, WellnessGroupUncheckedUpdateManyInput>
    /**
     * Filter which WellnessGroups to update
     */
    where?: WellnessGroupWhereInput
    /**
     * Limit how many WellnessGroups to update.
     */
    limit?: number
  }

  /**
   * WellnessGroup upsert
   */
  export type WellnessGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellnessGroup
     */
    select?: WellnessGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellnessGroup
     */
    omit?: WellnessGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellnessGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the WellnessGroup to update in case it exists.
     */
    where: WellnessGroupWhereUniqueInput
    /**
     * In case the WellnessGroup found by the `where` argument doesn't exist, create a new WellnessGroup with this data.
     */
    create: XOR<WellnessGroupCreateInput, WellnessGroupUncheckedCreateInput>
    /**
     * In case the WellnessGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WellnessGroupUpdateInput, WellnessGroupUncheckedUpdateInput>
  }

  /**
   * WellnessGroup delete
   */
  export type WellnessGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellnessGroup
     */
    select?: WellnessGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellnessGroup
     */
    omit?: WellnessGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellnessGroupInclude<ExtArgs> | null
    /**
     * Filter which WellnessGroup to delete.
     */
    where: WellnessGroupWhereUniqueInput
  }

  /**
   * WellnessGroup deleteMany
   */
  export type WellnessGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WellnessGroups to delete
     */
    where?: WellnessGroupWhereInput
    /**
     * Limit how many WellnessGroups to delete.
     */
    limit?: number
  }

  /**
   * WellnessGroup.members
   */
  export type WellnessGroup$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMembership
     */
    select?: GroupMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMembership
     */
    omit?: GroupMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMembershipInclude<ExtArgs> | null
    where?: GroupMembershipWhereInput
    orderBy?: GroupMembershipOrderByWithRelationInput | GroupMembershipOrderByWithRelationInput[]
    cursor?: GroupMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupMembershipScalarFieldEnum | GroupMembershipScalarFieldEnum[]
  }

  /**
   * WellnessGroup without action
   */
  export type WellnessGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellnessGroup
     */
    select?: WellnessGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WellnessGroup
     */
    omit?: WellnessGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellnessGroupInclude<ExtArgs> | null
  }


  /**
   * Model GroupMembership
   */

  export type AggregateGroupMembership = {
    _count: GroupMembershipCountAggregateOutputType | null
    _min: GroupMembershipMinAggregateOutputType | null
    _max: GroupMembershipMaxAggregateOutputType | null
  }

  export type GroupMembershipMinAggregateOutputType = {
    id: string | null
    userId: string | null
    groupId: string | null
    role: string | null
    shareProgress: boolean | null
    shareGoals: boolean | null
    joinedAt: Date | null
  }

  export type GroupMembershipMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    groupId: string | null
    role: string | null
    shareProgress: boolean | null
    shareGoals: boolean | null
    joinedAt: Date | null
  }

  export type GroupMembershipCountAggregateOutputType = {
    id: number
    userId: number
    groupId: number
    role: number
    shareProgress: number
    shareGoals: number
    joinedAt: number
    _all: number
  }


  export type GroupMembershipMinAggregateInputType = {
    id?: true
    userId?: true
    groupId?: true
    role?: true
    shareProgress?: true
    shareGoals?: true
    joinedAt?: true
  }

  export type GroupMembershipMaxAggregateInputType = {
    id?: true
    userId?: true
    groupId?: true
    role?: true
    shareProgress?: true
    shareGoals?: true
    joinedAt?: true
  }

  export type GroupMembershipCountAggregateInputType = {
    id?: true
    userId?: true
    groupId?: true
    role?: true
    shareProgress?: true
    shareGoals?: true
    joinedAt?: true
    _all?: true
  }

  export type GroupMembershipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupMembership to aggregate.
     */
    where?: GroupMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMemberships to fetch.
     */
    orderBy?: GroupMembershipOrderByWithRelationInput | GroupMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GroupMemberships
    **/
    _count?: true | GroupMembershipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupMembershipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupMembershipMaxAggregateInputType
  }

  export type GetGroupMembershipAggregateType<T extends GroupMembershipAggregateArgs> = {
        [P in keyof T & keyof AggregateGroupMembership]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroupMembership[P]>
      : GetScalarType<T[P], AggregateGroupMembership[P]>
  }




  export type GroupMembershipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupMembershipWhereInput
    orderBy?: GroupMembershipOrderByWithAggregationInput | GroupMembershipOrderByWithAggregationInput[]
    by: GroupMembershipScalarFieldEnum[] | GroupMembershipScalarFieldEnum
    having?: GroupMembershipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupMembershipCountAggregateInputType | true
    _min?: GroupMembershipMinAggregateInputType
    _max?: GroupMembershipMaxAggregateInputType
  }

  export type GroupMembershipGroupByOutputType = {
    id: string
    userId: string
    groupId: string
    role: string
    shareProgress: boolean
    shareGoals: boolean
    joinedAt: Date
    _count: GroupMembershipCountAggregateOutputType | null
    _min: GroupMembershipMinAggregateOutputType | null
    _max: GroupMembershipMaxAggregateOutputType | null
  }

  type GetGroupMembershipGroupByPayload<T extends GroupMembershipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupMembershipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupMembershipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupMembershipGroupByOutputType[P]>
            : GetScalarType<T[P], GroupMembershipGroupByOutputType[P]>
        }
      >
    >


  export type GroupMembershipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    groupId?: boolean
    role?: boolean
    shareProgress?: boolean
    shareGoals?: boolean
    joinedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    group?: boolean | WellnessGroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupMembership"]>

  export type GroupMembershipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    groupId?: boolean
    role?: boolean
    shareProgress?: boolean
    shareGoals?: boolean
    joinedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    group?: boolean | WellnessGroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupMembership"]>

  export type GroupMembershipSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    groupId?: boolean
    role?: boolean
    shareProgress?: boolean
    shareGoals?: boolean
    joinedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    group?: boolean | WellnessGroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupMembership"]>

  export type GroupMembershipSelectScalar = {
    id?: boolean
    userId?: boolean
    groupId?: boolean
    role?: boolean
    shareProgress?: boolean
    shareGoals?: boolean
    joinedAt?: boolean
  }

  export type GroupMembershipOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "groupId" | "role" | "shareProgress" | "shareGoals" | "joinedAt", ExtArgs["result"]["groupMembership"]>
  export type GroupMembershipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    group?: boolean | WellnessGroupDefaultArgs<ExtArgs>
  }
  export type GroupMembershipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    group?: boolean | WellnessGroupDefaultArgs<ExtArgs>
  }
  export type GroupMembershipIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    group?: boolean | WellnessGroupDefaultArgs<ExtArgs>
  }

  export type $GroupMembershipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GroupMembership"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      group: Prisma.$WellnessGroupPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      groupId: string
      role: string
      shareProgress: boolean
      shareGoals: boolean
      joinedAt: Date
    }, ExtArgs["result"]["groupMembership"]>
    composites: {}
  }

  type GroupMembershipGetPayload<S extends boolean | null | undefined | GroupMembershipDefaultArgs> = $Result.GetResult<Prisma.$GroupMembershipPayload, S>

  type GroupMembershipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GroupMembershipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GroupMembershipCountAggregateInputType | true
    }

  export interface GroupMembershipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GroupMembership'], meta: { name: 'GroupMembership' } }
    /**
     * Find zero or one GroupMembership that matches the filter.
     * @param {GroupMembershipFindUniqueArgs} args - Arguments to find a GroupMembership
     * @example
     * // Get one GroupMembership
     * const groupMembership = await prisma.groupMembership.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroupMembershipFindUniqueArgs>(args: SelectSubset<T, GroupMembershipFindUniqueArgs<ExtArgs>>): Prisma__GroupMembershipClient<$Result.GetResult<Prisma.$GroupMembershipPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GroupMembership that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GroupMembershipFindUniqueOrThrowArgs} args - Arguments to find a GroupMembership
     * @example
     * // Get one GroupMembership
     * const groupMembership = await prisma.groupMembership.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroupMembershipFindUniqueOrThrowArgs>(args: SelectSubset<T, GroupMembershipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroupMembershipClient<$Result.GetResult<Prisma.$GroupMembershipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GroupMembership that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMembershipFindFirstArgs} args - Arguments to find a GroupMembership
     * @example
     * // Get one GroupMembership
     * const groupMembership = await prisma.groupMembership.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroupMembershipFindFirstArgs>(args?: SelectSubset<T, GroupMembershipFindFirstArgs<ExtArgs>>): Prisma__GroupMembershipClient<$Result.GetResult<Prisma.$GroupMembershipPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GroupMembership that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMembershipFindFirstOrThrowArgs} args - Arguments to find a GroupMembership
     * @example
     * // Get one GroupMembership
     * const groupMembership = await prisma.groupMembership.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroupMembershipFindFirstOrThrowArgs>(args?: SelectSubset<T, GroupMembershipFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroupMembershipClient<$Result.GetResult<Prisma.$GroupMembershipPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GroupMemberships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMembershipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GroupMemberships
     * const groupMemberships = await prisma.groupMembership.findMany()
     * 
     * // Get first 10 GroupMemberships
     * const groupMemberships = await prisma.groupMembership.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupMembershipWithIdOnly = await prisma.groupMembership.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GroupMembershipFindManyArgs>(args?: SelectSubset<T, GroupMembershipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GroupMembership.
     * @param {GroupMembershipCreateArgs} args - Arguments to create a GroupMembership.
     * @example
     * // Create one GroupMembership
     * const GroupMembership = await prisma.groupMembership.create({
     *   data: {
     *     // ... data to create a GroupMembership
     *   }
     * })
     * 
     */
    create<T extends GroupMembershipCreateArgs>(args: SelectSubset<T, GroupMembershipCreateArgs<ExtArgs>>): Prisma__GroupMembershipClient<$Result.GetResult<Prisma.$GroupMembershipPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GroupMemberships.
     * @param {GroupMembershipCreateManyArgs} args - Arguments to create many GroupMemberships.
     * @example
     * // Create many GroupMemberships
     * const groupMembership = await prisma.groupMembership.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroupMembershipCreateManyArgs>(args?: SelectSubset<T, GroupMembershipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GroupMemberships and returns the data saved in the database.
     * @param {GroupMembershipCreateManyAndReturnArgs} args - Arguments to create many GroupMemberships.
     * @example
     * // Create many GroupMemberships
     * const groupMembership = await prisma.groupMembership.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GroupMemberships and only return the `id`
     * const groupMembershipWithIdOnly = await prisma.groupMembership.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GroupMembershipCreateManyAndReturnArgs>(args?: SelectSubset<T, GroupMembershipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMembershipPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GroupMembership.
     * @param {GroupMembershipDeleteArgs} args - Arguments to delete one GroupMembership.
     * @example
     * // Delete one GroupMembership
     * const GroupMembership = await prisma.groupMembership.delete({
     *   where: {
     *     // ... filter to delete one GroupMembership
     *   }
     * })
     * 
     */
    delete<T extends GroupMembershipDeleteArgs>(args: SelectSubset<T, GroupMembershipDeleteArgs<ExtArgs>>): Prisma__GroupMembershipClient<$Result.GetResult<Prisma.$GroupMembershipPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GroupMembership.
     * @param {GroupMembershipUpdateArgs} args - Arguments to update one GroupMembership.
     * @example
     * // Update one GroupMembership
     * const groupMembership = await prisma.groupMembership.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroupMembershipUpdateArgs>(args: SelectSubset<T, GroupMembershipUpdateArgs<ExtArgs>>): Prisma__GroupMembershipClient<$Result.GetResult<Prisma.$GroupMembershipPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GroupMemberships.
     * @param {GroupMembershipDeleteManyArgs} args - Arguments to filter GroupMemberships to delete.
     * @example
     * // Delete a few GroupMemberships
     * const { count } = await prisma.groupMembership.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroupMembershipDeleteManyArgs>(args?: SelectSubset<T, GroupMembershipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMembershipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GroupMemberships
     * const groupMembership = await prisma.groupMembership.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroupMembershipUpdateManyArgs>(args: SelectSubset<T, GroupMembershipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupMemberships and returns the data updated in the database.
     * @param {GroupMembershipUpdateManyAndReturnArgs} args - Arguments to update many GroupMemberships.
     * @example
     * // Update many GroupMemberships
     * const groupMembership = await prisma.groupMembership.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GroupMemberships and only return the `id`
     * const groupMembershipWithIdOnly = await prisma.groupMembership.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GroupMembershipUpdateManyAndReturnArgs>(args: SelectSubset<T, GroupMembershipUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMembershipPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GroupMembership.
     * @param {GroupMembershipUpsertArgs} args - Arguments to update or create a GroupMembership.
     * @example
     * // Update or create a GroupMembership
     * const groupMembership = await prisma.groupMembership.upsert({
     *   create: {
     *     // ... data to create a GroupMembership
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GroupMembership we want to update
     *   }
     * })
     */
    upsert<T extends GroupMembershipUpsertArgs>(args: SelectSubset<T, GroupMembershipUpsertArgs<ExtArgs>>): Prisma__GroupMembershipClient<$Result.GetResult<Prisma.$GroupMembershipPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GroupMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMembershipCountArgs} args - Arguments to filter GroupMemberships to count.
     * @example
     * // Count the number of GroupMemberships
     * const count = await prisma.groupMembership.count({
     *   where: {
     *     // ... the filter for the GroupMemberships we want to count
     *   }
     * })
    **/
    count<T extends GroupMembershipCountArgs>(
      args?: Subset<T, GroupMembershipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupMembershipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GroupMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMembershipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupMembershipAggregateArgs>(args: Subset<T, GroupMembershipAggregateArgs>): Prisma.PrismaPromise<GetGroupMembershipAggregateType<T>>

    /**
     * Group by GroupMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMembershipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupMembershipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupMembershipGroupByArgs['orderBy'] }
        : { orderBy?: GroupMembershipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupMembershipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupMembershipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GroupMembership model
   */
  readonly fields: GroupMembershipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GroupMembership.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupMembershipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    group<T extends WellnessGroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WellnessGroupDefaultArgs<ExtArgs>>): Prisma__WellnessGroupClient<$Result.GetResult<Prisma.$WellnessGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GroupMembership model
   */
  interface GroupMembershipFieldRefs {
    readonly id: FieldRef<"GroupMembership", 'String'>
    readonly userId: FieldRef<"GroupMembership", 'String'>
    readonly groupId: FieldRef<"GroupMembership", 'String'>
    readonly role: FieldRef<"GroupMembership", 'String'>
    readonly shareProgress: FieldRef<"GroupMembership", 'Boolean'>
    readonly shareGoals: FieldRef<"GroupMembership", 'Boolean'>
    readonly joinedAt: FieldRef<"GroupMembership", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GroupMembership findUnique
   */
  export type GroupMembershipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMembership
     */
    select?: GroupMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMembership
     */
    omit?: GroupMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMembershipInclude<ExtArgs> | null
    /**
     * Filter, which GroupMembership to fetch.
     */
    where: GroupMembershipWhereUniqueInput
  }

  /**
   * GroupMembership findUniqueOrThrow
   */
  export type GroupMembershipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMembership
     */
    select?: GroupMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMembership
     */
    omit?: GroupMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMembershipInclude<ExtArgs> | null
    /**
     * Filter, which GroupMembership to fetch.
     */
    where: GroupMembershipWhereUniqueInput
  }

  /**
   * GroupMembership findFirst
   */
  export type GroupMembershipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMembership
     */
    select?: GroupMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMembership
     */
    omit?: GroupMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMembershipInclude<ExtArgs> | null
    /**
     * Filter, which GroupMembership to fetch.
     */
    where?: GroupMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMemberships to fetch.
     */
    orderBy?: GroupMembershipOrderByWithRelationInput | GroupMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupMemberships.
     */
    cursor?: GroupMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupMemberships.
     */
    distinct?: GroupMembershipScalarFieldEnum | GroupMembershipScalarFieldEnum[]
  }

  /**
   * GroupMembership findFirstOrThrow
   */
  export type GroupMembershipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMembership
     */
    select?: GroupMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMembership
     */
    omit?: GroupMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMembershipInclude<ExtArgs> | null
    /**
     * Filter, which GroupMembership to fetch.
     */
    where?: GroupMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMemberships to fetch.
     */
    orderBy?: GroupMembershipOrderByWithRelationInput | GroupMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupMemberships.
     */
    cursor?: GroupMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupMemberships.
     */
    distinct?: GroupMembershipScalarFieldEnum | GroupMembershipScalarFieldEnum[]
  }

  /**
   * GroupMembership findMany
   */
  export type GroupMembershipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMembership
     */
    select?: GroupMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMembership
     */
    omit?: GroupMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMembershipInclude<ExtArgs> | null
    /**
     * Filter, which GroupMemberships to fetch.
     */
    where?: GroupMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMemberships to fetch.
     */
    orderBy?: GroupMembershipOrderByWithRelationInput | GroupMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GroupMemberships.
     */
    cursor?: GroupMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMemberships.
     */
    skip?: number
    distinct?: GroupMembershipScalarFieldEnum | GroupMembershipScalarFieldEnum[]
  }

  /**
   * GroupMembership create
   */
  export type GroupMembershipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMembership
     */
    select?: GroupMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMembership
     */
    omit?: GroupMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMembershipInclude<ExtArgs> | null
    /**
     * The data needed to create a GroupMembership.
     */
    data: XOR<GroupMembershipCreateInput, GroupMembershipUncheckedCreateInput>
  }

  /**
   * GroupMembership createMany
   */
  export type GroupMembershipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GroupMemberships.
     */
    data: GroupMembershipCreateManyInput | GroupMembershipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GroupMembership createManyAndReturn
   */
  export type GroupMembershipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMembership
     */
    select?: GroupMembershipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMembership
     */
    omit?: GroupMembershipOmit<ExtArgs> | null
    /**
     * The data used to create many GroupMemberships.
     */
    data: GroupMembershipCreateManyInput | GroupMembershipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMembershipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GroupMembership update
   */
  export type GroupMembershipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMembership
     */
    select?: GroupMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMembership
     */
    omit?: GroupMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMembershipInclude<ExtArgs> | null
    /**
     * The data needed to update a GroupMembership.
     */
    data: XOR<GroupMembershipUpdateInput, GroupMembershipUncheckedUpdateInput>
    /**
     * Choose, which GroupMembership to update.
     */
    where: GroupMembershipWhereUniqueInput
  }

  /**
   * GroupMembership updateMany
   */
  export type GroupMembershipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GroupMemberships.
     */
    data: XOR<GroupMembershipUpdateManyMutationInput, GroupMembershipUncheckedUpdateManyInput>
    /**
     * Filter which GroupMemberships to update
     */
    where?: GroupMembershipWhereInput
    /**
     * Limit how many GroupMemberships to update.
     */
    limit?: number
  }

  /**
   * GroupMembership updateManyAndReturn
   */
  export type GroupMembershipUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMembership
     */
    select?: GroupMembershipSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMembership
     */
    omit?: GroupMembershipOmit<ExtArgs> | null
    /**
     * The data used to update GroupMemberships.
     */
    data: XOR<GroupMembershipUpdateManyMutationInput, GroupMembershipUncheckedUpdateManyInput>
    /**
     * Filter which GroupMemberships to update
     */
    where?: GroupMembershipWhereInput
    /**
     * Limit how many GroupMemberships to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMembershipIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GroupMembership upsert
   */
  export type GroupMembershipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMembership
     */
    select?: GroupMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMembership
     */
    omit?: GroupMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMembershipInclude<ExtArgs> | null
    /**
     * The filter to search for the GroupMembership to update in case it exists.
     */
    where: GroupMembershipWhereUniqueInput
    /**
     * In case the GroupMembership found by the `where` argument doesn't exist, create a new GroupMembership with this data.
     */
    create: XOR<GroupMembershipCreateInput, GroupMembershipUncheckedCreateInput>
    /**
     * In case the GroupMembership was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupMembershipUpdateInput, GroupMembershipUncheckedUpdateInput>
  }

  /**
   * GroupMembership delete
   */
  export type GroupMembershipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMembership
     */
    select?: GroupMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMembership
     */
    omit?: GroupMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMembershipInclude<ExtArgs> | null
    /**
     * Filter which GroupMembership to delete.
     */
    where: GroupMembershipWhereUniqueInput
  }

  /**
   * GroupMembership deleteMany
   */
  export type GroupMembershipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupMemberships to delete
     */
    where?: GroupMembershipWhereInput
    /**
     * Limit how many GroupMemberships to delete.
     */
    limit?: number
  }

  /**
   * GroupMembership without action
   */
  export type GroupMembershipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMembership
     */
    select?: GroupMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMembership
     */
    omit?: GroupMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMembershipInclude<ExtArgs> | null
  }


  /**
   * Model WorkplaceIntegration
   */

  export type AggregateWorkplaceIntegration = {
    _count: WorkplaceIntegrationCountAggregateOutputType | null
    _min: WorkplaceIntegrationMinAggregateOutputType | null
    _max: WorkplaceIntegrationMaxAggregateOutputType | null
  }

  export type WorkplaceIntegrationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    platform: string | null
    enabled: boolean | null
    frequency: string | null
    canSuggestBreaks: boolean | null
    canAccessCalendar: boolean | null
    canSendReminders: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkplaceIntegrationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    platform: string | null
    enabled: boolean | null
    frequency: string | null
    canSuggestBreaks: boolean | null
    canAccessCalendar: boolean | null
    canSendReminders: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkplaceIntegrationCountAggregateOutputType = {
    id: number
    userId: number
    platform: number
    enabled: number
    frequency: number
    canSuggestBreaks: number
    canAccessCalendar: number
    canSendReminders: number
    workHours: number
    breakPreferences: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkplaceIntegrationMinAggregateInputType = {
    id?: true
    userId?: true
    platform?: true
    enabled?: true
    frequency?: true
    canSuggestBreaks?: true
    canAccessCalendar?: true
    canSendReminders?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkplaceIntegrationMaxAggregateInputType = {
    id?: true
    userId?: true
    platform?: true
    enabled?: true
    frequency?: true
    canSuggestBreaks?: true
    canAccessCalendar?: true
    canSendReminders?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkplaceIntegrationCountAggregateInputType = {
    id?: true
    userId?: true
    platform?: true
    enabled?: true
    frequency?: true
    canSuggestBreaks?: true
    canAccessCalendar?: true
    canSendReminders?: true
    workHours?: true
    breakPreferences?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkplaceIntegrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkplaceIntegration to aggregate.
     */
    where?: WorkplaceIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkplaceIntegrations to fetch.
     */
    orderBy?: WorkplaceIntegrationOrderByWithRelationInput | WorkplaceIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkplaceIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkplaceIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkplaceIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkplaceIntegrations
    **/
    _count?: true | WorkplaceIntegrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkplaceIntegrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkplaceIntegrationMaxAggregateInputType
  }

  export type GetWorkplaceIntegrationAggregateType<T extends WorkplaceIntegrationAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkplaceIntegration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkplaceIntegration[P]>
      : GetScalarType<T[P], AggregateWorkplaceIntegration[P]>
  }




  export type WorkplaceIntegrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkplaceIntegrationWhereInput
    orderBy?: WorkplaceIntegrationOrderByWithAggregationInput | WorkplaceIntegrationOrderByWithAggregationInput[]
    by: WorkplaceIntegrationScalarFieldEnum[] | WorkplaceIntegrationScalarFieldEnum
    having?: WorkplaceIntegrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkplaceIntegrationCountAggregateInputType | true
    _min?: WorkplaceIntegrationMinAggregateInputType
    _max?: WorkplaceIntegrationMaxAggregateInputType
  }

  export type WorkplaceIntegrationGroupByOutputType = {
    id: string
    userId: string
    platform: string
    enabled: boolean
    frequency: string
    canSuggestBreaks: boolean
    canAccessCalendar: boolean
    canSendReminders: boolean
    workHours: JsonValue | null
    breakPreferences: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: WorkplaceIntegrationCountAggregateOutputType | null
    _min: WorkplaceIntegrationMinAggregateOutputType | null
    _max: WorkplaceIntegrationMaxAggregateOutputType | null
  }

  type GetWorkplaceIntegrationGroupByPayload<T extends WorkplaceIntegrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkplaceIntegrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkplaceIntegrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkplaceIntegrationGroupByOutputType[P]>
            : GetScalarType<T[P], WorkplaceIntegrationGroupByOutputType[P]>
        }
      >
    >


  export type WorkplaceIntegrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    platform?: boolean
    enabled?: boolean
    frequency?: boolean
    canSuggestBreaks?: boolean
    canAccessCalendar?: boolean
    canSendReminders?: boolean
    workHours?: boolean
    breakPreferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workplaceIntegration"]>

  export type WorkplaceIntegrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    platform?: boolean
    enabled?: boolean
    frequency?: boolean
    canSuggestBreaks?: boolean
    canAccessCalendar?: boolean
    canSendReminders?: boolean
    workHours?: boolean
    breakPreferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workplaceIntegration"]>

  export type WorkplaceIntegrationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    platform?: boolean
    enabled?: boolean
    frequency?: boolean
    canSuggestBreaks?: boolean
    canAccessCalendar?: boolean
    canSendReminders?: boolean
    workHours?: boolean
    breakPreferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workplaceIntegration"]>

  export type WorkplaceIntegrationSelectScalar = {
    id?: boolean
    userId?: boolean
    platform?: boolean
    enabled?: boolean
    frequency?: boolean
    canSuggestBreaks?: boolean
    canAccessCalendar?: boolean
    canSendReminders?: boolean
    workHours?: boolean
    breakPreferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WorkplaceIntegrationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "platform" | "enabled" | "frequency" | "canSuggestBreaks" | "canAccessCalendar" | "canSendReminders" | "workHours" | "breakPreferences" | "createdAt" | "updatedAt", ExtArgs["result"]["workplaceIntegration"]>
  export type WorkplaceIntegrationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WorkplaceIntegrationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WorkplaceIntegrationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WorkplaceIntegrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkplaceIntegration"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      platform: string
      enabled: boolean
      frequency: string
      canSuggestBreaks: boolean
      canAccessCalendar: boolean
      canSendReminders: boolean
      workHours: Prisma.JsonValue | null
      breakPreferences: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["workplaceIntegration"]>
    composites: {}
  }

  type WorkplaceIntegrationGetPayload<S extends boolean | null | undefined | WorkplaceIntegrationDefaultArgs> = $Result.GetResult<Prisma.$WorkplaceIntegrationPayload, S>

  type WorkplaceIntegrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkplaceIntegrationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkplaceIntegrationCountAggregateInputType | true
    }

  export interface WorkplaceIntegrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkplaceIntegration'], meta: { name: 'WorkplaceIntegration' } }
    /**
     * Find zero or one WorkplaceIntegration that matches the filter.
     * @param {WorkplaceIntegrationFindUniqueArgs} args - Arguments to find a WorkplaceIntegration
     * @example
     * // Get one WorkplaceIntegration
     * const workplaceIntegration = await prisma.workplaceIntegration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkplaceIntegrationFindUniqueArgs>(args: SelectSubset<T, WorkplaceIntegrationFindUniqueArgs<ExtArgs>>): Prisma__WorkplaceIntegrationClient<$Result.GetResult<Prisma.$WorkplaceIntegrationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkplaceIntegration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkplaceIntegrationFindUniqueOrThrowArgs} args - Arguments to find a WorkplaceIntegration
     * @example
     * // Get one WorkplaceIntegration
     * const workplaceIntegration = await prisma.workplaceIntegration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkplaceIntegrationFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkplaceIntegrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkplaceIntegrationClient<$Result.GetResult<Prisma.$WorkplaceIntegrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkplaceIntegration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkplaceIntegrationFindFirstArgs} args - Arguments to find a WorkplaceIntegration
     * @example
     * // Get one WorkplaceIntegration
     * const workplaceIntegration = await prisma.workplaceIntegration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkplaceIntegrationFindFirstArgs>(args?: SelectSubset<T, WorkplaceIntegrationFindFirstArgs<ExtArgs>>): Prisma__WorkplaceIntegrationClient<$Result.GetResult<Prisma.$WorkplaceIntegrationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkplaceIntegration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkplaceIntegrationFindFirstOrThrowArgs} args - Arguments to find a WorkplaceIntegration
     * @example
     * // Get one WorkplaceIntegration
     * const workplaceIntegration = await prisma.workplaceIntegration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkplaceIntegrationFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkplaceIntegrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkplaceIntegrationClient<$Result.GetResult<Prisma.$WorkplaceIntegrationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkplaceIntegrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkplaceIntegrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkplaceIntegrations
     * const workplaceIntegrations = await prisma.workplaceIntegration.findMany()
     * 
     * // Get first 10 WorkplaceIntegrations
     * const workplaceIntegrations = await prisma.workplaceIntegration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workplaceIntegrationWithIdOnly = await prisma.workplaceIntegration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkplaceIntegrationFindManyArgs>(args?: SelectSubset<T, WorkplaceIntegrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkplaceIntegrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkplaceIntegration.
     * @param {WorkplaceIntegrationCreateArgs} args - Arguments to create a WorkplaceIntegration.
     * @example
     * // Create one WorkplaceIntegration
     * const WorkplaceIntegration = await prisma.workplaceIntegration.create({
     *   data: {
     *     // ... data to create a WorkplaceIntegration
     *   }
     * })
     * 
     */
    create<T extends WorkplaceIntegrationCreateArgs>(args: SelectSubset<T, WorkplaceIntegrationCreateArgs<ExtArgs>>): Prisma__WorkplaceIntegrationClient<$Result.GetResult<Prisma.$WorkplaceIntegrationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkplaceIntegrations.
     * @param {WorkplaceIntegrationCreateManyArgs} args - Arguments to create many WorkplaceIntegrations.
     * @example
     * // Create many WorkplaceIntegrations
     * const workplaceIntegration = await prisma.workplaceIntegration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkplaceIntegrationCreateManyArgs>(args?: SelectSubset<T, WorkplaceIntegrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkplaceIntegrations and returns the data saved in the database.
     * @param {WorkplaceIntegrationCreateManyAndReturnArgs} args - Arguments to create many WorkplaceIntegrations.
     * @example
     * // Create many WorkplaceIntegrations
     * const workplaceIntegration = await prisma.workplaceIntegration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkplaceIntegrations and only return the `id`
     * const workplaceIntegrationWithIdOnly = await prisma.workplaceIntegration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkplaceIntegrationCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkplaceIntegrationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkplaceIntegrationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkplaceIntegration.
     * @param {WorkplaceIntegrationDeleteArgs} args - Arguments to delete one WorkplaceIntegration.
     * @example
     * // Delete one WorkplaceIntegration
     * const WorkplaceIntegration = await prisma.workplaceIntegration.delete({
     *   where: {
     *     // ... filter to delete one WorkplaceIntegration
     *   }
     * })
     * 
     */
    delete<T extends WorkplaceIntegrationDeleteArgs>(args: SelectSubset<T, WorkplaceIntegrationDeleteArgs<ExtArgs>>): Prisma__WorkplaceIntegrationClient<$Result.GetResult<Prisma.$WorkplaceIntegrationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkplaceIntegration.
     * @param {WorkplaceIntegrationUpdateArgs} args - Arguments to update one WorkplaceIntegration.
     * @example
     * // Update one WorkplaceIntegration
     * const workplaceIntegration = await prisma.workplaceIntegration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkplaceIntegrationUpdateArgs>(args: SelectSubset<T, WorkplaceIntegrationUpdateArgs<ExtArgs>>): Prisma__WorkplaceIntegrationClient<$Result.GetResult<Prisma.$WorkplaceIntegrationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkplaceIntegrations.
     * @param {WorkplaceIntegrationDeleteManyArgs} args - Arguments to filter WorkplaceIntegrations to delete.
     * @example
     * // Delete a few WorkplaceIntegrations
     * const { count } = await prisma.workplaceIntegration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkplaceIntegrationDeleteManyArgs>(args?: SelectSubset<T, WorkplaceIntegrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkplaceIntegrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkplaceIntegrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkplaceIntegrations
     * const workplaceIntegration = await prisma.workplaceIntegration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkplaceIntegrationUpdateManyArgs>(args: SelectSubset<T, WorkplaceIntegrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkplaceIntegrations and returns the data updated in the database.
     * @param {WorkplaceIntegrationUpdateManyAndReturnArgs} args - Arguments to update many WorkplaceIntegrations.
     * @example
     * // Update many WorkplaceIntegrations
     * const workplaceIntegration = await prisma.workplaceIntegration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkplaceIntegrations and only return the `id`
     * const workplaceIntegrationWithIdOnly = await prisma.workplaceIntegration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkplaceIntegrationUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkplaceIntegrationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkplaceIntegrationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkplaceIntegration.
     * @param {WorkplaceIntegrationUpsertArgs} args - Arguments to update or create a WorkplaceIntegration.
     * @example
     * // Update or create a WorkplaceIntegration
     * const workplaceIntegration = await prisma.workplaceIntegration.upsert({
     *   create: {
     *     // ... data to create a WorkplaceIntegration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkplaceIntegration we want to update
     *   }
     * })
     */
    upsert<T extends WorkplaceIntegrationUpsertArgs>(args: SelectSubset<T, WorkplaceIntegrationUpsertArgs<ExtArgs>>): Prisma__WorkplaceIntegrationClient<$Result.GetResult<Prisma.$WorkplaceIntegrationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkplaceIntegrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkplaceIntegrationCountArgs} args - Arguments to filter WorkplaceIntegrations to count.
     * @example
     * // Count the number of WorkplaceIntegrations
     * const count = await prisma.workplaceIntegration.count({
     *   where: {
     *     // ... the filter for the WorkplaceIntegrations we want to count
     *   }
     * })
    **/
    count<T extends WorkplaceIntegrationCountArgs>(
      args?: Subset<T, WorkplaceIntegrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkplaceIntegrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkplaceIntegration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkplaceIntegrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkplaceIntegrationAggregateArgs>(args: Subset<T, WorkplaceIntegrationAggregateArgs>): Prisma.PrismaPromise<GetWorkplaceIntegrationAggregateType<T>>

    /**
     * Group by WorkplaceIntegration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkplaceIntegrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkplaceIntegrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkplaceIntegrationGroupByArgs['orderBy'] }
        : { orderBy?: WorkplaceIntegrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkplaceIntegrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkplaceIntegrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkplaceIntegration model
   */
  readonly fields: WorkplaceIntegrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkplaceIntegration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkplaceIntegrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkplaceIntegration model
   */
  interface WorkplaceIntegrationFieldRefs {
    readonly id: FieldRef<"WorkplaceIntegration", 'String'>
    readonly userId: FieldRef<"WorkplaceIntegration", 'String'>
    readonly platform: FieldRef<"WorkplaceIntegration", 'String'>
    readonly enabled: FieldRef<"WorkplaceIntegration", 'Boolean'>
    readonly frequency: FieldRef<"WorkplaceIntegration", 'String'>
    readonly canSuggestBreaks: FieldRef<"WorkplaceIntegration", 'Boolean'>
    readonly canAccessCalendar: FieldRef<"WorkplaceIntegration", 'Boolean'>
    readonly canSendReminders: FieldRef<"WorkplaceIntegration", 'Boolean'>
    readonly workHours: FieldRef<"WorkplaceIntegration", 'Json'>
    readonly breakPreferences: FieldRef<"WorkplaceIntegration", 'Json'>
    readonly createdAt: FieldRef<"WorkplaceIntegration", 'DateTime'>
    readonly updatedAt: FieldRef<"WorkplaceIntegration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkplaceIntegration findUnique
   */
  export type WorkplaceIntegrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkplaceIntegration
     */
    select?: WorkplaceIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkplaceIntegration
     */
    omit?: WorkplaceIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkplaceIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which WorkplaceIntegration to fetch.
     */
    where: WorkplaceIntegrationWhereUniqueInput
  }

  /**
   * WorkplaceIntegration findUniqueOrThrow
   */
  export type WorkplaceIntegrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkplaceIntegration
     */
    select?: WorkplaceIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkplaceIntegration
     */
    omit?: WorkplaceIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkplaceIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which WorkplaceIntegration to fetch.
     */
    where: WorkplaceIntegrationWhereUniqueInput
  }

  /**
   * WorkplaceIntegration findFirst
   */
  export type WorkplaceIntegrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkplaceIntegration
     */
    select?: WorkplaceIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkplaceIntegration
     */
    omit?: WorkplaceIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkplaceIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which WorkplaceIntegration to fetch.
     */
    where?: WorkplaceIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkplaceIntegrations to fetch.
     */
    orderBy?: WorkplaceIntegrationOrderByWithRelationInput | WorkplaceIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkplaceIntegrations.
     */
    cursor?: WorkplaceIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkplaceIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkplaceIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkplaceIntegrations.
     */
    distinct?: WorkplaceIntegrationScalarFieldEnum | WorkplaceIntegrationScalarFieldEnum[]
  }

  /**
   * WorkplaceIntegration findFirstOrThrow
   */
  export type WorkplaceIntegrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkplaceIntegration
     */
    select?: WorkplaceIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkplaceIntegration
     */
    omit?: WorkplaceIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkplaceIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which WorkplaceIntegration to fetch.
     */
    where?: WorkplaceIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkplaceIntegrations to fetch.
     */
    orderBy?: WorkplaceIntegrationOrderByWithRelationInput | WorkplaceIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkplaceIntegrations.
     */
    cursor?: WorkplaceIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkplaceIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkplaceIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkplaceIntegrations.
     */
    distinct?: WorkplaceIntegrationScalarFieldEnum | WorkplaceIntegrationScalarFieldEnum[]
  }

  /**
   * WorkplaceIntegration findMany
   */
  export type WorkplaceIntegrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkplaceIntegration
     */
    select?: WorkplaceIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkplaceIntegration
     */
    omit?: WorkplaceIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkplaceIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which WorkplaceIntegrations to fetch.
     */
    where?: WorkplaceIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkplaceIntegrations to fetch.
     */
    orderBy?: WorkplaceIntegrationOrderByWithRelationInput | WorkplaceIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkplaceIntegrations.
     */
    cursor?: WorkplaceIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkplaceIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkplaceIntegrations.
     */
    skip?: number
    distinct?: WorkplaceIntegrationScalarFieldEnum | WorkplaceIntegrationScalarFieldEnum[]
  }

  /**
   * WorkplaceIntegration create
   */
  export type WorkplaceIntegrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkplaceIntegration
     */
    select?: WorkplaceIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkplaceIntegration
     */
    omit?: WorkplaceIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkplaceIntegrationInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkplaceIntegration.
     */
    data: XOR<WorkplaceIntegrationCreateInput, WorkplaceIntegrationUncheckedCreateInput>
  }

  /**
   * WorkplaceIntegration createMany
   */
  export type WorkplaceIntegrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkplaceIntegrations.
     */
    data: WorkplaceIntegrationCreateManyInput | WorkplaceIntegrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkplaceIntegration createManyAndReturn
   */
  export type WorkplaceIntegrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkplaceIntegration
     */
    select?: WorkplaceIntegrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkplaceIntegration
     */
    omit?: WorkplaceIntegrationOmit<ExtArgs> | null
    /**
     * The data used to create many WorkplaceIntegrations.
     */
    data: WorkplaceIntegrationCreateManyInput | WorkplaceIntegrationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkplaceIntegrationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkplaceIntegration update
   */
  export type WorkplaceIntegrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkplaceIntegration
     */
    select?: WorkplaceIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkplaceIntegration
     */
    omit?: WorkplaceIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkplaceIntegrationInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkplaceIntegration.
     */
    data: XOR<WorkplaceIntegrationUpdateInput, WorkplaceIntegrationUncheckedUpdateInput>
    /**
     * Choose, which WorkplaceIntegration to update.
     */
    where: WorkplaceIntegrationWhereUniqueInput
  }

  /**
   * WorkplaceIntegration updateMany
   */
  export type WorkplaceIntegrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkplaceIntegrations.
     */
    data: XOR<WorkplaceIntegrationUpdateManyMutationInput, WorkplaceIntegrationUncheckedUpdateManyInput>
    /**
     * Filter which WorkplaceIntegrations to update
     */
    where?: WorkplaceIntegrationWhereInput
    /**
     * Limit how many WorkplaceIntegrations to update.
     */
    limit?: number
  }

  /**
   * WorkplaceIntegration updateManyAndReturn
   */
  export type WorkplaceIntegrationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkplaceIntegration
     */
    select?: WorkplaceIntegrationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkplaceIntegration
     */
    omit?: WorkplaceIntegrationOmit<ExtArgs> | null
    /**
     * The data used to update WorkplaceIntegrations.
     */
    data: XOR<WorkplaceIntegrationUpdateManyMutationInput, WorkplaceIntegrationUncheckedUpdateManyInput>
    /**
     * Filter which WorkplaceIntegrations to update
     */
    where?: WorkplaceIntegrationWhereInput
    /**
     * Limit how many WorkplaceIntegrations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkplaceIntegrationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkplaceIntegration upsert
   */
  export type WorkplaceIntegrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkplaceIntegration
     */
    select?: WorkplaceIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkplaceIntegration
     */
    omit?: WorkplaceIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkplaceIntegrationInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkplaceIntegration to update in case it exists.
     */
    where: WorkplaceIntegrationWhereUniqueInput
    /**
     * In case the WorkplaceIntegration found by the `where` argument doesn't exist, create a new WorkplaceIntegration with this data.
     */
    create: XOR<WorkplaceIntegrationCreateInput, WorkplaceIntegrationUncheckedCreateInput>
    /**
     * In case the WorkplaceIntegration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkplaceIntegrationUpdateInput, WorkplaceIntegrationUncheckedUpdateInput>
  }

  /**
   * WorkplaceIntegration delete
   */
  export type WorkplaceIntegrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkplaceIntegration
     */
    select?: WorkplaceIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkplaceIntegration
     */
    omit?: WorkplaceIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkplaceIntegrationInclude<ExtArgs> | null
    /**
     * Filter which WorkplaceIntegration to delete.
     */
    where: WorkplaceIntegrationWhereUniqueInput
  }

  /**
   * WorkplaceIntegration deleteMany
   */
  export type WorkplaceIntegrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkplaceIntegrations to delete
     */
    where?: WorkplaceIntegrationWhereInput
    /**
     * Limit how many WorkplaceIntegrations to delete.
     */
    limit?: number
  }

  /**
   * WorkplaceIntegration without action
   */
  export type WorkplaceIntegrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkplaceIntegration
     */
    select?: WorkplaceIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkplaceIntegration
     */
    omit?: WorkplaceIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkplaceIntegrationInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    timezone: 'timezone',
    preferences: 'preferences',
    aiCoachEnabled: 'aiCoachEnabled',
    biometricSyncEnabled: 'biometricSyncEnabled',
    baseStressLevel: 'baseStressLevel',
    sleepGoal: 'sleepGoal',
    stepsGoal: 'stepsGoal',
    workSchedule: 'workSchedule',
    personalityProfile: 'personalityProfile'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    expiresAt: 'expiresAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    accountId: 'accountId',
    providerId: 'providerId',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    accessTokenExpiresAt: 'accessTokenExpiresAt',
    refreshTokenExpiresAt: 'refreshTokenExpiresAt',
    scope: 'scope',
    idToken: 'idToken',
    password: 'password',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const VerificationScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    value: 'value',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VerificationScalarFieldEnum = (typeof VerificationScalarFieldEnum)[keyof typeof VerificationScalarFieldEnum]


  export const JournalEntryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    content: 'content',
    date: 'date',
    mood: 'mood',
    stressLevel: 'stressLevel',
    emotionScores: 'emotionScores',
    topics: 'topics',
    sentiment: 'sentiment',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type JournalEntryScalarFieldEnum = (typeof JournalEntryScalarFieldEnum)[keyof typeof JournalEntryScalarFieldEnum]


  export const HabitScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    isCompleted: 'isCompleted',
    date: 'date',
    aiSuggested: 'aiSuggested',
    adaptiveReminder: 'adaptiveReminder',
    difficultyLevel: 'difficultyLevel',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HabitScalarFieldEnum = (typeof HabitScalarFieldEnum)[keyof typeof HabitScalarFieldEnum]


  export const ClassScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    startTime: 'startTime',
    durationMins: 'durationMins',
    instructor: 'instructor',
    imageUrl: 'imageUrl',
    capacity: 'capacity',
    intensity: 'intensity',
    stressLevel: 'stressLevel',
    aiOptimized: 'aiOptimized',
    adaptiveContent: 'adaptiveContent',
    prerequisites: 'prerequisites',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClassScalarFieldEnum = (typeof ClassScalarFieldEnum)[keyof typeof ClassScalarFieldEnum]


  export const BookingScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    classId: 'classId',
    aiSuggested: 'aiSuggested',
    predictedEffectiveness: 'predictedEffectiveness',
    createdAt: 'createdAt'
  };

  export type BookingScalarFieldEnum = (typeof BookingScalarFieldEnum)[keyof typeof BookingScalarFieldEnum]


  export const BiometricDataScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    heartRate: 'heartRate',
    heartRateVariability: 'heartRateVariability',
    stressLevel: 'stressLevel',
    sleepQuality: 'sleepQuality',
    sleepDuration: 'sleepDuration',
    steps: 'steps',
    calories: 'calories',
    respiratoryRate: 'respiratoryRate',
    skinTemperature: 'skinTemperature',
    bloodPressureSystolic: 'bloodPressureSystolic',
    bloodPressureDiastolic: 'bloodPressureDiastolic',
    oxygenSaturation: 'oxygenSaturation',
    wellnessScore: 'wellnessScore',
    energyLevel: 'energyLevel',
    recoveryScore: 'recoveryScore',
    deviceType: 'deviceType',
    deviceId: 'deviceId',
    accuracy: 'accuracy',
    timestamp: 'timestamp',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BiometricDataScalarFieldEnum = (typeof BiometricDataScalarFieldEnum)[keyof typeof BiometricDataScalarFieldEnum]


  export const MoodEntryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    mood: 'mood',
    confidence: 'confidence',
    source: 'source',
    emotions: 'emotions',
    valence: 'valence',
    arousal: 'arousal',
    location: 'location',
    weather: 'weather',
    timeOfDay: 'timeOfDay',
    activity: 'activity',
    voiceFeatures: 'voiceFeatures',
    timestamp: 'timestamp',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MoodEntryScalarFieldEnum = (typeof MoodEntryScalarFieldEnum)[keyof typeof MoodEntryScalarFieldEnum]


  export const StressPredictionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    predictedStressLevel: 'predictedStressLevel',
    confidence: 'confidence',
    predictedAt: 'predictedAt',
    modelVersion: 'modelVersion',
    triggers: 'triggers',
    riskFactors: 'riskFactors',
    recommendedInterventions: 'recommendedInterventions',
    preventionStrategies: 'preventionStrategies',
    actualStressLevel: 'actualStressLevel',
    wasAccurate: 'wasAccurate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StressPredictionScalarFieldEnum = (typeof StressPredictionScalarFieldEnum)[keyof typeof StressPredictionScalarFieldEnum]


  export const WellnessChallengeScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    type: 'type',
    duration: 'duration',
    target: 'target',
    reward: 'reward',
    isActive: 'isActive',
    startDate: 'startDate',
    endDate: 'endDate',
    maxParticipants: 'maxParticipants',
    isPublic: 'isPublic',
    teamBased: 'teamBased',
    aiGenerated: 'aiGenerated',
    adaptiveDifficulty: 'adaptiveDifficulty',
    personalizedGoals: 'personalizedGoals',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WellnessChallengeScalarFieldEnum = (typeof WellnessChallengeScalarFieldEnum)[keyof typeof WellnessChallengeScalarFieldEnum]


  export const ChallengeParticipantScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    challengeId: 'challengeId',
    progress: 'progress',
    completed: 'completed',
    currentStreak: 'currentStreak',
    bestStreak: 'bestStreak',
    rank: 'rank',
    joinedAt: 'joinedAt',
    completedAt: 'completedAt'
  };

  export type ChallengeParticipantScalarFieldEnum = (typeof ChallengeParticipantScalarFieldEnum)[keyof typeof ChallengeParticipantScalarFieldEnum]


  export const AIRecommendationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    title: 'title',
    description: 'description',
    priority: 'priority',
    reasoning: 'reasoning',
    actionUrl: 'actionUrl',
    duration: 'duration',
    intensity: 'intensity',
    triggeredBy: 'triggeredBy',
    biometricState: 'biometricState',
    effectivenessScore: 'effectivenessScore',
    isRead: 'isRead',
    isCompleted: 'isCompleted',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt',
    completedAt: 'completedAt'
  };

  export type AIRecommendationScalarFieldEnum = (typeof AIRecommendationScalarFieldEnum)[keyof typeof AIRecommendationScalarFieldEnum]


  export const DeviceConnectionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    deviceType: 'deviceType',
    deviceId: 'deviceId',
    deviceName: 'deviceName',
    isConnected: 'isConnected',
    lastSync: 'lastSync',
    syncInterval: 'syncInterval',
    reliability: 'reliability',
    batteryLevel: 'batteryLevel',
    signalStrength: 'signalStrength',
    permissions: 'permissions',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DeviceConnectionScalarFieldEnum = (typeof DeviceConnectionScalarFieldEnum)[keyof typeof DeviceConnectionScalarFieldEnum]


  export const WellnessSessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    sessionType: 'sessionType',
    title: 'title',
    duration: 'duration',
    startingStress: 'startingStress',
    endingStress: 'endingStress',
    adaptations: 'adaptations',
    avgHeartRate: 'avgHeartRate',
    stressReduction: 'stressReduction',
    userRating: 'userRating',
    completionRate: 'completionRate',
    startedAt: 'startedAt',
    completedAt: 'completedAt'
  };

  export type WellnessSessionScalarFieldEnum = (typeof WellnessSessionScalarFieldEnum)[keyof typeof WellnessSessionScalarFieldEnum]


  export const EnvironmentalDataScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    location: 'location',
    timezone: 'timezone',
    temperature: 'temperature',
    humidity: 'humidity',
    pressure: 'pressure',
    weather: 'weather',
    airQuality: 'airQuality',
    pollutants: 'pollutants',
    lightLevel: 'lightLevel',
    uvIndex: 'uvIndex',
    noiseLevel: 'noiseLevel',
    timestamp: 'timestamp'
  };

  export type EnvironmentalDataScalarFieldEnum = (typeof EnvironmentalDataScalarFieldEnum)[keyof typeof EnvironmentalDataScalarFieldEnum]


  export const WellnessGroupScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    type: 'type',
    isPublic: 'isPublic',
    maxMembers: 'maxMembers',
    groupGoals: 'groupGoals',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WellnessGroupScalarFieldEnum = (typeof WellnessGroupScalarFieldEnum)[keyof typeof WellnessGroupScalarFieldEnum]


  export const GroupMembershipScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    groupId: 'groupId',
    role: 'role',
    shareProgress: 'shareProgress',
    shareGoals: 'shareGoals',
    joinedAt: 'joinedAt'
  };

  export type GroupMembershipScalarFieldEnum = (typeof GroupMembershipScalarFieldEnum)[keyof typeof GroupMembershipScalarFieldEnum]


  export const WorkplaceIntegrationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    platform: 'platform',
    enabled: 'enabled',
    frequency: 'frequency',
    canSuggestBreaks: 'canSuggestBreaks',
    canAccessCalendar: 'canAccessCalendar',
    canSendReminders: 'canSendReminders',
    workHours: 'workHours',
    breakPreferences: 'breakPreferences',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkplaceIntegrationScalarFieldEnum = (typeof WorkplaceIntegrationScalarFieldEnum)[keyof typeof WorkplaceIntegrationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    image?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    timezone?: StringFilter<"User"> | string
    preferences?: JsonNullableFilter<"User">
    aiCoachEnabled?: BoolFilter<"User"> | boolean
    biometricSyncEnabled?: BoolFilter<"User"> | boolean
    baseStressLevel?: IntNullableFilter<"User"> | number | null
    sleepGoal?: FloatNullableFilter<"User"> | number | null
    stepsGoal?: IntNullableFilter<"User"> | number | null
    workSchedule?: JsonNullableFilter<"User">
    personalityProfile?: JsonNullableFilter<"User">
    sessions?: SessionListRelationFilter
    account?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    journalEntries?: JournalEntryListRelationFilter
    habits?: HabitListRelationFilter
    bookings?: BookingListRelationFilter
    biometricData?: BiometricDataListRelationFilter
    moodEntries?: MoodEntryListRelationFilter
    stressPredictions?: StressPredictionListRelationFilter
    challengeParticipants?: ChallengeParticipantListRelationFilter
    aiRecommendations?: AIRecommendationListRelationFilter
    deviceConnections?: DeviceConnectionListRelationFilter
    wellnessSessions?: WellnessSessionListRelationFilter
    environmentalData?: EnvironmentalDataListRelationFilter
    collaborativeGroups?: GroupMembershipListRelationFilter
    workplaceIntegrations?: WorkplaceIntegrationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    timezone?: SortOrder
    preferences?: SortOrderInput | SortOrder
    aiCoachEnabled?: SortOrder
    biometricSyncEnabled?: SortOrder
    baseStressLevel?: SortOrderInput | SortOrder
    sleepGoal?: SortOrderInput | SortOrder
    stepsGoal?: SortOrderInput | SortOrder
    workSchedule?: SortOrderInput | SortOrder
    personalityProfile?: SortOrderInput | SortOrder
    sessions?: SessionOrderByRelationAggregateInput
    account?: AccountOrderByWithRelationInput
    journalEntries?: JournalEntryOrderByRelationAggregateInput
    habits?: HabitOrderByRelationAggregateInput
    bookings?: BookingOrderByRelationAggregateInput
    biometricData?: BiometricDataOrderByRelationAggregateInput
    moodEntries?: MoodEntryOrderByRelationAggregateInput
    stressPredictions?: StressPredictionOrderByRelationAggregateInput
    challengeParticipants?: ChallengeParticipantOrderByRelationAggregateInput
    aiRecommendations?: AIRecommendationOrderByRelationAggregateInput
    deviceConnections?: DeviceConnectionOrderByRelationAggregateInput
    wellnessSessions?: WellnessSessionOrderByRelationAggregateInput
    environmentalData?: EnvironmentalDataOrderByRelationAggregateInput
    collaborativeGroups?: GroupMembershipOrderByRelationAggregateInput
    workplaceIntegrations?: WorkplaceIntegrationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    emailVerified?: BoolFilter<"User"> | boolean
    image?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    timezone?: StringFilter<"User"> | string
    preferences?: JsonNullableFilter<"User">
    aiCoachEnabled?: BoolFilter<"User"> | boolean
    biometricSyncEnabled?: BoolFilter<"User"> | boolean
    baseStressLevel?: IntNullableFilter<"User"> | number | null
    sleepGoal?: FloatNullableFilter<"User"> | number | null
    stepsGoal?: IntNullableFilter<"User"> | number | null
    workSchedule?: JsonNullableFilter<"User">
    personalityProfile?: JsonNullableFilter<"User">
    sessions?: SessionListRelationFilter
    account?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    journalEntries?: JournalEntryListRelationFilter
    habits?: HabitListRelationFilter
    bookings?: BookingListRelationFilter
    biometricData?: BiometricDataListRelationFilter
    moodEntries?: MoodEntryListRelationFilter
    stressPredictions?: StressPredictionListRelationFilter
    challengeParticipants?: ChallengeParticipantListRelationFilter
    aiRecommendations?: AIRecommendationListRelationFilter
    deviceConnections?: DeviceConnectionListRelationFilter
    wellnessSessions?: WellnessSessionListRelationFilter
    environmentalData?: EnvironmentalDataListRelationFilter
    collaborativeGroups?: GroupMembershipListRelationFilter
    workplaceIntegrations?: WorkplaceIntegrationListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    timezone?: SortOrder
    preferences?: SortOrderInput | SortOrder
    aiCoachEnabled?: SortOrder
    biometricSyncEnabled?: SortOrder
    baseStressLevel?: SortOrderInput | SortOrder
    sleepGoal?: SortOrderInput | SortOrder
    stepsGoal?: SortOrderInput | SortOrder
    workSchedule?: SortOrderInput | SortOrder
    personalityProfile?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    timezone?: StringWithAggregatesFilter<"User"> | string
    preferences?: JsonNullableWithAggregatesFilter<"User">
    aiCoachEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    biometricSyncEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    baseStressLevel?: IntNullableWithAggregatesFilter<"User"> | number | null
    sleepGoal?: FloatNullableWithAggregatesFilter<"User"> | number | null
    stepsGoal?: IntNullableWithAggregatesFilter<"User"> | number | null
    workSchedule?: JsonNullableWithAggregatesFilter<"User">
    personalityProfile?: JsonNullableWithAggregatesFilter<"User">
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    token?: StringWithAggregatesFilter<"Session"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    expiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    expiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    accountId?: StringWithAggregatesFilter<"Account"> | string
    providerId?: StringWithAggregatesFilter<"Account"> | string
    accessToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    idToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    password?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type VerificationWhereInput = {
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    id?: StringFilter<"Verification"> | string
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeFilter<"Verification"> | Date | string
    updatedAt?: DateTimeFilter<"Verification"> | Date | string
  }

  export type VerificationOrderByWithRelationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeFilter<"Verification"> | Date | string
    updatedAt?: DateTimeFilter<"Verification"> | Date | string
  }, "id">

  export type VerificationOrderByWithAggregationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VerificationCountOrderByAggregateInput
    _max?: VerificationMaxOrderByAggregateInput
    _min?: VerificationMinOrderByAggregateInput
  }

  export type VerificationScalarWhereWithAggregatesInput = {
    AND?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    OR?: VerificationScalarWhereWithAggregatesInput[]
    NOT?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Verification"> | string
    identifier?: StringWithAggregatesFilter<"Verification"> | string
    value?: StringWithAggregatesFilter<"Verification"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
  }

  export type JournalEntryWhereInput = {
    AND?: JournalEntryWhereInput | JournalEntryWhereInput[]
    OR?: JournalEntryWhereInput[]
    NOT?: JournalEntryWhereInput | JournalEntryWhereInput[]
    id?: StringFilter<"JournalEntry"> | string
    userId?: StringFilter<"JournalEntry"> | string
    content?: StringFilter<"JournalEntry"> | string
    date?: DateTimeFilter<"JournalEntry"> | Date | string
    mood?: StringNullableFilter<"JournalEntry"> | string | null
    stressLevel?: IntNullableFilter<"JournalEntry"> | number | null
    emotionScores?: JsonNullableFilter<"JournalEntry">
    topics?: JsonNullableFilter<"JournalEntry">
    sentiment?: FloatNullableFilter<"JournalEntry"> | number | null
    createdAt?: DateTimeFilter<"JournalEntry"> | Date | string
    updatedAt?: DateTimeFilter<"JournalEntry"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type JournalEntryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    date?: SortOrder
    mood?: SortOrderInput | SortOrder
    stressLevel?: SortOrderInput | SortOrder
    emotionScores?: SortOrderInput | SortOrder
    topics?: SortOrderInput | SortOrder
    sentiment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type JournalEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_date?: JournalEntryUserIdDateCompoundUniqueInput
    AND?: JournalEntryWhereInput | JournalEntryWhereInput[]
    OR?: JournalEntryWhereInput[]
    NOT?: JournalEntryWhereInput | JournalEntryWhereInput[]
    userId?: StringFilter<"JournalEntry"> | string
    content?: StringFilter<"JournalEntry"> | string
    date?: DateTimeFilter<"JournalEntry"> | Date | string
    mood?: StringNullableFilter<"JournalEntry"> | string | null
    stressLevel?: IntNullableFilter<"JournalEntry"> | number | null
    emotionScores?: JsonNullableFilter<"JournalEntry">
    topics?: JsonNullableFilter<"JournalEntry">
    sentiment?: FloatNullableFilter<"JournalEntry"> | number | null
    createdAt?: DateTimeFilter<"JournalEntry"> | Date | string
    updatedAt?: DateTimeFilter<"JournalEntry"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_date">

  export type JournalEntryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    date?: SortOrder
    mood?: SortOrderInput | SortOrder
    stressLevel?: SortOrderInput | SortOrder
    emotionScores?: SortOrderInput | SortOrder
    topics?: SortOrderInput | SortOrder
    sentiment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: JournalEntryCountOrderByAggregateInput
    _avg?: JournalEntryAvgOrderByAggregateInput
    _max?: JournalEntryMaxOrderByAggregateInput
    _min?: JournalEntryMinOrderByAggregateInput
    _sum?: JournalEntrySumOrderByAggregateInput
  }

  export type JournalEntryScalarWhereWithAggregatesInput = {
    AND?: JournalEntryScalarWhereWithAggregatesInput | JournalEntryScalarWhereWithAggregatesInput[]
    OR?: JournalEntryScalarWhereWithAggregatesInput[]
    NOT?: JournalEntryScalarWhereWithAggregatesInput | JournalEntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JournalEntry"> | string
    userId?: StringWithAggregatesFilter<"JournalEntry"> | string
    content?: StringWithAggregatesFilter<"JournalEntry"> | string
    date?: DateTimeWithAggregatesFilter<"JournalEntry"> | Date | string
    mood?: StringNullableWithAggregatesFilter<"JournalEntry"> | string | null
    stressLevel?: IntNullableWithAggregatesFilter<"JournalEntry"> | number | null
    emotionScores?: JsonNullableWithAggregatesFilter<"JournalEntry">
    topics?: JsonNullableWithAggregatesFilter<"JournalEntry">
    sentiment?: FloatNullableWithAggregatesFilter<"JournalEntry"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"JournalEntry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"JournalEntry"> | Date | string
  }

  export type HabitWhereInput = {
    AND?: HabitWhereInput | HabitWhereInput[]
    OR?: HabitWhereInput[]
    NOT?: HabitWhereInput | HabitWhereInput[]
    id?: StringFilter<"Habit"> | string
    userId?: StringFilter<"Habit"> | string
    title?: StringFilter<"Habit"> | string
    isCompleted?: BoolFilter<"Habit"> | boolean
    date?: DateTimeFilter<"Habit"> | Date | string
    aiSuggested?: BoolFilter<"Habit"> | boolean
    adaptiveReminder?: JsonNullableFilter<"Habit">
    difficultyLevel?: IntNullableFilter<"Habit"> | number | null
    createdAt?: DateTimeFilter<"Habit"> | Date | string
    updatedAt?: DateTimeFilter<"Habit"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type HabitOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    isCompleted?: SortOrder
    date?: SortOrder
    aiSuggested?: SortOrder
    adaptiveReminder?: SortOrderInput | SortOrder
    difficultyLevel?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type HabitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_id?: HabitUserIdIdCompoundUniqueInput
    AND?: HabitWhereInput | HabitWhereInput[]
    OR?: HabitWhereInput[]
    NOT?: HabitWhereInput | HabitWhereInput[]
    userId?: StringFilter<"Habit"> | string
    title?: StringFilter<"Habit"> | string
    isCompleted?: BoolFilter<"Habit"> | boolean
    date?: DateTimeFilter<"Habit"> | Date | string
    aiSuggested?: BoolFilter<"Habit"> | boolean
    adaptiveReminder?: JsonNullableFilter<"Habit">
    difficultyLevel?: IntNullableFilter<"Habit"> | number | null
    createdAt?: DateTimeFilter<"Habit"> | Date | string
    updatedAt?: DateTimeFilter<"Habit"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_id">

  export type HabitOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    isCompleted?: SortOrder
    date?: SortOrder
    aiSuggested?: SortOrder
    adaptiveReminder?: SortOrderInput | SortOrder
    difficultyLevel?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HabitCountOrderByAggregateInput
    _avg?: HabitAvgOrderByAggregateInput
    _max?: HabitMaxOrderByAggregateInput
    _min?: HabitMinOrderByAggregateInput
    _sum?: HabitSumOrderByAggregateInput
  }

  export type HabitScalarWhereWithAggregatesInput = {
    AND?: HabitScalarWhereWithAggregatesInput | HabitScalarWhereWithAggregatesInput[]
    OR?: HabitScalarWhereWithAggregatesInput[]
    NOT?: HabitScalarWhereWithAggregatesInput | HabitScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Habit"> | string
    userId?: StringWithAggregatesFilter<"Habit"> | string
    title?: StringWithAggregatesFilter<"Habit"> | string
    isCompleted?: BoolWithAggregatesFilter<"Habit"> | boolean
    date?: DateTimeWithAggregatesFilter<"Habit"> | Date | string
    aiSuggested?: BoolWithAggregatesFilter<"Habit"> | boolean
    adaptiveReminder?: JsonNullableWithAggregatesFilter<"Habit">
    difficultyLevel?: IntNullableWithAggregatesFilter<"Habit"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Habit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Habit"> | Date | string
  }

  export type ClassWhereInput = {
    AND?: ClassWhereInput | ClassWhereInput[]
    OR?: ClassWhereInput[]
    NOT?: ClassWhereInput | ClassWhereInput[]
    id?: StringFilter<"Class"> | string
    title?: StringFilter<"Class"> | string
    description?: StringNullableFilter<"Class"> | string | null
    startTime?: DateTimeFilter<"Class"> | Date | string
    durationMins?: IntFilter<"Class"> | number
    instructor?: StringFilter<"Class"> | string
    imageUrl?: StringNullableFilter<"Class"> | string | null
    capacity?: IntFilter<"Class"> | number
    intensity?: StringFilter<"Class"> | string
    stressLevel?: IntNullableFilter<"Class"> | number | null
    aiOptimized?: BoolFilter<"Class"> | boolean
    adaptiveContent?: JsonNullableFilter<"Class">
    prerequisites?: JsonNullableFilter<"Class">
    createdAt?: DateTimeFilter<"Class"> | Date | string
    updatedAt?: DateTimeFilter<"Class"> | Date | string
    bookings?: BookingListRelationFilter
  }

  export type ClassOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    startTime?: SortOrder
    durationMins?: SortOrder
    instructor?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    capacity?: SortOrder
    intensity?: SortOrder
    stressLevel?: SortOrderInput | SortOrder
    aiOptimized?: SortOrder
    adaptiveContent?: SortOrderInput | SortOrder
    prerequisites?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bookings?: BookingOrderByRelationAggregateInput
  }

  export type ClassWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClassWhereInput | ClassWhereInput[]
    OR?: ClassWhereInput[]
    NOT?: ClassWhereInput | ClassWhereInput[]
    title?: StringFilter<"Class"> | string
    description?: StringNullableFilter<"Class"> | string | null
    startTime?: DateTimeFilter<"Class"> | Date | string
    durationMins?: IntFilter<"Class"> | number
    instructor?: StringFilter<"Class"> | string
    imageUrl?: StringNullableFilter<"Class"> | string | null
    capacity?: IntFilter<"Class"> | number
    intensity?: StringFilter<"Class"> | string
    stressLevel?: IntNullableFilter<"Class"> | number | null
    aiOptimized?: BoolFilter<"Class"> | boolean
    adaptiveContent?: JsonNullableFilter<"Class">
    prerequisites?: JsonNullableFilter<"Class">
    createdAt?: DateTimeFilter<"Class"> | Date | string
    updatedAt?: DateTimeFilter<"Class"> | Date | string
    bookings?: BookingListRelationFilter
  }, "id">

  export type ClassOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    startTime?: SortOrder
    durationMins?: SortOrder
    instructor?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    capacity?: SortOrder
    intensity?: SortOrder
    stressLevel?: SortOrderInput | SortOrder
    aiOptimized?: SortOrder
    adaptiveContent?: SortOrderInput | SortOrder
    prerequisites?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClassCountOrderByAggregateInput
    _avg?: ClassAvgOrderByAggregateInput
    _max?: ClassMaxOrderByAggregateInput
    _min?: ClassMinOrderByAggregateInput
    _sum?: ClassSumOrderByAggregateInput
  }

  export type ClassScalarWhereWithAggregatesInput = {
    AND?: ClassScalarWhereWithAggregatesInput | ClassScalarWhereWithAggregatesInput[]
    OR?: ClassScalarWhereWithAggregatesInput[]
    NOT?: ClassScalarWhereWithAggregatesInput | ClassScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Class"> | string
    title?: StringWithAggregatesFilter<"Class"> | string
    description?: StringNullableWithAggregatesFilter<"Class"> | string | null
    startTime?: DateTimeWithAggregatesFilter<"Class"> | Date | string
    durationMins?: IntWithAggregatesFilter<"Class"> | number
    instructor?: StringWithAggregatesFilter<"Class"> | string
    imageUrl?: StringNullableWithAggregatesFilter<"Class"> | string | null
    capacity?: IntWithAggregatesFilter<"Class"> | number
    intensity?: StringWithAggregatesFilter<"Class"> | string
    stressLevel?: IntNullableWithAggregatesFilter<"Class"> | number | null
    aiOptimized?: BoolWithAggregatesFilter<"Class"> | boolean
    adaptiveContent?: JsonNullableWithAggregatesFilter<"Class">
    prerequisites?: JsonNullableWithAggregatesFilter<"Class">
    createdAt?: DateTimeWithAggregatesFilter<"Class"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Class"> | Date | string
  }

  export type BookingWhereInput = {
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    id?: StringFilter<"Booking"> | string
    userId?: StringFilter<"Booking"> | string
    classId?: StringFilter<"Booking"> | string
    aiSuggested?: BoolFilter<"Booking"> | boolean
    predictedEffectiveness?: FloatNullableFilter<"Booking"> | number | null
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
  }

  export type BookingOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    classId?: SortOrder
    aiSuggested?: SortOrder
    predictedEffectiveness?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    class?: ClassOrderByWithRelationInput
  }

  export type BookingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_classId?: BookingUserIdClassIdCompoundUniqueInput
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    userId?: StringFilter<"Booking"> | string
    classId?: StringFilter<"Booking"> | string
    aiSuggested?: BoolFilter<"Booking"> | boolean
    predictedEffectiveness?: FloatNullableFilter<"Booking"> | number | null
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
  }, "id" | "userId_classId">

  export type BookingOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    classId?: SortOrder
    aiSuggested?: SortOrder
    predictedEffectiveness?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: BookingCountOrderByAggregateInput
    _avg?: BookingAvgOrderByAggregateInput
    _max?: BookingMaxOrderByAggregateInput
    _min?: BookingMinOrderByAggregateInput
    _sum?: BookingSumOrderByAggregateInput
  }

  export type BookingScalarWhereWithAggregatesInput = {
    AND?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    OR?: BookingScalarWhereWithAggregatesInput[]
    NOT?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Booking"> | string
    userId?: StringWithAggregatesFilter<"Booking"> | string
    classId?: StringWithAggregatesFilter<"Booking"> | string
    aiSuggested?: BoolWithAggregatesFilter<"Booking"> | boolean
    predictedEffectiveness?: FloatNullableWithAggregatesFilter<"Booking"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
  }

  export type BiometricDataWhereInput = {
    AND?: BiometricDataWhereInput | BiometricDataWhereInput[]
    OR?: BiometricDataWhereInput[]
    NOT?: BiometricDataWhereInput | BiometricDataWhereInput[]
    id?: StringFilter<"BiometricData"> | string
    userId?: StringFilter<"BiometricData"> | string
    heartRate?: IntNullableFilter<"BiometricData"> | number | null
    heartRateVariability?: FloatNullableFilter<"BiometricData"> | number | null
    stressLevel?: IntNullableFilter<"BiometricData"> | number | null
    sleepQuality?: IntNullableFilter<"BiometricData"> | number | null
    sleepDuration?: FloatNullableFilter<"BiometricData"> | number | null
    steps?: IntNullableFilter<"BiometricData"> | number | null
    calories?: IntNullableFilter<"BiometricData"> | number | null
    respiratoryRate?: IntNullableFilter<"BiometricData"> | number | null
    skinTemperature?: FloatNullableFilter<"BiometricData"> | number | null
    bloodPressureSystolic?: IntNullableFilter<"BiometricData"> | number | null
    bloodPressureDiastolic?: IntNullableFilter<"BiometricData"> | number | null
    oxygenSaturation?: FloatNullableFilter<"BiometricData"> | number | null
    wellnessScore?: FloatNullableFilter<"BiometricData"> | number | null
    energyLevel?: IntNullableFilter<"BiometricData"> | number | null
    recoveryScore?: FloatNullableFilter<"BiometricData"> | number | null
    deviceType?: StringNullableFilter<"BiometricData"> | string | null
    deviceId?: StringNullableFilter<"BiometricData"> | string | null
    accuracy?: FloatNullableFilter<"BiometricData"> | number | null
    timestamp?: DateTimeFilter<"BiometricData"> | Date | string
    createdAt?: DateTimeFilter<"BiometricData"> | Date | string
    updatedAt?: DateTimeFilter<"BiometricData"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type BiometricDataOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    heartRate?: SortOrderInput | SortOrder
    heartRateVariability?: SortOrderInput | SortOrder
    stressLevel?: SortOrderInput | SortOrder
    sleepQuality?: SortOrderInput | SortOrder
    sleepDuration?: SortOrderInput | SortOrder
    steps?: SortOrderInput | SortOrder
    calories?: SortOrderInput | SortOrder
    respiratoryRate?: SortOrderInput | SortOrder
    skinTemperature?: SortOrderInput | SortOrder
    bloodPressureSystolic?: SortOrderInput | SortOrder
    bloodPressureDiastolic?: SortOrderInput | SortOrder
    oxygenSaturation?: SortOrderInput | SortOrder
    wellnessScore?: SortOrderInput | SortOrder
    energyLevel?: SortOrderInput | SortOrder
    recoveryScore?: SortOrderInput | SortOrder
    deviceType?: SortOrderInput | SortOrder
    deviceId?: SortOrderInput | SortOrder
    accuracy?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type BiometricDataWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BiometricDataWhereInput | BiometricDataWhereInput[]
    OR?: BiometricDataWhereInput[]
    NOT?: BiometricDataWhereInput | BiometricDataWhereInput[]
    userId?: StringFilter<"BiometricData"> | string
    heartRate?: IntNullableFilter<"BiometricData"> | number | null
    heartRateVariability?: FloatNullableFilter<"BiometricData"> | number | null
    stressLevel?: IntNullableFilter<"BiometricData"> | number | null
    sleepQuality?: IntNullableFilter<"BiometricData"> | number | null
    sleepDuration?: FloatNullableFilter<"BiometricData"> | number | null
    steps?: IntNullableFilter<"BiometricData"> | number | null
    calories?: IntNullableFilter<"BiometricData"> | number | null
    respiratoryRate?: IntNullableFilter<"BiometricData"> | number | null
    skinTemperature?: FloatNullableFilter<"BiometricData"> | number | null
    bloodPressureSystolic?: IntNullableFilter<"BiometricData"> | number | null
    bloodPressureDiastolic?: IntNullableFilter<"BiometricData"> | number | null
    oxygenSaturation?: FloatNullableFilter<"BiometricData"> | number | null
    wellnessScore?: FloatNullableFilter<"BiometricData"> | number | null
    energyLevel?: IntNullableFilter<"BiometricData"> | number | null
    recoveryScore?: FloatNullableFilter<"BiometricData"> | number | null
    deviceType?: StringNullableFilter<"BiometricData"> | string | null
    deviceId?: StringNullableFilter<"BiometricData"> | string | null
    accuracy?: FloatNullableFilter<"BiometricData"> | number | null
    timestamp?: DateTimeFilter<"BiometricData"> | Date | string
    createdAt?: DateTimeFilter<"BiometricData"> | Date | string
    updatedAt?: DateTimeFilter<"BiometricData"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type BiometricDataOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    heartRate?: SortOrderInput | SortOrder
    heartRateVariability?: SortOrderInput | SortOrder
    stressLevel?: SortOrderInput | SortOrder
    sleepQuality?: SortOrderInput | SortOrder
    sleepDuration?: SortOrderInput | SortOrder
    steps?: SortOrderInput | SortOrder
    calories?: SortOrderInput | SortOrder
    respiratoryRate?: SortOrderInput | SortOrder
    skinTemperature?: SortOrderInput | SortOrder
    bloodPressureSystolic?: SortOrderInput | SortOrder
    bloodPressureDiastolic?: SortOrderInput | SortOrder
    oxygenSaturation?: SortOrderInput | SortOrder
    wellnessScore?: SortOrderInput | SortOrder
    energyLevel?: SortOrderInput | SortOrder
    recoveryScore?: SortOrderInput | SortOrder
    deviceType?: SortOrderInput | SortOrder
    deviceId?: SortOrderInput | SortOrder
    accuracy?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BiometricDataCountOrderByAggregateInput
    _avg?: BiometricDataAvgOrderByAggregateInput
    _max?: BiometricDataMaxOrderByAggregateInput
    _min?: BiometricDataMinOrderByAggregateInput
    _sum?: BiometricDataSumOrderByAggregateInput
  }

  export type BiometricDataScalarWhereWithAggregatesInput = {
    AND?: BiometricDataScalarWhereWithAggregatesInput | BiometricDataScalarWhereWithAggregatesInput[]
    OR?: BiometricDataScalarWhereWithAggregatesInput[]
    NOT?: BiometricDataScalarWhereWithAggregatesInput | BiometricDataScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BiometricData"> | string
    userId?: StringWithAggregatesFilter<"BiometricData"> | string
    heartRate?: IntNullableWithAggregatesFilter<"BiometricData"> | number | null
    heartRateVariability?: FloatNullableWithAggregatesFilter<"BiometricData"> | number | null
    stressLevel?: IntNullableWithAggregatesFilter<"BiometricData"> | number | null
    sleepQuality?: IntNullableWithAggregatesFilter<"BiometricData"> | number | null
    sleepDuration?: FloatNullableWithAggregatesFilter<"BiometricData"> | number | null
    steps?: IntNullableWithAggregatesFilter<"BiometricData"> | number | null
    calories?: IntNullableWithAggregatesFilter<"BiometricData"> | number | null
    respiratoryRate?: IntNullableWithAggregatesFilter<"BiometricData"> | number | null
    skinTemperature?: FloatNullableWithAggregatesFilter<"BiometricData"> | number | null
    bloodPressureSystolic?: IntNullableWithAggregatesFilter<"BiometricData"> | number | null
    bloodPressureDiastolic?: IntNullableWithAggregatesFilter<"BiometricData"> | number | null
    oxygenSaturation?: FloatNullableWithAggregatesFilter<"BiometricData"> | number | null
    wellnessScore?: FloatNullableWithAggregatesFilter<"BiometricData"> | number | null
    energyLevel?: IntNullableWithAggregatesFilter<"BiometricData"> | number | null
    recoveryScore?: FloatNullableWithAggregatesFilter<"BiometricData"> | number | null
    deviceType?: StringNullableWithAggregatesFilter<"BiometricData"> | string | null
    deviceId?: StringNullableWithAggregatesFilter<"BiometricData"> | string | null
    accuracy?: FloatNullableWithAggregatesFilter<"BiometricData"> | number | null
    timestamp?: DateTimeWithAggregatesFilter<"BiometricData"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"BiometricData"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BiometricData"> | Date | string
  }

  export type MoodEntryWhereInput = {
    AND?: MoodEntryWhereInput | MoodEntryWhereInput[]
    OR?: MoodEntryWhereInput[]
    NOT?: MoodEntryWhereInput | MoodEntryWhereInput[]
    id?: StringFilter<"MoodEntry"> | string
    userId?: StringFilter<"MoodEntry"> | string
    mood?: StringFilter<"MoodEntry"> | string
    confidence?: FloatFilter<"MoodEntry"> | number
    source?: StringFilter<"MoodEntry"> | string
    emotions?: JsonNullableFilter<"MoodEntry">
    valence?: FloatNullableFilter<"MoodEntry"> | number | null
    arousal?: FloatNullableFilter<"MoodEntry"> | number | null
    location?: StringNullableFilter<"MoodEntry"> | string | null
    weather?: StringNullableFilter<"MoodEntry"> | string | null
    timeOfDay?: StringNullableFilter<"MoodEntry"> | string | null
    activity?: StringNullableFilter<"MoodEntry"> | string | null
    voiceFeatures?: JsonNullableFilter<"MoodEntry">
    timestamp?: DateTimeFilter<"MoodEntry"> | Date | string
    createdAt?: DateTimeFilter<"MoodEntry"> | Date | string
    updatedAt?: DateTimeFilter<"MoodEntry"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MoodEntryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    mood?: SortOrder
    confidence?: SortOrder
    source?: SortOrder
    emotions?: SortOrderInput | SortOrder
    valence?: SortOrderInput | SortOrder
    arousal?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    weather?: SortOrderInput | SortOrder
    timeOfDay?: SortOrderInput | SortOrder
    activity?: SortOrderInput | SortOrder
    voiceFeatures?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type MoodEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MoodEntryWhereInput | MoodEntryWhereInput[]
    OR?: MoodEntryWhereInput[]
    NOT?: MoodEntryWhereInput | MoodEntryWhereInput[]
    userId?: StringFilter<"MoodEntry"> | string
    mood?: StringFilter<"MoodEntry"> | string
    confidence?: FloatFilter<"MoodEntry"> | number
    source?: StringFilter<"MoodEntry"> | string
    emotions?: JsonNullableFilter<"MoodEntry">
    valence?: FloatNullableFilter<"MoodEntry"> | number | null
    arousal?: FloatNullableFilter<"MoodEntry"> | number | null
    location?: StringNullableFilter<"MoodEntry"> | string | null
    weather?: StringNullableFilter<"MoodEntry"> | string | null
    timeOfDay?: StringNullableFilter<"MoodEntry"> | string | null
    activity?: StringNullableFilter<"MoodEntry"> | string | null
    voiceFeatures?: JsonNullableFilter<"MoodEntry">
    timestamp?: DateTimeFilter<"MoodEntry"> | Date | string
    createdAt?: DateTimeFilter<"MoodEntry"> | Date | string
    updatedAt?: DateTimeFilter<"MoodEntry"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type MoodEntryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    mood?: SortOrder
    confidence?: SortOrder
    source?: SortOrder
    emotions?: SortOrderInput | SortOrder
    valence?: SortOrderInput | SortOrder
    arousal?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    weather?: SortOrderInput | SortOrder
    timeOfDay?: SortOrderInput | SortOrder
    activity?: SortOrderInput | SortOrder
    voiceFeatures?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MoodEntryCountOrderByAggregateInput
    _avg?: MoodEntryAvgOrderByAggregateInput
    _max?: MoodEntryMaxOrderByAggregateInput
    _min?: MoodEntryMinOrderByAggregateInput
    _sum?: MoodEntrySumOrderByAggregateInput
  }

  export type MoodEntryScalarWhereWithAggregatesInput = {
    AND?: MoodEntryScalarWhereWithAggregatesInput | MoodEntryScalarWhereWithAggregatesInput[]
    OR?: MoodEntryScalarWhereWithAggregatesInput[]
    NOT?: MoodEntryScalarWhereWithAggregatesInput | MoodEntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MoodEntry"> | string
    userId?: StringWithAggregatesFilter<"MoodEntry"> | string
    mood?: StringWithAggregatesFilter<"MoodEntry"> | string
    confidence?: FloatWithAggregatesFilter<"MoodEntry"> | number
    source?: StringWithAggregatesFilter<"MoodEntry"> | string
    emotions?: JsonNullableWithAggregatesFilter<"MoodEntry">
    valence?: FloatNullableWithAggregatesFilter<"MoodEntry"> | number | null
    arousal?: FloatNullableWithAggregatesFilter<"MoodEntry"> | number | null
    location?: StringNullableWithAggregatesFilter<"MoodEntry"> | string | null
    weather?: StringNullableWithAggregatesFilter<"MoodEntry"> | string | null
    timeOfDay?: StringNullableWithAggregatesFilter<"MoodEntry"> | string | null
    activity?: StringNullableWithAggregatesFilter<"MoodEntry"> | string | null
    voiceFeatures?: JsonNullableWithAggregatesFilter<"MoodEntry">
    timestamp?: DateTimeWithAggregatesFilter<"MoodEntry"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"MoodEntry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MoodEntry"> | Date | string
  }

  export type StressPredictionWhereInput = {
    AND?: StressPredictionWhereInput | StressPredictionWhereInput[]
    OR?: StressPredictionWhereInput[]
    NOT?: StressPredictionWhereInput | StressPredictionWhereInput[]
    id?: StringFilter<"StressPrediction"> | string
    userId?: StringFilter<"StressPrediction"> | string
    predictedStressLevel?: IntFilter<"StressPrediction"> | number
    confidence?: FloatFilter<"StressPrediction"> | number
    predictedAt?: DateTimeFilter<"StressPrediction"> | Date | string
    modelVersion?: StringNullableFilter<"StressPrediction"> | string | null
    triggers?: JsonNullableFilter<"StressPrediction">
    riskFactors?: JsonNullableFilter<"StressPrediction">
    recommendedInterventions?: JsonNullableFilter<"StressPrediction">
    preventionStrategies?: JsonNullableFilter<"StressPrediction">
    actualStressLevel?: IntNullableFilter<"StressPrediction"> | number | null
    wasAccurate?: BoolNullableFilter<"StressPrediction"> | boolean | null
    createdAt?: DateTimeFilter<"StressPrediction"> | Date | string
    updatedAt?: DateTimeFilter<"StressPrediction"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type StressPredictionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    predictedStressLevel?: SortOrder
    confidence?: SortOrder
    predictedAt?: SortOrder
    modelVersion?: SortOrderInput | SortOrder
    triggers?: SortOrderInput | SortOrder
    riskFactors?: SortOrderInput | SortOrder
    recommendedInterventions?: SortOrderInput | SortOrder
    preventionStrategies?: SortOrderInput | SortOrder
    actualStressLevel?: SortOrderInput | SortOrder
    wasAccurate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type StressPredictionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StressPredictionWhereInput | StressPredictionWhereInput[]
    OR?: StressPredictionWhereInput[]
    NOT?: StressPredictionWhereInput | StressPredictionWhereInput[]
    userId?: StringFilter<"StressPrediction"> | string
    predictedStressLevel?: IntFilter<"StressPrediction"> | number
    confidence?: FloatFilter<"StressPrediction"> | number
    predictedAt?: DateTimeFilter<"StressPrediction"> | Date | string
    modelVersion?: StringNullableFilter<"StressPrediction"> | string | null
    triggers?: JsonNullableFilter<"StressPrediction">
    riskFactors?: JsonNullableFilter<"StressPrediction">
    recommendedInterventions?: JsonNullableFilter<"StressPrediction">
    preventionStrategies?: JsonNullableFilter<"StressPrediction">
    actualStressLevel?: IntNullableFilter<"StressPrediction"> | number | null
    wasAccurate?: BoolNullableFilter<"StressPrediction"> | boolean | null
    createdAt?: DateTimeFilter<"StressPrediction"> | Date | string
    updatedAt?: DateTimeFilter<"StressPrediction"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type StressPredictionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    predictedStressLevel?: SortOrder
    confidence?: SortOrder
    predictedAt?: SortOrder
    modelVersion?: SortOrderInput | SortOrder
    triggers?: SortOrderInput | SortOrder
    riskFactors?: SortOrderInput | SortOrder
    recommendedInterventions?: SortOrderInput | SortOrder
    preventionStrategies?: SortOrderInput | SortOrder
    actualStressLevel?: SortOrderInput | SortOrder
    wasAccurate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StressPredictionCountOrderByAggregateInput
    _avg?: StressPredictionAvgOrderByAggregateInput
    _max?: StressPredictionMaxOrderByAggregateInput
    _min?: StressPredictionMinOrderByAggregateInput
    _sum?: StressPredictionSumOrderByAggregateInput
  }

  export type StressPredictionScalarWhereWithAggregatesInput = {
    AND?: StressPredictionScalarWhereWithAggregatesInput | StressPredictionScalarWhereWithAggregatesInput[]
    OR?: StressPredictionScalarWhereWithAggregatesInput[]
    NOT?: StressPredictionScalarWhereWithAggregatesInput | StressPredictionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StressPrediction"> | string
    userId?: StringWithAggregatesFilter<"StressPrediction"> | string
    predictedStressLevel?: IntWithAggregatesFilter<"StressPrediction"> | number
    confidence?: FloatWithAggregatesFilter<"StressPrediction"> | number
    predictedAt?: DateTimeWithAggregatesFilter<"StressPrediction"> | Date | string
    modelVersion?: StringNullableWithAggregatesFilter<"StressPrediction"> | string | null
    triggers?: JsonNullableWithAggregatesFilter<"StressPrediction">
    riskFactors?: JsonNullableWithAggregatesFilter<"StressPrediction">
    recommendedInterventions?: JsonNullableWithAggregatesFilter<"StressPrediction">
    preventionStrategies?: JsonNullableWithAggregatesFilter<"StressPrediction">
    actualStressLevel?: IntNullableWithAggregatesFilter<"StressPrediction"> | number | null
    wasAccurate?: BoolNullableWithAggregatesFilter<"StressPrediction"> | boolean | null
    createdAt?: DateTimeWithAggregatesFilter<"StressPrediction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StressPrediction"> | Date | string
  }

  export type WellnessChallengeWhereInput = {
    AND?: WellnessChallengeWhereInput | WellnessChallengeWhereInput[]
    OR?: WellnessChallengeWhereInput[]
    NOT?: WellnessChallengeWhereInput | WellnessChallengeWhereInput[]
    id?: StringFilter<"WellnessChallenge"> | string
    title?: StringFilter<"WellnessChallenge"> | string
    description?: StringFilter<"WellnessChallenge"> | string
    type?: StringFilter<"WellnessChallenge"> | string
    duration?: IntFilter<"WellnessChallenge"> | number
    target?: JsonFilter<"WellnessChallenge">
    reward?: StringNullableFilter<"WellnessChallenge"> | string | null
    isActive?: BoolFilter<"WellnessChallenge"> | boolean
    startDate?: DateTimeFilter<"WellnessChallenge"> | Date | string
    endDate?: DateTimeFilter<"WellnessChallenge"> | Date | string
    maxParticipants?: IntNullableFilter<"WellnessChallenge"> | number | null
    isPublic?: BoolFilter<"WellnessChallenge"> | boolean
    teamBased?: BoolFilter<"WellnessChallenge"> | boolean
    aiGenerated?: BoolFilter<"WellnessChallenge"> | boolean
    adaptiveDifficulty?: BoolFilter<"WellnessChallenge"> | boolean
    personalizedGoals?: JsonNullableFilter<"WellnessChallenge">
    createdAt?: DateTimeFilter<"WellnessChallenge"> | Date | string
    updatedAt?: DateTimeFilter<"WellnessChallenge"> | Date | string
    participants?: ChallengeParticipantListRelationFilter
  }

  export type WellnessChallengeOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    duration?: SortOrder
    target?: SortOrder
    reward?: SortOrderInput | SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    maxParticipants?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    teamBased?: SortOrder
    aiGenerated?: SortOrder
    adaptiveDifficulty?: SortOrder
    personalizedGoals?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    participants?: ChallengeParticipantOrderByRelationAggregateInput
  }

  export type WellnessChallengeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WellnessChallengeWhereInput | WellnessChallengeWhereInput[]
    OR?: WellnessChallengeWhereInput[]
    NOT?: WellnessChallengeWhereInput | WellnessChallengeWhereInput[]
    title?: StringFilter<"WellnessChallenge"> | string
    description?: StringFilter<"WellnessChallenge"> | string
    type?: StringFilter<"WellnessChallenge"> | string
    duration?: IntFilter<"WellnessChallenge"> | number
    target?: JsonFilter<"WellnessChallenge">
    reward?: StringNullableFilter<"WellnessChallenge"> | string | null
    isActive?: BoolFilter<"WellnessChallenge"> | boolean
    startDate?: DateTimeFilter<"WellnessChallenge"> | Date | string
    endDate?: DateTimeFilter<"WellnessChallenge"> | Date | string
    maxParticipants?: IntNullableFilter<"WellnessChallenge"> | number | null
    isPublic?: BoolFilter<"WellnessChallenge"> | boolean
    teamBased?: BoolFilter<"WellnessChallenge"> | boolean
    aiGenerated?: BoolFilter<"WellnessChallenge"> | boolean
    adaptiveDifficulty?: BoolFilter<"WellnessChallenge"> | boolean
    personalizedGoals?: JsonNullableFilter<"WellnessChallenge">
    createdAt?: DateTimeFilter<"WellnessChallenge"> | Date | string
    updatedAt?: DateTimeFilter<"WellnessChallenge"> | Date | string
    participants?: ChallengeParticipantListRelationFilter
  }, "id">

  export type WellnessChallengeOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    duration?: SortOrder
    target?: SortOrder
    reward?: SortOrderInput | SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    maxParticipants?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    teamBased?: SortOrder
    aiGenerated?: SortOrder
    adaptiveDifficulty?: SortOrder
    personalizedGoals?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WellnessChallengeCountOrderByAggregateInput
    _avg?: WellnessChallengeAvgOrderByAggregateInput
    _max?: WellnessChallengeMaxOrderByAggregateInput
    _min?: WellnessChallengeMinOrderByAggregateInput
    _sum?: WellnessChallengeSumOrderByAggregateInput
  }

  export type WellnessChallengeScalarWhereWithAggregatesInput = {
    AND?: WellnessChallengeScalarWhereWithAggregatesInput | WellnessChallengeScalarWhereWithAggregatesInput[]
    OR?: WellnessChallengeScalarWhereWithAggregatesInput[]
    NOT?: WellnessChallengeScalarWhereWithAggregatesInput | WellnessChallengeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WellnessChallenge"> | string
    title?: StringWithAggregatesFilter<"WellnessChallenge"> | string
    description?: StringWithAggregatesFilter<"WellnessChallenge"> | string
    type?: StringWithAggregatesFilter<"WellnessChallenge"> | string
    duration?: IntWithAggregatesFilter<"WellnessChallenge"> | number
    target?: JsonWithAggregatesFilter<"WellnessChallenge">
    reward?: StringNullableWithAggregatesFilter<"WellnessChallenge"> | string | null
    isActive?: BoolWithAggregatesFilter<"WellnessChallenge"> | boolean
    startDate?: DateTimeWithAggregatesFilter<"WellnessChallenge"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"WellnessChallenge"> | Date | string
    maxParticipants?: IntNullableWithAggregatesFilter<"WellnessChallenge"> | number | null
    isPublic?: BoolWithAggregatesFilter<"WellnessChallenge"> | boolean
    teamBased?: BoolWithAggregatesFilter<"WellnessChallenge"> | boolean
    aiGenerated?: BoolWithAggregatesFilter<"WellnessChallenge"> | boolean
    adaptiveDifficulty?: BoolWithAggregatesFilter<"WellnessChallenge"> | boolean
    personalizedGoals?: JsonNullableWithAggregatesFilter<"WellnessChallenge">
    createdAt?: DateTimeWithAggregatesFilter<"WellnessChallenge"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WellnessChallenge"> | Date | string
  }

  export type ChallengeParticipantWhereInput = {
    AND?: ChallengeParticipantWhereInput | ChallengeParticipantWhereInput[]
    OR?: ChallengeParticipantWhereInput[]
    NOT?: ChallengeParticipantWhereInput | ChallengeParticipantWhereInput[]
    id?: StringFilter<"ChallengeParticipant"> | string
    userId?: StringFilter<"ChallengeParticipant"> | string
    challengeId?: StringFilter<"ChallengeParticipant"> | string
    progress?: JsonFilter<"ChallengeParticipant">
    completed?: BoolFilter<"ChallengeParticipant"> | boolean
    currentStreak?: IntFilter<"ChallengeParticipant"> | number
    bestStreak?: IntFilter<"ChallengeParticipant"> | number
    rank?: IntNullableFilter<"ChallengeParticipant"> | number | null
    joinedAt?: DateTimeFilter<"ChallengeParticipant"> | Date | string
    completedAt?: DateTimeNullableFilter<"ChallengeParticipant"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    challenge?: XOR<WellnessChallengeScalarRelationFilter, WellnessChallengeWhereInput>
  }

  export type ChallengeParticipantOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    challengeId?: SortOrder
    progress?: SortOrder
    completed?: SortOrder
    currentStreak?: SortOrder
    bestStreak?: SortOrder
    rank?: SortOrderInput | SortOrder
    joinedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    challenge?: WellnessChallengeOrderByWithRelationInput
  }

  export type ChallengeParticipantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_challengeId?: ChallengeParticipantUserIdChallengeIdCompoundUniqueInput
    AND?: ChallengeParticipantWhereInput | ChallengeParticipantWhereInput[]
    OR?: ChallengeParticipantWhereInput[]
    NOT?: ChallengeParticipantWhereInput | ChallengeParticipantWhereInput[]
    userId?: StringFilter<"ChallengeParticipant"> | string
    challengeId?: StringFilter<"ChallengeParticipant"> | string
    progress?: JsonFilter<"ChallengeParticipant">
    completed?: BoolFilter<"ChallengeParticipant"> | boolean
    currentStreak?: IntFilter<"ChallengeParticipant"> | number
    bestStreak?: IntFilter<"ChallengeParticipant"> | number
    rank?: IntNullableFilter<"ChallengeParticipant"> | number | null
    joinedAt?: DateTimeFilter<"ChallengeParticipant"> | Date | string
    completedAt?: DateTimeNullableFilter<"ChallengeParticipant"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    challenge?: XOR<WellnessChallengeScalarRelationFilter, WellnessChallengeWhereInput>
  }, "id" | "userId_challengeId">

  export type ChallengeParticipantOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    challengeId?: SortOrder
    progress?: SortOrder
    completed?: SortOrder
    currentStreak?: SortOrder
    bestStreak?: SortOrder
    rank?: SortOrderInput | SortOrder
    joinedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: ChallengeParticipantCountOrderByAggregateInput
    _avg?: ChallengeParticipantAvgOrderByAggregateInput
    _max?: ChallengeParticipantMaxOrderByAggregateInput
    _min?: ChallengeParticipantMinOrderByAggregateInput
    _sum?: ChallengeParticipantSumOrderByAggregateInput
  }

  export type ChallengeParticipantScalarWhereWithAggregatesInput = {
    AND?: ChallengeParticipantScalarWhereWithAggregatesInput | ChallengeParticipantScalarWhereWithAggregatesInput[]
    OR?: ChallengeParticipantScalarWhereWithAggregatesInput[]
    NOT?: ChallengeParticipantScalarWhereWithAggregatesInput | ChallengeParticipantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChallengeParticipant"> | string
    userId?: StringWithAggregatesFilter<"ChallengeParticipant"> | string
    challengeId?: StringWithAggregatesFilter<"ChallengeParticipant"> | string
    progress?: JsonWithAggregatesFilter<"ChallengeParticipant">
    completed?: BoolWithAggregatesFilter<"ChallengeParticipant"> | boolean
    currentStreak?: IntWithAggregatesFilter<"ChallengeParticipant"> | number
    bestStreak?: IntWithAggregatesFilter<"ChallengeParticipant"> | number
    rank?: IntNullableWithAggregatesFilter<"ChallengeParticipant"> | number | null
    joinedAt?: DateTimeWithAggregatesFilter<"ChallengeParticipant"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"ChallengeParticipant"> | Date | string | null
  }

  export type AIRecommendationWhereInput = {
    AND?: AIRecommendationWhereInput | AIRecommendationWhereInput[]
    OR?: AIRecommendationWhereInput[]
    NOT?: AIRecommendationWhereInput | AIRecommendationWhereInput[]
    id?: StringFilter<"AIRecommendation"> | string
    userId?: StringFilter<"AIRecommendation"> | string
    type?: StringFilter<"AIRecommendation"> | string
    title?: StringFilter<"AIRecommendation"> | string
    description?: StringFilter<"AIRecommendation"> | string
    priority?: IntFilter<"AIRecommendation"> | number
    reasoning?: StringFilter<"AIRecommendation"> | string
    actionUrl?: StringNullableFilter<"AIRecommendation"> | string | null
    duration?: IntNullableFilter<"AIRecommendation"> | number | null
    intensity?: StringNullableFilter<"AIRecommendation"> | string | null
    triggeredBy?: JsonNullableFilter<"AIRecommendation">
    biometricState?: JsonNullableFilter<"AIRecommendation">
    effectivenessScore?: FloatNullableFilter<"AIRecommendation"> | number | null
    isRead?: BoolFilter<"AIRecommendation"> | boolean
    isCompleted?: BoolFilter<"AIRecommendation"> | boolean
    createdAt?: DateTimeFilter<"AIRecommendation"> | Date | string
    expiresAt?: DateTimeNullableFilter<"AIRecommendation"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"AIRecommendation"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AIRecommendationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    reasoning?: SortOrder
    actionUrl?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    intensity?: SortOrderInput | SortOrder
    triggeredBy?: SortOrderInput | SortOrder
    biometricState?: SortOrderInput | SortOrder
    effectivenessScore?: SortOrderInput | SortOrder
    isRead?: SortOrder
    isCompleted?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AIRecommendationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AIRecommendationWhereInput | AIRecommendationWhereInput[]
    OR?: AIRecommendationWhereInput[]
    NOT?: AIRecommendationWhereInput | AIRecommendationWhereInput[]
    userId?: StringFilter<"AIRecommendation"> | string
    type?: StringFilter<"AIRecommendation"> | string
    title?: StringFilter<"AIRecommendation"> | string
    description?: StringFilter<"AIRecommendation"> | string
    priority?: IntFilter<"AIRecommendation"> | number
    reasoning?: StringFilter<"AIRecommendation"> | string
    actionUrl?: StringNullableFilter<"AIRecommendation"> | string | null
    duration?: IntNullableFilter<"AIRecommendation"> | number | null
    intensity?: StringNullableFilter<"AIRecommendation"> | string | null
    triggeredBy?: JsonNullableFilter<"AIRecommendation">
    biometricState?: JsonNullableFilter<"AIRecommendation">
    effectivenessScore?: FloatNullableFilter<"AIRecommendation"> | number | null
    isRead?: BoolFilter<"AIRecommendation"> | boolean
    isCompleted?: BoolFilter<"AIRecommendation"> | boolean
    createdAt?: DateTimeFilter<"AIRecommendation"> | Date | string
    expiresAt?: DateTimeNullableFilter<"AIRecommendation"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"AIRecommendation"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AIRecommendationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    reasoning?: SortOrder
    actionUrl?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    intensity?: SortOrderInput | SortOrder
    triggeredBy?: SortOrderInput | SortOrder
    biometricState?: SortOrderInput | SortOrder
    effectivenessScore?: SortOrderInput | SortOrder
    isRead?: SortOrder
    isCompleted?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: AIRecommendationCountOrderByAggregateInput
    _avg?: AIRecommendationAvgOrderByAggregateInput
    _max?: AIRecommendationMaxOrderByAggregateInput
    _min?: AIRecommendationMinOrderByAggregateInput
    _sum?: AIRecommendationSumOrderByAggregateInput
  }

  export type AIRecommendationScalarWhereWithAggregatesInput = {
    AND?: AIRecommendationScalarWhereWithAggregatesInput | AIRecommendationScalarWhereWithAggregatesInput[]
    OR?: AIRecommendationScalarWhereWithAggregatesInput[]
    NOT?: AIRecommendationScalarWhereWithAggregatesInput | AIRecommendationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AIRecommendation"> | string
    userId?: StringWithAggregatesFilter<"AIRecommendation"> | string
    type?: StringWithAggregatesFilter<"AIRecommendation"> | string
    title?: StringWithAggregatesFilter<"AIRecommendation"> | string
    description?: StringWithAggregatesFilter<"AIRecommendation"> | string
    priority?: IntWithAggregatesFilter<"AIRecommendation"> | number
    reasoning?: StringWithAggregatesFilter<"AIRecommendation"> | string
    actionUrl?: StringNullableWithAggregatesFilter<"AIRecommendation"> | string | null
    duration?: IntNullableWithAggregatesFilter<"AIRecommendation"> | number | null
    intensity?: StringNullableWithAggregatesFilter<"AIRecommendation"> | string | null
    triggeredBy?: JsonNullableWithAggregatesFilter<"AIRecommendation">
    biometricState?: JsonNullableWithAggregatesFilter<"AIRecommendation">
    effectivenessScore?: FloatNullableWithAggregatesFilter<"AIRecommendation"> | number | null
    isRead?: BoolWithAggregatesFilter<"AIRecommendation"> | boolean
    isCompleted?: BoolWithAggregatesFilter<"AIRecommendation"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AIRecommendation"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"AIRecommendation"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"AIRecommendation"> | Date | string | null
  }

  export type DeviceConnectionWhereInput = {
    AND?: DeviceConnectionWhereInput | DeviceConnectionWhereInput[]
    OR?: DeviceConnectionWhereInput[]
    NOT?: DeviceConnectionWhereInput | DeviceConnectionWhereInput[]
    id?: StringFilter<"DeviceConnection"> | string
    userId?: StringFilter<"DeviceConnection"> | string
    deviceType?: StringFilter<"DeviceConnection"> | string
    deviceId?: StringFilter<"DeviceConnection"> | string
    deviceName?: StringNullableFilter<"DeviceConnection"> | string | null
    isConnected?: BoolFilter<"DeviceConnection"> | boolean
    lastSync?: DateTimeNullableFilter<"DeviceConnection"> | Date | string | null
    syncInterval?: IntNullableFilter<"DeviceConnection"> | number | null
    reliability?: FloatNullableFilter<"DeviceConnection"> | number | null
    batteryLevel?: IntNullableFilter<"DeviceConnection"> | number | null
    signalStrength?: FloatNullableFilter<"DeviceConnection"> | number | null
    permissions?: JsonFilter<"DeviceConnection">
    createdAt?: DateTimeFilter<"DeviceConnection"> | Date | string
    updatedAt?: DateTimeFilter<"DeviceConnection"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DeviceConnectionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceType?: SortOrder
    deviceId?: SortOrder
    deviceName?: SortOrderInput | SortOrder
    isConnected?: SortOrder
    lastSync?: SortOrderInput | SortOrder
    syncInterval?: SortOrderInput | SortOrder
    reliability?: SortOrderInput | SortOrder
    batteryLevel?: SortOrderInput | SortOrder
    signalStrength?: SortOrderInput | SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type DeviceConnectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_deviceType_deviceId?: DeviceConnectionUserIdDeviceTypeDeviceIdCompoundUniqueInput
    AND?: DeviceConnectionWhereInput | DeviceConnectionWhereInput[]
    OR?: DeviceConnectionWhereInput[]
    NOT?: DeviceConnectionWhereInput | DeviceConnectionWhereInput[]
    userId?: StringFilter<"DeviceConnection"> | string
    deviceType?: StringFilter<"DeviceConnection"> | string
    deviceId?: StringFilter<"DeviceConnection"> | string
    deviceName?: StringNullableFilter<"DeviceConnection"> | string | null
    isConnected?: BoolFilter<"DeviceConnection"> | boolean
    lastSync?: DateTimeNullableFilter<"DeviceConnection"> | Date | string | null
    syncInterval?: IntNullableFilter<"DeviceConnection"> | number | null
    reliability?: FloatNullableFilter<"DeviceConnection"> | number | null
    batteryLevel?: IntNullableFilter<"DeviceConnection"> | number | null
    signalStrength?: FloatNullableFilter<"DeviceConnection"> | number | null
    permissions?: JsonFilter<"DeviceConnection">
    createdAt?: DateTimeFilter<"DeviceConnection"> | Date | string
    updatedAt?: DateTimeFilter<"DeviceConnection"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_deviceType_deviceId">

  export type DeviceConnectionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceType?: SortOrder
    deviceId?: SortOrder
    deviceName?: SortOrderInput | SortOrder
    isConnected?: SortOrder
    lastSync?: SortOrderInput | SortOrder
    syncInterval?: SortOrderInput | SortOrder
    reliability?: SortOrderInput | SortOrder
    batteryLevel?: SortOrderInput | SortOrder
    signalStrength?: SortOrderInput | SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DeviceConnectionCountOrderByAggregateInput
    _avg?: DeviceConnectionAvgOrderByAggregateInput
    _max?: DeviceConnectionMaxOrderByAggregateInput
    _min?: DeviceConnectionMinOrderByAggregateInput
    _sum?: DeviceConnectionSumOrderByAggregateInput
  }

  export type DeviceConnectionScalarWhereWithAggregatesInput = {
    AND?: DeviceConnectionScalarWhereWithAggregatesInput | DeviceConnectionScalarWhereWithAggregatesInput[]
    OR?: DeviceConnectionScalarWhereWithAggregatesInput[]
    NOT?: DeviceConnectionScalarWhereWithAggregatesInput | DeviceConnectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DeviceConnection"> | string
    userId?: StringWithAggregatesFilter<"DeviceConnection"> | string
    deviceType?: StringWithAggregatesFilter<"DeviceConnection"> | string
    deviceId?: StringWithAggregatesFilter<"DeviceConnection"> | string
    deviceName?: StringNullableWithAggregatesFilter<"DeviceConnection"> | string | null
    isConnected?: BoolWithAggregatesFilter<"DeviceConnection"> | boolean
    lastSync?: DateTimeNullableWithAggregatesFilter<"DeviceConnection"> | Date | string | null
    syncInterval?: IntNullableWithAggregatesFilter<"DeviceConnection"> | number | null
    reliability?: FloatNullableWithAggregatesFilter<"DeviceConnection"> | number | null
    batteryLevel?: IntNullableWithAggregatesFilter<"DeviceConnection"> | number | null
    signalStrength?: FloatNullableWithAggregatesFilter<"DeviceConnection"> | number | null
    permissions?: JsonWithAggregatesFilter<"DeviceConnection">
    createdAt?: DateTimeWithAggregatesFilter<"DeviceConnection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DeviceConnection"> | Date | string
  }

  export type WellnessSessionWhereInput = {
    AND?: WellnessSessionWhereInput | WellnessSessionWhereInput[]
    OR?: WellnessSessionWhereInput[]
    NOT?: WellnessSessionWhereInput | WellnessSessionWhereInput[]
    id?: StringFilter<"WellnessSession"> | string
    userId?: StringFilter<"WellnessSession"> | string
    sessionType?: StringFilter<"WellnessSession"> | string
    title?: StringFilter<"WellnessSession"> | string
    duration?: IntFilter<"WellnessSession"> | number
    startingStress?: IntNullableFilter<"WellnessSession"> | number | null
    endingStress?: IntNullableFilter<"WellnessSession"> | number | null
    adaptations?: JsonNullableFilter<"WellnessSession">
    avgHeartRate?: IntNullableFilter<"WellnessSession"> | number | null
    stressReduction?: FloatNullableFilter<"WellnessSession"> | number | null
    userRating?: IntNullableFilter<"WellnessSession"> | number | null
    completionRate?: FloatNullableFilter<"WellnessSession"> | number | null
    startedAt?: DateTimeFilter<"WellnessSession"> | Date | string
    completedAt?: DateTimeNullableFilter<"WellnessSession"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type WellnessSessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionType?: SortOrder
    title?: SortOrder
    duration?: SortOrder
    startingStress?: SortOrderInput | SortOrder
    endingStress?: SortOrderInput | SortOrder
    adaptations?: SortOrderInput | SortOrder
    avgHeartRate?: SortOrderInput | SortOrder
    stressReduction?: SortOrderInput | SortOrder
    userRating?: SortOrderInput | SortOrder
    completionRate?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type WellnessSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WellnessSessionWhereInput | WellnessSessionWhereInput[]
    OR?: WellnessSessionWhereInput[]
    NOT?: WellnessSessionWhereInput | WellnessSessionWhereInput[]
    userId?: StringFilter<"WellnessSession"> | string
    sessionType?: StringFilter<"WellnessSession"> | string
    title?: StringFilter<"WellnessSession"> | string
    duration?: IntFilter<"WellnessSession"> | number
    startingStress?: IntNullableFilter<"WellnessSession"> | number | null
    endingStress?: IntNullableFilter<"WellnessSession"> | number | null
    adaptations?: JsonNullableFilter<"WellnessSession">
    avgHeartRate?: IntNullableFilter<"WellnessSession"> | number | null
    stressReduction?: FloatNullableFilter<"WellnessSession"> | number | null
    userRating?: IntNullableFilter<"WellnessSession"> | number | null
    completionRate?: FloatNullableFilter<"WellnessSession"> | number | null
    startedAt?: DateTimeFilter<"WellnessSession"> | Date | string
    completedAt?: DateTimeNullableFilter<"WellnessSession"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type WellnessSessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionType?: SortOrder
    title?: SortOrder
    duration?: SortOrder
    startingStress?: SortOrderInput | SortOrder
    endingStress?: SortOrderInput | SortOrder
    adaptations?: SortOrderInput | SortOrder
    avgHeartRate?: SortOrderInput | SortOrder
    stressReduction?: SortOrderInput | SortOrder
    userRating?: SortOrderInput | SortOrder
    completionRate?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: WellnessSessionCountOrderByAggregateInput
    _avg?: WellnessSessionAvgOrderByAggregateInput
    _max?: WellnessSessionMaxOrderByAggregateInput
    _min?: WellnessSessionMinOrderByAggregateInput
    _sum?: WellnessSessionSumOrderByAggregateInput
  }

  export type WellnessSessionScalarWhereWithAggregatesInput = {
    AND?: WellnessSessionScalarWhereWithAggregatesInput | WellnessSessionScalarWhereWithAggregatesInput[]
    OR?: WellnessSessionScalarWhereWithAggregatesInput[]
    NOT?: WellnessSessionScalarWhereWithAggregatesInput | WellnessSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WellnessSession"> | string
    userId?: StringWithAggregatesFilter<"WellnessSession"> | string
    sessionType?: StringWithAggregatesFilter<"WellnessSession"> | string
    title?: StringWithAggregatesFilter<"WellnessSession"> | string
    duration?: IntWithAggregatesFilter<"WellnessSession"> | number
    startingStress?: IntNullableWithAggregatesFilter<"WellnessSession"> | number | null
    endingStress?: IntNullableWithAggregatesFilter<"WellnessSession"> | number | null
    adaptations?: JsonNullableWithAggregatesFilter<"WellnessSession">
    avgHeartRate?: IntNullableWithAggregatesFilter<"WellnessSession"> | number | null
    stressReduction?: FloatNullableWithAggregatesFilter<"WellnessSession"> | number | null
    userRating?: IntNullableWithAggregatesFilter<"WellnessSession"> | number | null
    completionRate?: FloatNullableWithAggregatesFilter<"WellnessSession"> | number | null
    startedAt?: DateTimeWithAggregatesFilter<"WellnessSession"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"WellnessSession"> | Date | string | null
  }

  export type EnvironmentalDataWhereInput = {
    AND?: EnvironmentalDataWhereInput | EnvironmentalDataWhereInput[]
    OR?: EnvironmentalDataWhereInput[]
    NOT?: EnvironmentalDataWhereInput | EnvironmentalDataWhereInput[]
    id?: StringFilter<"EnvironmentalData"> | string
    userId?: StringFilter<"EnvironmentalData"> | string
    location?: StringNullableFilter<"EnvironmentalData"> | string | null
    timezone?: StringNullableFilter<"EnvironmentalData"> | string | null
    temperature?: FloatNullableFilter<"EnvironmentalData"> | number | null
    humidity?: FloatNullableFilter<"EnvironmentalData"> | number | null
    pressure?: FloatNullableFilter<"EnvironmentalData"> | number | null
    weather?: StringNullableFilter<"EnvironmentalData"> | string | null
    airQuality?: IntNullableFilter<"EnvironmentalData"> | number | null
    pollutants?: JsonNullableFilter<"EnvironmentalData">
    lightLevel?: FloatNullableFilter<"EnvironmentalData"> | number | null
    uvIndex?: FloatNullableFilter<"EnvironmentalData"> | number | null
    noiseLevel?: FloatNullableFilter<"EnvironmentalData"> | number | null
    timestamp?: DateTimeFilter<"EnvironmentalData"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type EnvironmentalDataOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    location?: SortOrderInput | SortOrder
    timezone?: SortOrderInput | SortOrder
    temperature?: SortOrderInput | SortOrder
    humidity?: SortOrderInput | SortOrder
    pressure?: SortOrderInput | SortOrder
    weather?: SortOrderInput | SortOrder
    airQuality?: SortOrderInput | SortOrder
    pollutants?: SortOrderInput | SortOrder
    lightLevel?: SortOrderInput | SortOrder
    uvIndex?: SortOrderInput | SortOrder
    noiseLevel?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type EnvironmentalDataWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EnvironmentalDataWhereInput | EnvironmentalDataWhereInput[]
    OR?: EnvironmentalDataWhereInput[]
    NOT?: EnvironmentalDataWhereInput | EnvironmentalDataWhereInput[]
    userId?: StringFilter<"EnvironmentalData"> | string
    location?: StringNullableFilter<"EnvironmentalData"> | string | null
    timezone?: StringNullableFilter<"EnvironmentalData"> | string | null
    temperature?: FloatNullableFilter<"EnvironmentalData"> | number | null
    humidity?: FloatNullableFilter<"EnvironmentalData"> | number | null
    pressure?: FloatNullableFilter<"EnvironmentalData"> | number | null
    weather?: StringNullableFilter<"EnvironmentalData"> | string | null
    airQuality?: IntNullableFilter<"EnvironmentalData"> | number | null
    pollutants?: JsonNullableFilter<"EnvironmentalData">
    lightLevel?: FloatNullableFilter<"EnvironmentalData"> | number | null
    uvIndex?: FloatNullableFilter<"EnvironmentalData"> | number | null
    noiseLevel?: FloatNullableFilter<"EnvironmentalData"> | number | null
    timestamp?: DateTimeFilter<"EnvironmentalData"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type EnvironmentalDataOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    location?: SortOrderInput | SortOrder
    timezone?: SortOrderInput | SortOrder
    temperature?: SortOrderInput | SortOrder
    humidity?: SortOrderInput | SortOrder
    pressure?: SortOrderInput | SortOrder
    weather?: SortOrderInput | SortOrder
    airQuality?: SortOrderInput | SortOrder
    pollutants?: SortOrderInput | SortOrder
    lightLevel?: SortOrderInput | SortOrder
    uvIndex?: SortOrderInput | SortOrder
    noiseLevel?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: EnvironmentalDataCountOrderByAggregateInput
    _avg?: EnvironmentalDataAvgOrderByAggregateInput
    _max?: EnvironmentalDataMaxOrderByAggregateInput
    _min?: EnvironmentalDataMinOrderByAggregateInput
    _sum?: EnvironmentalDataSumOrderByAggregateInput
  }

  export type EnvironmentalDataScalarWhereWithAggregatesInput = {
    AND?: EnvironmentalDataScalarWhereWithAggregatesInput | EnvironmentalDataScalarWhereWithAggregatesInput[]
    OR?: EnvironmentalDataScalarWhereWithAggregatesInput[]
    NOT?: EnvironmentalDataScalarWhereWithAggregatesInput | EnvironmentalDataScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EnvironmentalData"> | string
    userId?: StringWithAggregatesFilter<"EnvironmentalData"> | string
    location?: StringNullableWithAggregatesFilter<"EnvironmentalData"> | string | null
    timezone?: StringNullableWithAggregatesFilter<"EnvironmentalData"> | string | null
    temperature?: FloatNullableWithAggregatesFilter<"EnvironmentalData"> | number | null
    humidity?: FloatNullableWithAggregatesFilter<"EnvironmentalData"> | number | null
    pressure?: FloatNullableWithAggregatesFilter<"EnvironmentalData"> | number | null
    weather?: StringNullableWithAggregatesFilter<"EnvironmentalData"> | string | null
    airQuality?: IntNullableWithAggregatesFilter<"EnvironmentalData"> | number | null
    pollutants?: JsonNullableWithAggregatesFilter<"EnvironmentalData">
    lightLevel?: FloatNullableWithAggregatesFilter<"EnvironmentalData"> | number | null
    uvIndex?: FloatNullableWithAggregatesFilter<"EnvironmentalData"> | number | null
    noiseLevel?: FloatNullableWithAggregatesFilter<"EnvironmentalData"> | number | null
    timestamp?: DateTimeWithAggregatesFilter<"EnvironmentalData"> | Date | string
  }

  export type WellnessGroupWhereInput = {
    AND?: WellnessGroupWhereInput | WellnessGroupWhereInput[]
    OR?: WellnessGroupWhereInput[]
    NOT?: WellnessGroupWhereInput | WellnessGroupWhereInput[]
    id?: StringFilter<"WellnessGroup"> | string
    name?: StringFilter<"WellnessGroup"> | string
    description?: StringNullableFilter<"WellnessGroup"> | string | null
    type?: StringFilter<"WellnessGroup"> | string
    isPublic?: BoolFilter<"WellnessGroup"> | boolean
    maxMembers?: IntNullableFilter<"WellnessGroup"> | number | null
    groupGoals?: JsonNullableFilter<"WellnessGroup">
    createdAt?: DateTimeFilter<"WellnessGroup"> | Date | string
    updatedAt?: DateTimeFilter<"WellnessGroup"> | Date | string
    members?: GroupMembershipListRelationFilter
  }

  export type WellnessGroupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    isPublic?: SortOrder
    maxMembers?: SortOrderInput | SortOrder
    groupGoals?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    members?: GroupMembershipOrderByRelationAggregateInput
  }

  export type WellnessGroupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WellnessGroupWhereInput | WellnessGroupWhereInput[]
    OR?: WellnessGroupWhereInput[]
    NOT?: WellnessGroupWhereInput | WellnessGroupWhereInput[]
    name?: StringFilter<"WellnessGroup"> | string
    description?: StringNullableFilter<"WellnessGroup"> | string | null
    type?: StringFilter<"WellnessGroup"> | string
    isPublic?: BoolFilter<"WellnessGroup"> | boolean
    maxMembers?: IntNullableFilter<"WellnessGroup"> | number | null
    groupGoals?: JsonNullableFilter<"WellnessGroup">
    createdAt?: DateTimeFilter<"WellnessGroup"> | Date | string
    updatedAt?: DateTimeFilter<"WellnessGroup"> | Date | string
    members?: GroupMembershipListRelationFilter
  }, "id">

  export type WellnessGroupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    isPublic?: SortOrder
    maxMembers?: SortOrderInput | SortOrder
    groupGoals?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WellnessGroupCountOrderByAggregateInput
    _avg?: WellnessGroupAvgOrderByAggregateInput
    _max?: WellnessGroupMaxOrderByAggregateInput
    _min?: WellnessGroupMinOrderByAggregateInput
    _sum?: WellnessGroupSumOrderByAggregateInput
  }

  export type WellnessGroupScalarWhereWithAggregatesInput = {
    AND?: WellnessGroupScalarWhereWithAggregatesInput | WellnessGroupScalarWhereWithAggregatesInput[]
    OR?: WellnessGroupScalarWhereWithAggregatesInput[]
    NOT?: WellnessGroupScalarWhereWithAggregatesInput | WellnessGroupScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WellnessGroup"> | string
    name?: StringWithAggregatesFilter<"WellnessGroup"> | string
    description?: StringNullableWithAggregatesFilter<"WellnessGroup"> | string | null
    type?: StringWithAggregatesFilter<"WellnessGroup"> | string
    isPublic?: BoolWithAggregatesFilter<"WellnessGroup"> | boolean
    maxMembers?: IntNullableWithAggregatesFilter<"WellnessGroup"> | number | null
    groupGoals?: JsonNullableWithAggregatesFilter<"WellnessGroup">
    createdAt?: DateTimeWithAggregatesFilter<"WellnessGroup"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WellnessGroup"> | Date | string
  }

  export type GroupMembershipWhereInput = {
    AND?: GroupMembershipWhereInput | GroupMembershipWhereInput[]
    OR?: GroupMembershipWhereInput[]
    NOT?: GroupMembershipWhereInput | GroupMembershipWhereInput[]
    id?: StringFilter<"GroupMembership"> | string
    userId?: StringFilter<"GroupMembership"> | string
    groupId?: StringFilter<"GroupMembership"> | string
    role?: StringFilter<"GroupMembership"> | string
    shareProgress?: BoolFilter<"GroupMembership"> | boolean
    shareGoals?: BoolFilter<"GroupMembership"> | boolean
    joinedAt?: DateTimeFilter<"GroupMembership"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    group?: XOR<WellnessGroupScalarRelationFilter, WellnessGroupWhereInput>
  }

  export type GroupMembershipOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
    role?: SortOrder
    shareProgress?: SortOrder
    shareGoals?: SortOrder
    joinedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    group?: WellnessGroupOrderByWithRelationInput
  }

  export type GroupMembershipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_groupId?: GroupMembershipUserIdGroupIdCompoundUniqueInput
    AND?: GroupMembershipWhereInput | GroupMembershipWhereInput[]
    OR?: GroupMembershipWhereInput[]
    NOT?: GroupMembershipWhereInput | GroupMembershipWhereInput[]
    userId?: StringFilter<"GroupMembership"> | string
    groupId?: StringFilter<"GroupMembership"> | string
    role?: StringFilter<"GroupMembership"> | string
    shareProgress?: BoolFilter<"GroupMembership"> | boolean
    shareGoals?: BoolFilter<"GroupMembership"> | boolean
    joinedAt?: DateTimeFilter<"GroupMembership"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    group?: XOR<WellnessGroupScalarRelationFilter, WellnessGroupWhereInput>
  }, "id" | "userId_groupId">

  export type GroupMembershipOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
    role?: SortOrder
    shareProgress?: SortOrder
    shareGoals?: SortOrder
    joinedAt?: SortOrder
    _count?: GroupMembershipCountOrderByAggregateInput
    _max?: GroupMembershipMaxOrderByAggregateInput
    _min?: GroupMembershipMinOrderByAggregateInput
  }

  export type GroupMembershipScalarWhereWithAggregatesInput = {
    AND?: GroupMembershipScalarWhereWithAggregatesInput | GroupMembershipScalarWhereWithAggregatesInput[]
    OR?: GroupMembershipScalarWhereWithAggregatesInput[]
    NOT?: GroupMembershipScalarWhereWithAggregatesInput | GroupMembershipScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GroupMembership"> | string
    userId?: StringWithAggregatesFilter<"GroupMembership"> | string
    groupId?: StringWithAggregatesFilter<"GroupMembership"> | string
    role?: StringWithAggregatesFilter<"GroupMembership"> | string
    shareProgress?: BoolWithAggregatesFilter<"GroupMembership"> | boolean
    shareGoals?: BoolWithAggregatesFilter<"GroupMembership"> | boolean
    joinedAt?: DateTimeWithAggregatesFilter<"GroupMembership"> | Date | string
  }

  export type WorkplaceIntegrationWhereInput = {
    AND?: WorkplaceIntegrationWhereInput | WorkplaceIntegrationWhereInput[]
    OR?: WorkplaceIntegrationWhereInput[]
    NOT?: WorkplaceIntegrationWhereInput | WorkplaceIntegrationWhereInput[]
    id?: StringFilter<"WorkplaceIntegration"> | string
    userId?: StringFilter<"WorkplaceIntegration"> | string
    platform?: StringFilter<"WorkplaceIntegration"> | string
    enabled?: BoolFilter<"WorkplaceIntegration"> | boolean
    frequency?: StringFilter<"WorkplaceIntegration"> | string
    canSuggestBreaks?: BoolFilter<"WorkplaceIntegration"> | boolean
    canAccessCalendar?: BoolFilter<"WorkplaceIntegration"> | boolean
    canSendReminders?: BoolFilter<"WorkplaceIntegration"> | boolean
    workHours?: JsonNullableFilter<"WorkplaceIntegration">
    breakPreferences?: JsonNullableFilter<"WorkplaceIntegration">
    createdAt?: DateTimeFilter<"WorkplaceIntegration"> | Date | string
    updatedAt?: DateTimeFilter<"WorkplaceIntegration"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type WorkplaceIntegrationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    platform?: SortOrder
    enabled?: SortOrder
    frequency?: SortOrder
    canSuggestBreaks?: SortOrder
    canAccessCalendar?: SortOrder
    canSendReminders?: SortOrder
    workHours?: SortOrderInput | SortOrder
    breakPreferences?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type WorkplaceIntegrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_platform?: WorkplaceIntegrationUserIdPlatformCompoundUniqueInput
    AND?: WorkplaceIntegrationWhereInput | WorkplaceIntegrationWhereInput[]
    OR?: WorkplaceIntegrationWhereInput[]
    NOT?: WorkplaceIntegrationWhereInput | WorkplaceIntegrationWhereInput[]
    userId?: StringFilter<"WorkplaceIntegration"> | string
    platform?: StringFilter<"WorkplaceIntegration"> | string
    enabled?: BoolFilter<"WorkplaceIntegration"> | boolean
    frequency?: StringFilter<"WorkplaceIntegration"> | string
    canSuggestBreaks?: BoolFilter<"WorkplaceIntegration"> | boolean
    canAccessCalendar?: BoolFilter<"WorkplaceIntegration"> | boolean
    canSendReminders?: BoolFilter<"WorkplaceIntegration"> | boolean
    workHours?: JsonNullableFilter<"WorkplaceIntegration">
    breakPreferences?: JsonNullableFilter<"WorkplaceIntegration">
    createdAt?: DateTimeFilter<"WorkplaceIntegration"> | Date | string
    updatedAt?: DateTimeFilter<"WorkplaceIntegration"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_platform">

  export type WorkplaceIntegrationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    platform?: SortOrder
    enabled?: SortOrder
    frequency?: SortOrder
    canSuggestBreaks?: SortOrder
    canAccessCalendar?: SortOrder
    canSendReminders?: SortOrder
    workHours?: SortOrderInput | SortOrder
    breakPreferences?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkplaceIntegrationCountOrderByAggregateInput
    _max?: WorkplaceIntegrationMaxOrderByAggregateInput
    _min?: WorkplaceIntegrationMinOrderByAggregateInput
  }

  export type WorkplaceIntegrationScalarWhereWithAggregatesInput = {
    AND?: WorkplaceIntegrationScalarWhereWithAggregatesInput | WorkplaceIntegrationScalarWhereWithAggregatesInput[]
    OR?: WorkplaceIntegrationScalarWhereWithAggregatesInput[]
    NOT?: WorkplaceIntegrationScalarWhereWithAggregatesInput | WorkplaceIntegrationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkplaceIntegration"> | string
    userId?: StringWithAggregatesFilter<"WorkplaceIntegration"> | string
    platform?: StringWithAggregatesFilter<"WorkplaceIntegration"> | string
    enabled?: BoolWithAggregatesFilter<"WorkplaceIntegration"> | boolean
    frequency?: StringWithAggregatesFilter<"WorkplaceIntegration"> | string
    canSuggestBreaks?: BoolWithAggregatesFilter<"WorkplaceIntegration"> | boolean
    canAccessCalendar?: BoolWithAggregatesFilter<"WorkplaceIntegration"> | boolean
    canSendReminders?: BoolWithAggregatesFilter<"WorkplaceIntegration"> | boolean
    workHours?: JsonNullableWithAggregatesFilter<"WorkplaceIntegration">
    breakPreferences?: JsonNullableWithAggregatesFilter<"WorkplaceIntegration">
    createdAt?: DateTimeWithAggregatesFilter<"WorkplaceIntegration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WorkplaceIntegration"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timezone?: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: boolean
    biometricSyncEnabled?: boolean
    baseStressLevel?: number | null
    sleepGoal?: number | null
    stepsGoal?: number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionCreateNestedManyWithoutUserInput
    account?: AccountCreateNestedOneWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    habits?: HabitCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    biometricData?: BiometricDataCreateNestedManyWithoutUserInput
    moodEntries?: MoodEntryCreateNestedManyWithoutUserInput
    stressPredictions?: StressPredictionCreateNestedManyWithoutUserInput
    challengeParticipants?: ChallengeParticipantCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutUserInput
    deviceConnections?: DeviceConnectionCreateNestedManyWithoutUserInput
    wellnessSessions?: WellnessSessionCreateNestedManyWithoutUserInput
    environmentalData?: EnvironmentalDataCreateNestedManyWithoutUserInput
    collaborativeGroups?: GroupMembershipCreateNestedManyWithoutUserInput
    workplaceIntegrations?: WorkplaceIntegrationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timezone?: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: boolean
    biometricSyncEnabled?: boolean
    baseStressLevel?: number | null
    sleepGoal?: number | null
    stepsGoal?: number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    account?: AccountUncheckedCreateNestedOneWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    habits?: HabitUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    biometricData?: BiometricDataUncheckedCreateNestedManyWithoutUserInput
    moodEntries?: MoodEntryUncheckedCreateNestedManyWithoutUserInput
    stressPredictions?: StressPredictionUncheckedCreateNestedManyWithoutUserInput
    challengeParticipants?: ChallengeParticipantUncheckedCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutUserInput
    deviceConnections?: DeviceConnectionUncheckedCreateNestedManyWithoutUserInput
    wellnessSessions?: WellnessSessionUncheckedCreateNestedManyWithoutUserInput
    environmentalData?: EnvironmentalDataUncheckedCreateNestedManyWithoutUserInput
    collaborativeGroups?: GroupMembershipUncheckedCreateNestedManyWithoutUserInput
    workplaceIntegrations?: WorkplaceIntegrationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: BoolFieldUpdateOperationsInput | boolean
    biometricSyncEnabled?: BoolFieldUpdateOperationsInput | boolean
    baseStressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    sleepGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    stepsGoal?: NullableIntFieldUpdateOperationsInput | number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUpdateManyWithoutUserNestedInput
    account?: AccountUpdateOneWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    habits?: HabitUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    biometricData?: BiometricDataUpdateManyWithoutUserNestedInput
    moodEntries?: MoodEntryUpdateManyWithoutUserNestedInput
    stressPredictions?: StressPredictionUpdateManyWithoutUserNestedInput
    challengeParticipants?: ChallengeParticipantUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUpdateManyWithoutUserNestedInput
    deviceConnections?: DeviceConnectionUpdateManyWithoutUserNestedInput
    wellnessSessions?: WellnessSessionUpdateManyWithoutUserNestedInput
    environmentalData?: EnvironmentalDataUpdateManyWithoutUserNestedInput
    collaborativeGroups?: GroupMembershipUpdateManyWithoutUserNestedInput
    workplaceIntegrations?: WorkplaceIntegrationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: BoolFieldUpdateOperationsInput | boolean
    biometricSyncEnabled?: BoolFieldUpdateOperationsInput | boolean
    baseStressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    sleepGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    stepsGoal?: NullableIntFieldUpdateOperationsInput | number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    account?: AccountUncheckedUpdateOneWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    habits?: HabitUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    biometricData?: BiometricDataUncheckedUpdateManyWithoutUserNestedInput
    moodEntries?: MoodEntryUncheckedUpdateManyWithoutUserNestedInput
    stressPredictions?: StressPredictionUncheckedUpdateManyWithoutUserNestedInput
    challengeParticipants?: ChallengeParticipantUncheckedUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutUserNestedInput
    deviceConnections?: DeviceConnectionUncheckedUpdateManyWithoutUserNestedInput
    wellnessSessions?: WellnessSessionUncheckedUpdateManyWithoutUserNestedInput
    environmentalData?: EnvironmentalDataUncheckedUpdateManyWithoutUserNestedInput
    collaborativeGroups?: GroupMembershipUncheckedUpdateManyWithoutUserNestedInput
    workplaceIntegrations?: WorkplaceIntegrationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timezone?: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: boolean
    biometricSyncEnabled?: boolean
    baseStressLevel?: number | null
    sleepGoal?: number | null
    stepsGoal?: number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: BoolFieldUpdateOperationsInput | boolean
    biometricSyncEnabled?: BoolFieldUpdateOperationsInput | boolean
    baseStressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    sleepGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    stepsGoal?: NullableIntFieldUpdateOperationsInput | number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: BoolFieldUpdateOperationsInput | boolean
    biometricSyncEnabled?: BoolFieldUpdateOperationsInput | boolean
    baseStressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    sleepGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    stepsGoal?: NullableIntFieldUpdateOperationsInput | number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SessionCreateInput = {
    id?: string
    token: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    idToken?: string | null
    password?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAccountInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    idToken?: string | null
    password?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    idToken?: string | null
    password?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUncheckedCreateInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateManyInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalEntryCreateInput = {
    id?: string
    content: string
    date: Date | string
    mood?: string | null
    stressLevel?: number | null
    emotionScores?: NullableJsonNullValueInput | InputJsonValue
    topics?: NullableJsonNullValueInput | InputJsonValue
    sentiment?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutJournalEntriesInput
  }

  export type JournalEntryUncheckedCreateInput = {
    id?: string
    userId: string
    content: string
    date: Date | string
    mood?: string | null
    stressLevel?: number | null
    emotionScores?: NullableJsonNullValueInput | InputJsonValue
    topics?: NullableJsonNullValueInput | InputJsonValue
    sentiment?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JournalEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    mood?: NullableStringFieldUpdateOperationsInput | string | null
    stressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    emotionScores?: NullableJsonNullValueInput | InputJsonValue
    topics?: NullableJsonNullValueInput | InputJsonValue
    sentiment?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutJournalEntriesNestedInput
  }

  export type JournalEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    mood?: NullableStringFieldUpdateOperationsInput | string | null
    stressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    emotionScores?: NullableJsonNullValueInput | InputJsonValue
    topics?: NullableJsonNullValueInput | InputJsonValue
    sentiment?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalEntryCreateManyInput = {
    id?: string
    userId: string
    content: string
    date: Date | string
    mood?: string | null
    stressLevel?: number | null
    emotionScores?: NullableJsonNullValueInput | InputJsonValue
    topics?: NullableJsonNullValueInput | InputJsonValue
    sentiment?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JournalEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    mood?: NullableStringFieldUpdateOperationsInput | string | null
    stressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    emotionScores?: NullableJsonNullValueInput | InputJsonValue
    topics?: NullableJsonNullValueInput | InputJsonValue
    sentiment?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    mood?: NullableStringFieldUpdateOperationsInput | string | null
    stressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    emotionScores?: NullableJsonNullValueInput | InputJsonValue
    topics?: NullableJsonNullValueInput | InputJsonValue
    sentiment?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HabitCreateInput = {
    id?: string
    title: string
    isCompleted?: boolean
    date: Date | string
    aiSuggested?: boolean
    adaptiveReminder?: NullableJsonNullValueInput | InputJsonValue
    difficultyLevel?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutHabitsInput
  }

  export type HabitUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    isCompleted?: boolean
    date: Date | string
    aiSuggested?: boolean
    adaptiveReminder?: NullableJsonNullValueInput | InputJsonValue
    difficultyLevel?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HabitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    aiSuggested?: BoolFieldUpdateOperationsInput | boolean
    adaptiveReminder?: NullableJsonNullValueInput | InputJsonValue
    difficultyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutHabitsNestedInput
  }

  export type HabitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    aiSuggested?: BoolFieldUpdateOperationsInput | boolean
    adaptiveReminder?: NullableJsonNullValueInput | InputJsonValue
    difficultyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HabitCreateManyInput = {
    id?: string
    userId: string
    title: string
    isCompleted?: boolean
    date: Date | string
    aiSuggested?: boolean
    adaptiveReminder?: NullableJsonNullValueInput | InputJsonValue
    difficultyLevel?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HabitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    aiSuggested?: BoolFieldUpdateOperationsInput | boolean
    adaptiveReminder?: NullableJsonNullValueInput | InputJsonValue
    difficultyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HabitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    aiSuggested?: BoolFieldUpdateOperationsInput | boolean
    adaptiveReminder?: NullableJsonNullValueInput | InputJsonValue
    difficultyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassCreateInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    durationMins?: number
    instructor: string
    imageUrl?: string | null
    capacity?: number
    intensity?: string
    stressLevel?: number | null
    aiOptimized?: boolean
    adaptiveContent?: NullableJsonNullValueInput | InputJsonValue
    prerequisites?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    durationMins?: number
    instructor: string
    imageUrl?: string | null
    capacity?: number
    intensity?: string
    stressLevel?: number | null
    aiOptimized?: boolean
    adaptiveContent?: NullableJsonNullValueInput | InputJsonValue
    prerequisites?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMins?: IntFieldUpdateOperationsInput | number
    instructor?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    intensity?: StringFieldUpdateOperationsInput | string
    stressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    aiOptimized?: BoolFieldUpdateOperationsInput | boolean
    adaptiveContent?: NullableJsonNullValueInput | InputJsonValue
    prerequisites?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMins?: IntFieldUpdateOperationsInput | number
    instructor?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    intensity?: StringFieldUpdateOperationsInput | string
    stressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    aiOptimized?: BoolFieldUpdateOperationsInput | boolean
    adaptiveContent?: NullableJsonNullValueInput | InputJsonValue
    prerequisites?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    durationMins?: number
    instructor: string
    imageUrl?: string | null
    capacity?: number
    intensity?: string
    stressLevel?: number | null
    aiOptimized?: boolean
    adaptiveContent?: NullableJsonNullValueInput | InputJsonValue
    prerequisites?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMins?: IntFieldUpdateOperationsInput | number
    instructor?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    intensity?: StringFieldUpdateOperationsInput | string
    stressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    aiOptimized?: BoolFieldUpdateOperationsInput | boolean
    adaptiveContent?: NullableJsonNullValueInput | InputJsonValue
    prerequisites?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMins?: IntFieldUpdateOperationsInput | number
    instructor?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    intensity?: StringFieldUpdateOperationsInput | string
    stressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    aiOptimized?: BoolFieldUpdateOperationsInput | boolean
    adaptiveContent?: NullableJsonNullValueInput | InputJsonValue
    prerequisites?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateInput = {
    id?: string
    aiSuggested?: boolean
    predictedEffectiveness?: number | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutBookingsInput
    class: ClassCreateNestedOneWithoutBookingsInput
  }

  export type BookingUncheckedCreateInput = {
    id?: string
    userId: string
    classId: string
    aiSuggested?: boolean
    predictedEffectiveness?: number | null
    createdAt?: Date | string
  }

  export type BookingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    aiSuggested?: BoolFieldUpdateOperationsInput | boolean
    predictedEffectiveness?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    class?: ClassUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type BookingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    aiSuggested?: BoolFieldUpdateOperationsInput | boolean
    predictedEffectiveness?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateManyInput = {
    id?: string
    userId: string
    classId: string
    aiSuggested?: boolean
    predictedEffectiveness?: number | null
    createdAt?: Date | string
  }

  export type BookingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    aiSuggested?: BoolFieldUpdateOperationsInput | boolean
    predictedEffectiveness?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    aiSuggested?: BoolFieldUpdateOperationsInput | boolean
    predictedEffectiveness?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BiometricDataCreateInput = {
    id?: string
    heartRate?: number | null
    heartRateVariability?: number | null
    stressLevel?: number | null
    sleepQuality?: number | null
    sleepDuration?: number | null
    steps?: number | null
    calories?: number | null
    respiratoryRate?: number | null
    skinTemperature?: number | null
    bloodPressureSystolic?: number | null
    bloodPressureDiastolic?: number | null
    oxygenSaturation?: number | null
    wellnessScore?: number | null
    energyLevel?: number | null
    recoveryScore?: number | null
    deviceType?: string | null
    deviceId?: string | null
    accuracy?: number | null
    timestamp?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBiometricDataInput
  }

  export type BiometricDataUncheckedCreateInput = {
    id?: string
    userId: string
    heartRate?: number | null
    heartRateVariability?: number | null
    stressLevel?: number | null
    sleepQuality?: number | null
    sleepDuration?: number | null
    steps?: number | null
    calories?: number | null
    respiratoryRate?: number | null
    skinTemperature?: number | null
    bloodPressureSystolic?: number | null
    bloodPressureDiastolic?: number | null
    oxygenSaturation?: number | null
    wellnessScore?: number | null
    energyLevel?: number | null
    recoveryScore?: number | null
    deviceType?: string | null
    deviceId?: string | null
    accuracy?: number | null
    timestamp?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BiometricDataUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    heartRateVariability?: NullableFloatFieldUpdateOperationsInput | number | null
    stressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    sleepQuality?: NullableIntFieldUpdateOperationsInput | number | null
    sleepDuration?: NullableFloatFieldUpdateOperationsInput | number | null
    steps?: NullableIntFieldUpdateOperationsInput | number | null
    calories?: NullableIntFieldUpdateOperationsInput | number | null
    respiratoryRate?: NullableIntFieldUpdateOperationsInput | number | null
    skinTemperature?: NullableFloatFieldUpdateOperationsInput | number | null
    bloodPressureSystolic?: NullableIntFieldUpdateOperationsInput | number | null
    bloodPressureDiastolic?: NullableIntFieldUpdateOperationsInput | number | null
    oxygenSaturation?: NullableFloatFieldUpdateOperationsInput | number | null
    wellnessScore?: NullableFloatFieldUpdateOperationsInput | number | null
    energyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    recoveryScore?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBiometricDataNestedInput
  }

  export type BiometricDataUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    heartRateVariability?: NullableFloatFieldUpdateOperationsInput | number | null
    stressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    sleepQuality?: NullableIntFieldUpdateOperationsInput | number | null
    sleepDuration?: NullableFloatFieldUpdateOperationsInput | number | null
    steps?: NullableIntFieldUpdateOperationsInput | number | null
    calories?: NullableIntFieldUpdateOperationsInput | number | null
    respiratoryRate?: NullableIntFieldUpdateOperationsInput | number | null
    skinTemperature?: NullableFloatFieldUpdateOperationsInput | number | null
    bloodPressureSystolic?: NullableIntFieldUpdateOperationsInput | number | null
    bloodPressureDiastolic?: NullableIntFieldUpdateOperationsInput | number | null
    oxygenSaturation?: NullableFloatFieldUpdateOperationsInput | number | null
    wellnessScore?: NullableFloatFieldUpdateOperationsInput | number | null
    energyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    recoveryScore?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BiometricDataCreateManyInput = {
    id?: string
    userId: string
    heartRate?: number | null
    heartRateVariability?: number | null
    stressLevel?: number | null
    sleepQuality?: number | null
    sleepDuration?: number | null
    steps?: number | null
    calories?: number | null
    respiratoryRate?: number | null
    skinTemperature?: number | null
    bloodPressureSystolic?: number | null
    bloodPressureDiastolic?: number | null
    oxygenSaturation?: number | null
    wellnessScore?: number | null
    energyLevel?: number | null
    recoveryScore?: number | null
    deviceType?: string | null
    deviceId?: string | null
    accuracy?: number | null
    timestamp?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BiometricDataUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    heartRateVariability?: NullableFloatFieldUpdateOperationsInput | number | null
    stressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    sleepQuality?: NullableIntFieldUpdateOperationsInput | number | null
    sleepDuration?: NullableFloatFieldUpdateOperationsInput | number | null
    steps?: NullableIntFieldUpdateOperationsInput | number | null
    calories?: NullableIntFieldUpdateOperationsInput | number | null
    respiratoryRate?: NullableIntFieldUpdateOperationsInput | number | null
    skinTemperature?: NullableFloatFieldUpdateOperationsInput | number | null
    bloodPressureSystolic?: NullableIntFieldUpdateOperationsInput | number | null
    bloodPressureDiastolic?: NullableIntFieldUpdateOperationsInput | number | null
    oxygenSaturation?: NullableFloatFieldUpdateOperationsInput | number | null
    wellnessScore?: NullableFloatFieldUpdateOperationsInput | number | null
    energyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    recoveryScore?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BiometricDataUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    heartRateVariability?: NullableFloatFieldUpdateOperationsInput | number | null
    stressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    sleepQuality?: NullableIntFieldUpdateOperationsInput | number | null
    sleepDuration?: NullableFloatFieldUpdateOperationsInput | number | null
    steps?: NullableIntFieldUpdateOperationsInput | number | null
    calories?: NullableIntFieldUpdateOperationsInput | number | null
    respiratoryRate?: NullableIntFieldUpdateOperationsInput | number | null
    skinTemperature?: NullableFloatFieldUpdateOperationsInput | number | null
    bloodPressureSystolic?: NullableIntFieldUpdateOperationsInput | number | null
    bloodPressureDiastolic?: NullableIntFieldUpdateOperationsInput | number | null
    oxygenSaturation?: NullableFloatFieldUpdateOperationsInput | number | null
    wellnessScore?: NullableFloatFieldUpdateOperationsInput | number | null
    energyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    recoveryScore?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MoodEntryCreateInput = {
    id?: string
    mood: string
    confidence: number
    source: string
    emotions?: NullableJsonNullValueInput | InputJsonValue
    valence?: number | null
    arousal?: number | null
    location?: string | null
    weather?: string | null
    timeOfDay?: string | null
    activity?: string | null
    voiceFeatures?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMoodEntriesInput
  }

  export type MoodEntryUncheckedCreateInput = {
    id?: string
    userId: string
    mood: string
    confidence: number
    source: string
    emotions?: NullableJsonNullValueInput | InputJsonValue
    valence?: number | null
    arousal?: number | null
    location?: string | null
    weather?: string | null
    timeOfDay?: string | null
    activity?: string | null
    voiceFeatures?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MoodEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mood?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    emotions?: NullableJsonNullValueInput | InputJsonValue
    valence?: NullableFloatFieldUpdateOperationsInput | number | null
    arousal?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    weather?: NullableStringFieldUpdateOperationsInput | string | null
    timeOfDay?: NullableStringFieldUpdateOperationsInput | string | null
    activity?: NullableStringFieldUpdateOperationsInput | string | null
    voiceFeatures?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMoodEntriesNestedInput
  }

  export type MoodEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mood?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    emotions?: NullableJsonNullValueInput | InputJsonValue
    valence?: NullableFloatFieldUpdateOperationsInput | number | null
    arousal?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    weather?: NullableStringFieldUpdateOperationsInput | string | null
    timeOfDay?: NullableStringFieldUpdateOperationsInput | string | null
    activity?: NullableStringFieldUpdateOperationsInput | string | null
    voiceFeatures?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MoodEntryCreateManyInput = {
    id?: string
    userId: string
    mood: string
    confidence: number
    source: string
    emotions?: NullableJsonNullValueInput | InputJsonValue
    valence?: number | null
    arousal?: number | null
    location?: string | null
    weather?: string | null
    timeOfDay?: string | null
    activity?: string | null
    voiceFeatures?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MoodEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    mood?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    emotions?: NullableJsonNullValueInput | InputJsonValue
    valence?: NullableFloatFieldUpdateOperationsInput | number | null
    arousal?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    weather?: NullableStringFieldUpdateOperationsInput | string | null
    timeOfDay?: NullableStringFieldUpdateOperationsInput | string | null
    activity?: NullableStringFieldUpdateOperationsInput | string | null
    voiceFeatures?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MoodEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mood?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    emotions?: NullableJsonNullValueInput | InputJsonValue
    valence?: NullableFloatFieldUpdateOperationsInput | number | null
    arousal?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    weather?: NullableStringFieldUpdateOperationsInput | string | null
    timeOfDay?: NullableStringFieldUpdateOperationsInput | string | null
    activity?: NullableStringFieldUpdateOperationsInput | string | null
    voiceFeatures?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StressPredictionCreateInput = {
    id?: string
    predictedStressLevel: number
    confidence: number
    predictedAt: Date | string
    modelVersion?: string | null
    triggers?: NullableJsonNullValueInput | InputJsonValue
    riskFactors?: NullableJsonNullValueInput | InputJsonValue
    recommendedInterventions?: NullableJsonNullValueInput | InputJsonValue
    preventionStrategies?: NullableJsonNullValueInput | InputJsonValue
    actualStressLevel?: number | null
    wasAccurate?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStressPredictionsInput
  }

  export type StressPredictionUncheckedCreateInput = {
    id?: string
    userId: string
    predictedStressLevel: number
    confidence: number
    predictedAt: Date | string
    modelVersion?: string | null
    triggers?: NullableJsonNullValueInput | InputJsonValue
    riskFactors?: NullableJsonNullValueInput | InputJsonValue
    recommendedInterventions?: NullableJsonNullValueInput | InputJsonValue
    preventionStrategies?: NullableJsonNullValueInput | InputJsonValue
    actualStressLevel?: number | null
    wasAccurate?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StressPredictionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    predictedStressLevel?: IntFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    predictedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    triggers?: NullableJsonNullValueInput | InputJsonValue
    riskFactors?: NullableJsonNullValueInput | InputJsonValue
    recommendedInterventions?: NullableJsonNullValueInput | InputJsonValue
    preventionStrategies?: NullableJsonNullValueInput | InputJsonValue
    actualStressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    wasAccurate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStressPredictionsNestedInput
  }

  export type StressPredictionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    predictedStressLevel?: IntFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    predictedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    triggers?: NullableJsonNullValueInput | InputJsonValue
    riskFactors?: NullableJsonNullValueInput | InputJsonValue
    recommendedInterventions?: NullableJsonNullValueInput | InputJsonValue
    preventionStrategies?: NullableJsonNullValueInput | InputJsonValue
    actualStressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    wasAccurate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StressPredictionCreateManyInput = {
    id?: string
    userId: string
    predictedStressLevel: number
    confidence: number
    predictedAt: Date | string
    modelVersion?: string | null
    triggers?: NullableJsonNullValueInput | InputJsonValue
    riskFactors?: NullableJsonNullValueInput | InputJsonValue
    recommendedInterventions?: NullableJsonNullValueInput | InputJsonValue
    preventionStrategies?: NullableJsonNullValueInput | InputJsonValue
    actualStressLevel?: number | null
    wasAccurate?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StressPredictionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    predictedStressLevel?: IntFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    predictedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    triggers?: NullableJsonNullValueInput | InputJsonValue
    riskFactors?: NullableJsonNullValueInput | InputJsonValue
    recommendedInterventions?: NullableJsonNullValueInput | InputJsonValue
    preventionStrategies?: NullableJsonNullValueInput | InputJsonValue
    actualStressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    wasAccurate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StressPredictionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    predictedStressLevel?: IntFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    predictedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    triggers?: NullableJsonNullValueInput | InputJsonValue
    riskFactors?: NullableJsonNullValueInput | InputJsonValue
    recommendedInterventions?: NullableJsonNullValueInput | InputJsonValue
    preventionStrategies?: NullableJsonNullValueInput | InputJsonValue
    actualStressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    wasAccurate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WellnessChallengeCreateInput = {
    id?: string
    title: string
    description: string
    type: string
    duration: number
    target: JsonNullValueInput | InputJsonValue
    reward?: string | null
    isActive?: boolean
    startDate: Date | string
    endDate: Date | string
    maxParticipants?: number | null
    isPublic?: boolean
    teamBased?: boolean
    aiGenerated?: boolean
    adaptiveDifficulty?: boolean
    personalizedGoals?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: ChallengeParticipantCreateNestedManyWithoutChallengeInput
  }

  export type WellnessChallengeUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    type: string
    duration: number
    target: JsonNullValueInput | InputJsonValue
    reward?: string | null
    isActive?: boolean
    startDate: Date | string
    endDate: Date | string
    maxParticipants?: number | null
    isPublic?: boolean
    teamBased?: boolean
    aiGenerated?: boolean
    adaptiveDifficulty?: boolean
    personalizedGoals?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: ChallengeParticipantUncheckedCreateNestedManyWithoutChallengeInput
  }

  export type WellnessChallengeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    target?: JsonNullValueInput | InputJsonValue
    reward?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    teamBased?: BoolFieldUpdateOperationsInput | boolean
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    adaptiveDifficulty?: BoolFieldUpdateOperationsInput | boolean
    personalizedGoals?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ChallengeParticipantUpdateManyWithoutChallengeNestedInput
  }

  export type WellnessChallengeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    target?: JsonNullValueInput | InputJsonValue
    reward?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    teamBased?: BoolFieldUpdateOperationsInput | boolean
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    adaptiveDifficulty?: BoolFieldUpdateOperationsInput | boolean
    personalizedGoals?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ChallengeParticipantUncheckedUpdateManyWithoutChallengeNestedInput
  }

  export type WellnessChallengeCreateManyInput = {
    id?: string
    title: string
    description: string
    type: string
    duration: number
    target: JsonNullValueInput | InputJsonValue
    reward?: string | null
    isActive?: boolean
    startDate: Date | string
    endDate: Date | string
    maxParticipants?: number | null
    isPublic?: boolean
    teamBased?: boolean
    aiGenerated?: boolean
    adaptiveDifficulty?: boolean
    personalizedGoals?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WellnessChallengeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    target?: JsonNullValueInput | InputJsonValue
    reward?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    teamBased?: BoolFieldUpdateOperationsInput | boolean
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    adaptiveDifficulty?: BoolFieldUpdateOperationsInput | boolean
    personalizedGoals?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WellnessChallengeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    target?: JsonNullValueInput | InputJsonValue
    reward?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    teamBased?: BoolFieldUpdateOperationsInput | boolean
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    adaptiveDifficulty?: BoolFieldUpdateOperationsInput | boolean
    personalizedGoals?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeParticipantCreateInput = {
    id?: string
    progress: JsonNullValueInput | InputJsonValue
    completed?: boolean
    currentStreak?: number
    bestStreak?: number
    rank?: number | null
    joinedAt?: Date | string
    completedAt?: Date | string | null
    user: UserCreateNestedOneWithoutChallengeParticipantsInput
    challenge: WellnessChallengeCreateNestedOneWithoutParticipantsInput
  }

  export type ChallengeParticipantUncheckedCreateInput = {
    id?: string
    userId: string
    challengeId: string
    progress: JsonNullValueInput | InputJsonValue
    completed?: boolean
    currentStreak?: number
    bestStreak?: number
    rank?: number | null
    joinedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type ChallengeParticipantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: JsonNullValueInput | InputJsonValue
    completed?: BoolFieldUpdateOperationsInput | boolean
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutChallengeParticipantsNestedInput
    challenge?: WellnessChallengeUpdateOneRequiredWithoutParticipantsNestedInput
  }

  export type ChallengeParticipantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    progress?: JsonNullValueInput | InputJsonValue
    completed?: BoolFieldUpdateOperationsInput | boolean
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChallengeParticipantCreateManyInput = {
    id?: string
    userId: string
    challengeId: string
    progress: JsonNullValueInput | InputJsonValue
    completed?: boolean
    currentStreak?: number
    bestStreak?: number
    rank?: number | null
    joinedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type ChallengeParticipantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: JsonNullValueInput | InputJsonValue
    completed?: BoolFieldUpdateOperationsInput | boolean
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChallengeParticipantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    progress?: JsonNullValueInput | InputJsonValue
    completed?: BoolFieldUpdateOperationsInput | boolean
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AIRecommendationCreateInput = {
    id?: string
    type: string
    title: string
    description: string
    priority: number
    reasoning: string
    actionUrl?: string | null
    duration?: number | null
    intensity?: string | null
    triggeredBy?: NullableJsonNullValueInput | InputJsonValue
    biometricState?: NullableJsonNullValueInput | InputJsonValue
    effectivenessScore?: number | null
    isRead?: boolean
    isCompleted?: boolean
    createdAt?: Date | string
    expiresAt?: Date | string | null
    completedAt?: Date | string | null
    user: UserCreateNestedOneWithoutAiRecommendationsInput
  }

  export type AIRecommendationUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    title: string
    description: string
    priority: number
    reasoning: string
    actionUrl?: string | null
    duration?: number | null
    intensity?: string | null
    triggeredBy?: NullableJsonNullValueInput | InputJsonValue
    biometricState?: NullableJsonNullValueInput | InputJsonValue
    effectivenessScore?: number | null
    isRead?: boolean
    isCompleted?: boolean
    createdAt?: Date | string
    expiresAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type AIRecommendationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    reasoning?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    intensity?: NullableStringFieldUpdateOperationsInput | string | null
    triggeredBy?: NullableJsonNullValueInput | InputJsonValue
    biometricState?: NullableJsonNullValueInput | InputJsonValue
    effectivenessScore?: NullableFloatFieldUpdateOperationsInput | number | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAiRecommendationsNestedInput
  }

  export type AIRecommendationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    reasoning?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    intensity?: NullableStringFieldUpdateOperationsInput | string | null
    triggeredBy?: NullableJsonNullValueInput | InputJsonValue
    biometricState?: NullableJsonNullValueInput | InputJsonValue
    effectivenessScore?: NullableFloatFieldUpdateOperationsInput | number | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AIRecommendationCreateManyInput = {
    id?: string
    userId: string
    type: string
    title: string
    description: string
    priority: number
    reasoning: string
    actionUrl?: string | null
    duration?: number | null
    intensity?: string | null
    triggeredBy?: NullableJsonNullValueInput | InputJsonValue
    biometricState?: NullableJsonNullValueInput | InputJsonValue
    effectivenessScore?: number | null
    isRead?: boolean
    isCompleted?: boolean
    createdAt?: Date | string
    expiresAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type AIRecommendationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    reasoning?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    intensity?: NullableStringFieldUpdateOperationsInput | string | null
    triggeredBy?: NullableJsonNullValueInput | InputJsonValue
    biometricState?: NullableJsonNullValueInput | InputJsonValue
    effectivenessScore?: NullableFloatFieldUpdateOperationsInput | number | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AIRecommendationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    reasoning?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    intensity?: NullableStringFieldUpdateOperationsInput | string | null
    triggeredBy?: NullableJsonNullValueInput | InputJsonValue
    biometricState?: NullableJsonNullValueInput | InputJsonValue
    effectivenessScore?: NullableFloatFieldUpdateOperationsInput | number | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeviceConnectionCreateInput = {
    id?: string
    deviceType: string
    deviceId: string
    deviceName?: string | null
    isConnected?: boolean
    lastSync?: Date | string | null
    syncInterval?: number | null
    reliability?: number | null
    batteryLevel?: number | null
    signalStrength?: number | null
    permissions: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDeviceConnectionsInput
  }

  export type DeviceConnectionUncheckedCreateInput = {
    id?: string
    userId: string
    deviceType: string
    deviceId: string
    deviceName?: string | null
    isConnected?: boolean
    lastSync?: Date | string | null
    syncInterval?: number | null
    reliability?: number | null
    batteryLevel?: number | null
    signalStrength?: number | null
    permissions: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeviceConnectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceType?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    isConnected?: BoolFieldUpdateOperationsInput | boolean
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncInterval?: NullableIntFieldUpdateOperationsInput | number | null
    reliability?: NullableFloatFieldUpdateOperationsInput | number | null
    batteryLevel?: NullableIntFieldUpdateOperationsInput | number | null
    signalStrength?: NullableFloatFieldUpdateOperationsInput | number | null
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDeviceConnectionsNestedInput
  }

  export type DeviceConnectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    deviceType?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    isConnected?: BoolFieldUpdateOperationsInput | boolean
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncInterval?: NullableIntFieldUpdateOperationsInput | number | null
    reliability?: NullableFloatFieldUpdateOperationsInput | number | null
    batteryLevel?: NullableIntFieldUpdateOperationsInput | number | null
    signalStrength?: NullableFloatFieldUpdateOperationsInput | number | null
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceConnectionCreateManyInput = {
    id?: string
    userId: string
    deviceType: string
    deviceId: string
    deviceName?: string | null
    isConnected?: boolean
    lastSync?: Date | string | null
    syncInterval?: number | null
    reliability?: number | null
    batteryLevel?: number | null
    signalStrength?: number | null
    permissions: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeviceConnectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceType?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    isConnected?: BoolFieldUpdateOperationsInput | boolean
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncInterval?: NullableIntFieldUpdateOperationsInput | number | null
    reliability?: NullableFloatFieldUpdateOperationsInput | number | null
    batteryLevel?: NullableIntFieldUpdateOperationsInput | number | null
    signalStrength?: NullableFloatFieldUpdateOperationsInput | number | null
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceConnectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    deviceType?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    isConnected?: BoolFieldUpdateOperationsInput | boolean
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncInterval?: NullableIntFieldUpdateOperationsInput | number | null
    reliability?: NullableFloatFieldUpdateOperationsInput | number | null
    batteryLevel?: NullableIntFieldUpdateOperationsInput | number | null
    signalStrength?: NullableFloatFieldUpdateOperationsInput | number | null
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WellnessSessionCreateInput = {
    id?: string
    sessionType: string
    title: string
    duration: number
    startingStress?: number | null
    endingStress?: number | null
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    avgHeartRate?: number | null
    stressReduction?: number | null
    userRating?: number | null
    completionRate?: number | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    user: UserCreateNestedOneWithoutWellnessSessionsInput
  }

  export type WellnessSessionUncheckedCreateInput = {
    id?: string
    userId: string
    sessionType: string
    title: string
    duration: number
    startingStress?: number | null
    endingStress?: number | null
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    avgHeartRate?: number | null
    stressReduction?: number | null
    userRating?: number | null
    completionRate?: number | null
    startedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type WellnessSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    startingStress?: NullableIntFieldUpdateOperationsInput | number | null
    endingStress?: NullableIntFieldUpdateOperationsInput | number | null
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    avgHeartRate?: NullableIntFieldUpdateOperationsInput | number | null
    stressReduction?: NullableFloatFieldUpdateOperationsInput | number | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    completionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutWellnessSessionsNestedInput
  }

  export type WellnessSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    startingStress?: NullableIntFieldUpdateOperationsInput | number | null
    endingStress?: NullableIntFieldUpdateOperationsInput | number | null
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    avgHeartRate?: NullableIntFieldUpdateOperationsInput | number | null
    stressReduction?: NullableFloatFieldUpdateOperationsInput | number | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    completionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WellnessSessionCreateManyInput = {
    id?: string
    userId: string
    sessionType: string
    title: string
    duration: number
    startingStress?: number | null
    endingStress?: number | null
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    avgHeartRate?: number | null
    stressReduction?: number | null
    userRating?: number | null
    completionRate?: number | null
    startedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type WellnessSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    startingStress?: NullableIntFieldUpdateOperationsInput | number | null
    endingStress?: NullableIntFieldUpdateOperationsInput | number | null
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    avgHeartRate?: NullableIntFieldUpdateOperationsInput | number | null
    stressReduction?: NullableFloatFieldUpdateOperationsInput | number | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    completionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WellnessSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    startingStress?: NullableIntFieldUpdateOperationsInput | number | null
    endingStress?: NullableIntFieldUpdateOperationsInput | number | null
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    avgHeartRate?: NullableIntFieldUpdateOperationsInput | number | null
    stressReduction?: NullableFloatFieldUpdateOperationsInput | number | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    completionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EnvironmentalDataCreateInput = {
    id?: string
    location?: string | null
    timezone?: string | null
    temperature?: number | null
    humidity?: number | null
    pressure?: number | null
    weather?: string | null
    airQuality?: number | null
    pollutants?: NullableJsonNullValueInput | InputJsonValue
    lightLevel?: number | null
    uvIndex?: number | null
    noiseLevel?: number | null
    timestamp?: Date | string
    user: UserCreateNestedOneWithoutEnvironmentalDataInput
  }

  export type EnvironmentalDataUncheckedCreateInput = {
    id?: string
    userId: string
    location?: string | null
    timezone?: string | null
    temperature?: number | null
    humidity?: number | null
    pressure?: number | null
    weather?: string | null
    airQuality?: number | null
    pollutants?: NullableJsonNullValueInput | InputJsonValue
    lightLevel?: number | null
    uvIndex?: number | null
    noiseLevel?: number | null
    timestamp?: Date | string
  }

  export type EnvironmentalDataUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    humidity?: NullableFloatFieldUpdateOperationsInput | number | null
    pressure?: NullableFloatFieldUpdateOperationsInput | number | null
    weather?: NullableStringFieldUpdateOperationsInput | string | null
    airQuality?: NullableIntFieldUpdateOperationsInput | number | null
    pollutants?: NullableJsonNullValueInput | InputJsonValue
    lightLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    uvIndex?: NullableFloatFieldUpdateOperationsInput | number | null
    noiseLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEnvironmentalDataNestedInput
  }

  export type EnvironmentalDataUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    humidity?: NullableFloatFieldUpdateOperationsInput | number | null
    pressure?: NullableFloatFieldUpdateOperationsInput | number | null
    weather?: NullableStringFieldUpdateOperationsInput | string | null
    airQuality?: NullableIntFieldUpdateOperationsInput | number | null
    pollutants?: NullableJsonNullValueInput | InputJsonValue
    lightLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    uvIndex?: NullableFloatFieldUpdateOperationsInput | number | null
    noiseLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnvironmentalDataCreateManyInput = {
    id?: string
    userId: string
    location?: string | null
    timezone?: string | null
    temperature?: number | null
    humidity?: number | null
    pressure?: number | null
    weather?: string | null
    airQuality?: number | null
    pollutants?: NullableJsonNullValueInput | InputJsonValue
    lightLevel?: number | null
    uvIndex?: number | null
    noiseLevel?: number | null
    timestamp?: Date | string
  }

  export type EnvironmentalDataUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    humidity?: NullableFloatFieldUpdateOperationsInput | number | null
    pressure?: NullableFloatFieldUpdateOperationsInput | number | null
    weather?: NullableStringFieldUpdateOperationsInput | string | null
    airQuality?: NullableIntFieldUpdateOperationsInput | number | null
    pollutants?: NullableJsonNullValueInput | InputJsonValue
    lightLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    uvIndex?: NullableFloatFieldUpdateOperationsInput | number | null
    noiseLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnvironmentalDataUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    humidity?: NullableFloatFieldUpdateOperationsInput | number | null
    pressure?: NullableFloatFieldUpdateOperationsInput | number | null
    weather?: NullableStringFieldUpdateOperationsInput | string | null
    airQuality?: NullableIntFieldUpdateOperationsInput | number | null
    pollutants?: NullableJsonNullValueInput | InputJsonValue
    lightLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    uvIndex?: NullableFloatFieldUpdateOperationsInput | number | null
    noiseLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WellnessGroupCreateInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    isPublic?: boolean
    maxMembers?: number | null
    groupGoals?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: GroupMembershipCreateNestedManyWithoutGroupInput
  }

  export type WellnessGroupUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    isPublic?: boolean
    maxMembers?: number | null
    groupGoals?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: GroupMembershipUncheckedCreateNestedManyWithoutGroupInput
  }

  export type WellnessGroupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    maxMembers?: NullableIntFieldUpdateOperationsInput | number | null
    groupGoals?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: GroupMembershipUpdateManyWithoutGroupNestedInput
  }

  export type WellnessGroupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    maxMembers?: NullableIntFieldUpdateOperationsInput | number | null
    groupGoals?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: GroupMembershipUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type WellnessGroupCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    isPublic?: boolean
    maxMembers?: number | null
    groupGoals?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WellnessGroupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    maxMembers?: NullableIntFieldUpdateOperationsInput | number | null
    groupGoals?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WellnessGroupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    maxMembers?: NullableIntFieldUpdateOperationsInput | number | null
    groupGoals?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMembershipCreateInput = {
    id?: string
    role?: string
    shareProgress?: boolean
    shareGoals?: boolean
    joinedAt?: Date | string
    user: UserCreateNestedOneWithoutCollaborativeGroupsInput
    group: WellnessGroupCreateNestedOneWithoutMembersInput
  }

  export type GroupMembershipUncheckedCreateInput = {
    id?: string
    userId: string
    groupId: string
    role?: string
    shareProgress?: boolean
    shareGoals?: boolean
    joinedAt?: Date | string
  }

  export type GroupMembershipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    shareProgress?: BoolFieldUpdateOperationsInput | boolean
    shareGoals?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCollaborativeGroupsNestedInput
    group?: WellnessGroupUpdateOneRequiredWithoutMembersNestedInput
  }

  export type GroupMembershipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    shareProgress?: BoolFieldUpdateOperationsInput | boolean
    shareGoals?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMembershipCreateManyInput = {
    id?: string
    userId: string
    groupId: string
    role?: string
    shareProgress?: boolean
    shareGoals?: boolean
    joinedAt?: Date | string
  }

  export type GroupMembershipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    shareProgress?: BoolFieldUpdateOperationsInput | boolean
    shareGoals?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMembershipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    shareProgress?: BoolFieldUpdateOperationsInput | boolean
    shareGoals?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkplaceIntegrationCreateInput = {
    id?: string
    platform: string
    enabled?: boolean
    frequency?: string
    canSuggestBreaks?: boolean
    canAccessCalendar?: boolean
    canSendReminders?: boolean
    workHours?: NullableJsonNullValueInput | InputJsonValue
    breakPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutWorkplaceIntegrationsInput
  }

  export type WorkplaceIntegrationUncheckedCreateInput = {
    id?: string
    userId: string
    platform: string
    enabled?: boolean
    frequency?: string
    canSuggestBreaks?: boolean
    canAccessCalendar?: boolean
    canSendReminders?: boolean
    workHours?: NullableJsonNullValueInput | InputJsonValue
    breakPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkplaceIntegrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    frequency?: StringFieldUpdateOperationsInput | string
    canSuggestBreaks?: BoolFieldUpdateOperationsInput | boolean
    canAccessCalendar?: BoolFieldUpdateOperationsInput | boolean
    canSendReminders?: BoolFieldUpdateOperationsInput | boolean
    workHours?: NullableJsonNullValueInput | InputJsonValue
    breakPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWorkplaceIntegrationsNestedInput
  }

  export type WorkplaceIntegrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    frequency?: StringFieldUpdateOperationsInput | string
    canSuggestBreaks?: BoolFieldUpdateOperationsInput | boolean
    canAccessCalendar?: BoolFieldUpdateOperationsInput | boolean
    canSendReminders?: BoolFieldUpdateOperationsInput | boolean
    workHours?: NullableJsonNullValueInput | InputJsonValue
    breakPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkplaceIntegrationCreateManyInput = {
    id?: string
    userId: string
    platform: string
    enabled?: boolean
    frequency?: string
    canSuggestBreaks?: boolean
    canAccessCalendar?: boolean
    canSendReminders?: boolean
    workHours?: NullableJsonNullValueInput | InputJsonValue
    breakPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkplaceIntegrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    frequency?: StringFieldUpdateOperationsInput | string
    canSuggestBreaks?: BoolFieldUpdateOperationsInput | boolean
    canAccessCalendar?: BoolFieldUpdateOperationsInput | boolean
    canSendReminders?: BoolFieldUpdateOperationsInput | boolean
    workHours?: NullableJsonNullValueInput | InputJsonValue
    breakPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkplaceIntegrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    frequency?: StringFieldUpdateOperationsInput | string
    canSuggestBreaks?: BoolFieldUpdateOperationsInput | boolean
    canAccessCalendar?: BoolFieldUpdateOperationsInput | boolean
    canSendReminders?: BoolFieldUpdateOperationsInput | boolean
    workHours?: NullableJsonNullValueInput | InputJsonValue
    breakPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type AccountNullableScalarRelationFilter = {
    is?: AccountWhereInput | null
    isNot?: AccountWhereInput | null
  }

  export type JournalEntryListRelationFilter = {
    every?: JournalEntryWhereInput
    some?: JournalEntryWhereInput
    none?: JournalEntryWhereInput
  }

  export type HabitListRelationFilter = {
    every?: HabitWhereInput
    some?: HabitWhereInput
    none?: HabitWhereInput
  }

  export type BookingListRelationFilter = {
    every?: BookingWhereInput
    some?: BookingWhereInput
    none?: BookingWhereInput
  }

  export type BiometricDataListRelationFilter = {
    every?: BiometricDataWhereInput
    some?: BiometricDataWhereInput
    none?: BiometricDataWhereInput
  }

  export type MoodEntryListRelationFilter = {
    every?: MoodEntryWhereInput
    some?: MoodEntryWhereInput
    none?: MoodEntryWhereInput
  }

  export type StressPredictionListRelationFilter = {
    every?: StressPredictionWhereInput
    some?: StressPredictionWhereInput
    none?: StressPredictionWhereInput
  }

  export type ChallengeParticipantListRelationFilter = {
    every?: ChallengeParticipantWhereInput
    some?: ChallengeParticipantWhereInput
    none?: ChallengeParticipantWhereInput
  }

  export type AIRecommendationListRelationFilter = {
    every?: AIRecommendationWhereInput
    some?: AIRecommendationWhereInput
    none?: AIRecommendationWhereInput
  }

  export type DeviceConnectionListRelationFilter = {
    every?: DeviceConnectionWhereInput
    some?: DeviceConnectionWhereInput
    none?: DeviceConnectionWhereInput
  }

  export type WellnessSessionListRelationFilter = {
    every?: WellnessSessionWhereInput
    some?: WellnessSessionWhereInput
    none?: WellnessSessionWhereInput
  }

  export type EnvironmentalDataListRelationFilter = {
    every?: EnvironmentalDataWhereInput
    some?: EnvironmentalDataWhereInput
    none?: EnvironmentalDataWhereInput
  }

  export type GroupMembershipListRelationFilter = {
    every?: GroupMembershipWhereInput
    some?: GroupMembershipWhereInput
    none?: GroupMembershipWhereInput
  }

  export type WorkplaceIntegrationListRelationFilter = {
    every?: WorkplaceIntegrationWhereInput
    some?: WorkplaceIntegrationWhereInput
    none?: WorkplaceIntegrationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JournalEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HabitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BiometricDataOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MoodEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StressPredictionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChallengeParticipantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AIRecommendationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeviceConnectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WellnessSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EnvironmentalDataOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupMembershipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkplaceIntegrationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    timezone?: SortOrder
    preferences?: SortOrder
    aiCoachEnabled?: SortOrder
    biometricSyncEnabled?: SortOrder
    baseStressLevel?: SortOrder
    sleepGoal?: SortOrder
    stepsGoal?: SortOrder
    workSchedule?: SortOrder
    personalityProfile?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    baseStressLevel?: SortOrder
    sleepGoal?: SortOrder
    stepsGoal?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    timezone?: SortOrder
    aiCoachEnabled?: SortOrder
    biometricSyncEnabled?: SortOrder
    baseStressLevel?: SortOrder
    sleepGoal?: SortOrder
    stepsGoal?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    timezone?: SortOrder
    aiCoachEnabled?: SortOrder
    biometricSyncEnabled?: SortOrder
    baseStressLevel?: SortOrder
    sleepGoal?: SortOrder
    stepsGoal?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    baseStressLevel?: SortOrder
    sleepGoal?: SortOrder
    stepsGoal?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    idToken?: SortOrder
    password?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    idToken?: SortOrder
    password?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    idToken?: SortOrder
    password?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type VerificationCountOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMinOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JournalEntryUserIdDateCompoundUniqueInput = {
    userId: string
    date: Date | string
  }

  export type JournalEntryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    date?: SortOrder
    mood?: SortOrder
    stressLevel?: SortOrder
    emotionScores?: SortOrder
    topics?: SortOrder
    sentiment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JournalEntryAvgOrderByAggregateInput = {
    stressLevel?: SortOrder
    sentiment?: SortOrder
  }

  export type JournalEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    date?: SortOrder
    mood?: SortOrder
    stressLevel?: SortOrder
    sentiment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JournalEntryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    date?: SortOrder
    mood?: SortOrder
    stressLevel?: SortOrder
    sentiment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JournalEntrySumOrderByAggregateInput = {
    stressLevel?: SortOrder
    sentiment?: SortOrder
  }

  export type HabitUserIdIdCompoundUniqueInput = {
    userId: string
    id: string
  }

  export type HabitCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    isCompleted?: SortOrder
    date?: SortOrder
    aiSuggested?: SortOrder
    adaptiveReminder?: SortOrder
    difficultyLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HabitAvgOrderByAggregateInput = {
    difficultyLevel?: SortOrder
  }

  export type HabitMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    isCompleted?: SortOrder
    date?: SortOrder
    aiSuggested?: SortOrder
    difficultyLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HabitMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    isCompleted?: SortOrder
    date?: SortOrder
    aiSuggested?: SortOrder
    difficultyLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HabitSumOrderByAggregateInput = {
    difficultyLevel?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ClassCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    durationMins?: SortOrder
    instructor?: SortOrder
    imageUrl?: SortOrder
    capacity?: SortOrder
    intensity?: SortOrder
    stressLevel?: SortOrder
    aiOptimized?: SortOrder
    adaptiveContent?: SortOrder
    prerequisites?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassAvgOrderByAggregateInput = {
    durationMins?: SortOrder
    capacity?: SortOrder
    stressLevel?: SortOrder
  }

  export type ClassMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    durationMins?: SortOrder
    instructor?: SortOrder
    imageUrl?: SortOrder
    capacity?: SortOrder
    intensity?: SortOrder
    stressLevel?: SortOrder
    aiOptimized?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    durationMins?: SortOrder
    instructor?: SortOrder
    imageUrl?: SortOrder
    capacity?: SortOrder
    intensity?: SortOrder
    stressLevel?: SortOrder
    aiOptimized?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassSumOrderByAggregateInput = {
    durationMins?: SortOrder
    capacity?: SortOrder
    stressLevel?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type ClassScalarRelationFilter = {
    is?: ClassWhereInput
    isNot?: ClassWhereInput
  }

  export type BookingUserIdClassIdCompoundUniqueInput = {
    userId: string
    classId: string
  }

  export type BookingCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    classId?: SortOrder
    aiSuggested?: SortOrder
    predictedEffectiveness?: SortOrder
    createdAt?: SortOrder
  }

  export type BookingAvgOrderByAggregateInput = {
    predictedEffectiveness?: SortOrder
  }

  export type BookingMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    classId?: SortOrder
    aiSuggested?: SortOrder
    predictedEffectiveness?: SortOrder
    createdAt?: SortOrder
  }

  export type BookingMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    classId?: SortOrder
    aiSuggested?: SortOrder
    predictedEffectiveness?: SortOrder
    createdAt?: SortOrder
  }

  export type BookingSumOrderByAggregateInput = {
    predictedEffectiveness?: SortOrder
  }

  export type BiometricDataCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    heartRate?: SortOrder
    heartRateVariability?: SortOrder
    stressLevel?: SortOrder
    sleepQuality?: SortOrder
    sleepDuration?: SortOrder
    steps?: SortOrder
    calories?: SortOrder
    respiratoryRate?: SortOrder
    skinTemperature?: SortOrder
    bloodPressureSystolic?: SortOrder
    bloodPressureDiastolic?: SortOrder
    oxygenSaturation?: SortOrder
    wellnessScore?: SortOrder
    energyLevel?: SortOrder
    recoveryScore?: SortOrder
    deviceType?: SortOrder
    deviceId?: SortOrder
    accuracy?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BiometricDataAvgOrderByAggregateInput = {
    heartRate?: SortOrder
    heartRateVariability?: SortOrder
    stressLevel?: SortOrder
    sleepQuality?: SortOrder
    sleepDuration?: SortOrder
    steps?: SortOrder
    calories?: SortOrder
    respiratoryRate?: SortOrder
    skinTemperature?: SortOrder
    bloodPressureSystolic?: SortOrder
    bloodPressureDiastolic?: SortOrder
    oxygenSaturation?: SortOrder
    wellnessScore?: SortOrder
    energyLevel?: SortOrder
    recoveryScore?: SortOrder
    accuracy?: SortOrder
  }

  export type BiometricDataMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    heartRate?: SortOrder
    heartRateVariability?: SortOrder
    stressLevel?: SortOrder
    sleepQuality?: SortOrder
    sleepDuration?: SortOrder
    steps?: SortOrder
    calories?: SortOrder
    respiratoryRate?: SortOrder
    skinTemperature?: SortOrder
    bloodPressureSystolic?: SortOrder
    bloodPressureDiastolic?: SortOrder
    oxygenSaturation?: SortOrder
    wellnessScore?: SortOrder
    energyLevel?: SortOrder
    recoveryScore?: SortOrder
    deviceType?: SortOrder
    deviceId?: SortOrder
    accuracy?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BiometricDataMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    heartRate?: SortOrder
    heartRateVariability?: SortOrder
    stressLevel?: SortOrder
    sleepQuality?: SortOrder
    sleepDuration?: SortOrder
    steps?: SortOrder
    calories?: SortOrder
    respiratoryRate?: SortOrder
    skinTemperature?: SortOrder
    bloodPressureSystolic?: SortOrder
    bloodPressureDiastolic?: SortOrder
    oxygenSaturation?: SortOrder
    wellnessScore?: SortOrder
    energyLevel?: SortOrder
    recoveryScore?: SortOrder
    deviceType?: SortOrder
    deviceId?: SortOrder
    accuracy?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BiometricDataSumOrderByAggregateInput = {
    heartRate?: SortOrder
    heartRateVariability?: SortOrder
    stressLevel?: SortOrder
    sleepQuality?: SortOrder
    sleepDuration?: SortOrder
    steps?: SortOrder
    calories?: SortOrder
    respiratoryRate?: SortOrder
    skinTemperature?: SortOrder
    bloodPressureSystolic?: SortOrder
    bloodPressureDiastolic?: SortOrder
    oxygenSaturation?: SortOrder
    wellnessScore?: SortOrder
    energyLevel?: SortOrder
    recoveryScore?: SortOrder
    accuracy?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type MoodEntryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mood?: SortOrder
    confidence?: SortOrder
    source?: SortOrder
    emotions?: SortOrder
    valence?: SortOrder
    arousal?: SortOrder
    location?: SortOrder
    weather?: SortOrder
    timeOfDay?: SortOrder
    activity?: SortOrder
    voiceFeatures?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MoodEntryAvgOrderByAggregateInput = {
    confidence?: SortOrder
    valence?: SortOrder
    arousal?: SortOrder
  }

  export type MoodEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mood?: SortOrder
    confidence?: SortOrder
    source?: SortOrder
    valence?: SortOrder
    arousal?: SortOrder
    location?: SortOrder
    weather?: SortOrder
    timeOfDay?: SortOrder
    activity?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MoodEntryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mood?: SortOrder
    confidence?: SortOrder
    source?: SortOrder
    valence?: SortOrder
    arousal?: SortOrder
    location?: SortOrder
    weather?: SortOrder
    timeOfDay?: SortOrder
    activity?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MoodEntrySumOrderByAggregateInput = {
    confidence?: SortOrder
    valence?: SortOrder
    arousal?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type StressPredictionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    predictedStressLevel?: SortOrder
    confidence?: SortOrder
    predictedAt?: SortOrder
    modelVersion?: SortOrder
    triggers?: SortOrder
    riskFactors?: SortOrder
    recommendedInterventions?: SortOrder
    preventionStrategies?: SortOrder
    actualStressLevel?: SortOrder
    wasAccurate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StressPredictionAvgOrderByAggregateInput = {
    predictedStressLevel?: SortOrder
    confidence?: SortOrder
    actualStressLevel?: SortOrder
  }

  export type StressPredictionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    predictedStressLevel?: SortOrder
    confidence?: SortOrder
    predictedAt?: SortOrder
    modelVersion?: SortOrder
    actualStressLevel?: SortOrder
    wasAccurate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StressPredictionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    predictedStressLevel?: SortOrder
    confidence?: SortOrder
    predictedAt?: SortOrder
    modelVersion?: SortOrder
    actualStressLevel?: SortOrder
    wasAccurate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StressPredictionSumOrderByAggregateInput = {
    predictedStressLevel?: SortOrder
    confidence?: SortOrder
    actualStressLevel?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type WellnessChallengeCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    duration?: SortOrder
    target?: SortOrder
    reward?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    maxParticipants?: SortOrder
    isPublic?: SortOrder
    teamBased?: SortOrder
    aiGenerated?: SortOrder
    adaptiveDifficulty?: SortOrder
    personalizedGoals?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WellnessChallengeAvgOrderByAggregateInput = {
    duration?: SortOrder
    maxParticipants?: SortOrder
  }

  export type WellnessChallengeMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    duration?: SortOrder
    reward?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    maxParticipants?: SortOrder
    isPublic?: SortOrder
    teamBased?: SortOrder
    aiGenerated?: SortOrder
    adaptiveDifficulty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WellnessChallengeMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    duration?: SortOrder
    reward?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    maxParticipants?: SortOrder
    isPublic?: SortOrder
    teamBased?: SortOrder
    aiGenerated?: SortOrder
    adaptiveDifficulty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WellnessChallengeSumOrderByAggregateInput = {
    duration?: SortOrder
    maxParticipants?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type WellnessChallengeScalarRelationFilter = {
    is?: WellnessChallengeWhereInput
    isNot?: WellnessChallengeWhereInput
  }

  export type ChallengeParticipantUserIdChallengeIdCompoundUniqueInput = {
    userId: string
    challengeId: string
  }

  export type ChallengeParticipantCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    challengeId?: SortOrder
    progress?: SortOrder
    completed?: SortOrder
    currentStreak?: SortOrder
    bestStreak?: SortOrder
    rank?: SortOrder
    joinedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type ChallengeParticipantAvgOrderByAggregateInput = {
    currentStreak?: SortOrder
    bestStreak?: SortOrder
    rank?: SortOrder
  }

  export type ChallengeParticipantMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    challengeId?: SortOrder
    completed?: SortOrder
    currentStreak?: SortOrder
    bestStreak?: SortOrder
    rank?: SortOrder
    joinedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type ChallengeParticipantMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    challengeId?: SortOrder
    completed?: SortOrder
    currentStreak?: SortOrder
    bestStreak?: SortOrder
    rank?: SortOrder
    joinedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type ChallengeParticipantSumOrderByAggregateInput = {
    currentStreak?: SortOrder
    bestStreak?: SortOrder
    rank?: SortOrder
  }

  export type AIRecommendationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    reasoning?: SortOrder
    actionUrl?: SortOrder
    duration?: SortOrder
    intensity?: SortOrder
    triggeredBy?: SortOrder
    biometricState?: SortOrder
    effectivenessScore?: SortOrder
    isRead?: SortOrder
    isCompleted?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    completedAt?: SortOrder
  }

  export type AIRecommendationAvgOrderByAggregateInput = {
    priority?: SortOrder
    duration?: SortOrder
    effectivenessScore?: SortOrder
  }

  export type AIRecommendationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    reasoning?: SortOrder
    actionUrl?: SortOrder
    duration?: SortOrder
    intensity?: SortOrder
    effectivenessScore?: SortOrder
    isRead?: SortOrder
    isCompleted?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    completedAt?: SortOrder
  }

  export type AIRecommendationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    reasoning?: SortOrder
    actionUrl?: SortOrder
    duration?: SortOrder
    intensity?: SortOrder
    effectivenessScore?: SortOrder
    isRead?: SortOrder
    isCompleted?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    completedAt?: SortOrder
  }

  export type AIRecommendationSumOrderByAggregateInput = {
    priority?: SortOrder
    duration?: SortOrder
    effectivenessScore?: SortOrder
  }

  export type DeviceConnectionUserIdDeviceTypeDeviceIdCompoundUniqueInput = {
    userId: string
    deviceType: string
    deviceId: string
  }

  export type DeviceConnectionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceType?: SortOrder
    deviceId?: SortOrder
    deviceName?: SortOrder
    isConnected?: SortOrder
    lastSync?: SortOrder
    syncInterval?: SortOrder
    reliability?: SortOrder
    batteryLevel?: SortOrder
    signalStrength?: SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeviceConnectionAvgOrderByAggregateInput = {
    syncInterval?: SortOrder
    reliability?: SortOrder
    batteryLevel?: SortOrder
    signalStrength?: SortOrder
  }

  export type DeviceConnectionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceType?: SortOrder
    deviceId?: SortOrder
    deviceName?: SortOrder
    isConnected?: SortOrder
    lastSync?: SortOrder
    syncInterval?: SortOrder
    reliability?: SortOrder
    batteryLevel?: SortOrder
    signalStrength?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeviceConnectionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceType?: SortOrder
    deviceId?: SortOrder
    deviceName?: SortOrder
    isConnected?: SortOrder
    lastSync?: SortOrder
    syncInterval?: SortOrder
    reliability?: SortOrder
    batteryLevel?: SortOrder
    signalStrength?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeviceConnectionSumOrderByAggregateInput = {
    syncInterval?: SortOrder
    reliability?: SortOrder
    batteryLevel?: SortOrder
    signalStrength?: SortOrder
  }

  export type WellnessSessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionType?: SortOrder
    title?: SortOrder
    duration?: SortOrder
    startingStress?: SortOrder
    endingStress?: SortOrder
    adaptations?: SortOrder
    avgHeartRate?: SortOrder
    stressReduction?: SortOrder
    userRating?: SortOrder
    completionRate?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type WellnessSessionAvgOrderByAggregateInput = {
    duration?: SortOrder
    startingStress?: SortOrder
    endingStress?: SortOrder
    avgHeartRate?: SortOrder
    stressReduction?: SortOrder
    userRating?: SortOrder
    completionRate?: SortOrder
  }

  export type WellnessSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionType?: SortOrder
    title?: SortOrder
    duration?: SortOrder
    startingStress?: SortOrder
    endingStress?: SortOrder
    avgHeartRate?: SortOrder
    stressReduction?: SortOrder
    userRating?: SortOrder
    completionRate?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type WellnessSessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionType?: SortOrder
    title?: SortOrder
    duration?: SortOrder
    startingStress?: SortOrder
    endingStress?: SortOrder
    avgHeartRate?: SortOrder
    stressReduction?: SortOrder
    userRating?: SortOrder
    completionRate?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type WellnessSessionSumOrderByAggregateInput = {
    duration?: SortOrder
    startingStress?: SortOrder
    endingStress?: SortOrder
    avgHeartRate?: SortOrder
    stressReduction?: SortOrder
    userRating?: SortOrder
    completionRate?: SortOrder
  }

  export type EnvironmentalDataCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    location?: SortOrder
    timezone?: SortOrder
    temperature?: SortOrder
    humidity?: SortOrder
    pressure?: SortOrder
    weather?: SortOrder
    airQuality?: SortOrder
    pollutants?: SortOrder
    lightLevel?: SortOrder
    uvIndex?: SortOrder
    noiseLevel?: SortOrder
    timestamp?: SortOrder
  }

  export type EnvironmentalDataAvgOrderByAggregateInput = {
    temperature?: SortOrder
    humidity?: SortOrder
    pressure?: SortOrder
    airQuality?: SortOrder
    lightLevel?: SortOrder
    uvIndex?: SortOrder
    noiseLevel?: SortOrder
  }

  export type EnvironmentalDataMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    location?: SortOrder
    timezone?: SortOrder
    temperature?: SortOrder
    humidity?: SortOrder
    pressure?: SortOrder
    weather?: SortOrder
    airQuality?: SortOrder
    lightLevel?: SortOrder
    uvIndex?: SortOrder
    noiseLevel?: SortOrder
    timestamp?: SortOrder
  }

  export type EnvironmentalDataMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    location?: SortOrder
    timezone?: SortOrder
    temperature?: SortOrder
    humidity?: SortOrder
    pressure?: SortOrder
    weather?: SortOrder
    airQuality?: SortOrder
    lightLevel?: SortOrder
    uvIndex?: SortOrder
    noiseLevel?: SortOrder
    timestamp?: SortOrder
  }

  export type EnvironmentalDataSumOrderByAggregateInput = {
    temperature?: SortOrder
    humidity?: SortOrder
    pressure?: SortOrder
    airQuality?: SortOrder
    lightLevel?: SortOrder
    uvIndex?: SortOrder
    noiseLevel?: SortOrder
  }

  export type WellnessGroupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    isPublic?: SortOrder
    maxMembers?: SortOrder
    groupGoals?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WellnessGroupAvgOrderByAggregateInput = {
    maxMembers?: SortOrder
  }

  export type WellnessGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    isPublic?: SortOrder
    maxMembers?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WellnessGroupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    isPublic?: SortOrder
    maxMembers?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WellnessGroupSumOrderByAggregateInput = {
    maxMembers?: SortOrder
  }

  export type WellnessGroupScalarRelationFilter = {
    is?: WellnessGroupWhereInput
    isNot?: WellnessGroupWhereInput
  }

  export type GroupMembershipUserIdGroupIdCompoundUniqueInput = {
    userId: string
    groupId: string
  }

  export type GroupMembershipCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
    role?: SortOrder
    shareProgress?: SortOrder
    shareGoals?: SortOrder
    joinedAt?: SortOrder
  }

  export type GroupMembershipMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
    role?: SortOrder
    shareProgress?: SortOrder
    shareGoals?: SortOrder
    joinedAt?: SortOrder
  }

  export type GroupMembershipMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
    role?: SortOrder
    shareProgress?: SortOrder
    shareGoals?: SortOrder
    joinedAt?: SortOrder
  }

  export type WorkplaceIntegrationUserIdPlatformCompoundUniqueInput = {
    userId: string
    platform: string
  }

  export type WorkplaceIntegrationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    platform?: SortOrder
    enabled?: SortOrder
    frequency?: SortOrder
    canSuggestBreaks?: SortOrder
    canAccessCalendar?: SortOrder
    canSendReminders?: SortOrder
    workHours?: SortOrder
    breakPreferences?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkplaceIntegrationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    platform?: SortOrder
    enabled?: SortOrder
    frequency?: SortOrder
    canSuggestBreaks?: SortOrder
    canAccessCalendar?: SortOrder
    canSendReminders?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkplaceIntegrationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    platform?: SortOrder
    enabled?: SortOrder
    frequency?: SortOrder
    canSuggestBreaks?: SortOrder
    canAccessCalendar?: SortOrder
    canSendReminders?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountCreateNestedOneWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput
    connect?: AccountWhereUniqueInput
  }

  export type JournalEntryCreateNestedManyWithoutUserInput = {
    create?: XOR<JournalEntryCreateWithoutUserInput, JournalEntryUncheckedCreateWithoutUserInput> | JournalEntryCreateWithoutUserInput[] | JournalEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JournalEntryCreateOrConnectWithoutUserInput | JournalEntryCreateOrConnectWithoutUserInput[]
    createMany?: JournalEntryCreateManyUserInputEnvelope
    connect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
  }

  export type HabitCreateNestedManyWithoutUserInput = {
    create?: XOR<HabitCreateWithoutUserInput, HabitUncheckedCreateWithoutUserInput> | HabitCreateWithoutUserInput[] | HabitUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HabitCreateOrConnectWithoutUserInput | HabitCreateOrConnectWithoutUserInput[]
    createMany?: HabitCreateManyUserInputEnvelope
    connect?: HabitWhereUniqueInput | HabitWhereUniqueInput[]
  }

  export type BookingCreateNestedManyWithoutUserInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type BiometricDataCreateNestedManyWithoutUserInput = {
    create?: XOR<BiometricDataCreateWithoutUserInput, BiometricDataUncheckedCreateWithoutUserInput> | BiometricDataCreateWithoutUserInput[] | BiometricDataUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BiometricDataCreateOrConnectWithoutUserInput | BiometricDataCreateOrConnectWithoutUserInput[]
    createMany?: BiometricDataCreateManyUserInputEnvelope
    connect?: BiometricDataWhereUniqueInput | BiometricDataWhereUniqueInput[]
  }

  export type MoodEntryCreateNestedManyWithoutUserInput = {
    create?: XOR<MoodEntryCreateWithoutUserInput, MoodEntryUncheckedCreateWithoutUserInput> | MoodEntryCreateWithoutUserInput[] | MoodEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MoodEntryCreateOrConnectWithoutUserInput | MoodEntryCreateOrConnectWithoutUserInput[]
    createMany?: MoodEntryCreateManyUserInputEnvelope
    connect?: MoodEntryWhereUniqueInput | MoodEntryWhereUniqueInput[]
  }

  export type StressPredictionCreateNestedManyWithoutUserInput = {
    create?: XOR<StressPredictionCreateWithoutUserInput, StressPredictionUncheckedCreateWithoutUserInput> | StressPredictionCreateWithoutUserInput[] | StressPredictionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StressPredictionCreateOrConnectWithoutUserInput | StressPredictionCreateOrConnectWithoutUserInput[]
    createMany?: StressPredictionCreateManyUserInputEnvelope
    connect?: StressPredictionWhereUniqueInput | StressPredictionWhereUniqueInput[]
  }

  export type ChallengeParticipantCreateNestedManyWithoutUserInput = {
    create?: XOR<ChallengeParticipantCreateWithoutUserInput, ChallengeParticipantUncheckedCreateWithoutUserInput> | ChallengeParticipantCreateWithoutUserInput[] | ChallengeParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChallengeParticipantCreateOrConnectWithoutUserInput | ChallengeParticipantCreateOrConnectWithoutUserInput[]
    createMany?: ChallengeParticipantCreateManyUserInputEnvelope
    connect?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
  }

  export type AIRecommendationCreateNestedManyWithoutUserInput = {
    create?: XOR<AIRecommendationCreateWithoutUserInput, AIRecommendationUncheckedCreateWithoutUserInput> | AIRecommendationCreateWithoutUserInput[] | AIRecommendationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIRecommendationCreateOrConnectWithoutUserInput | AIRecommendationCreateOrConnectWithoutUserInput[]
    createMany?: AIRecommendationCreateManyUserInputEnvelope
    connect?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
  }

  export type DeviceConnectionCreateNestedManyWithoutUserInput = {
    create?: XOR<DeviceConnectionCreateWithoutUserInput, DeviceConnectionUncheckedCreateWithoutUserInput> | DeviceConnectionCreateWithoutUserInput[] | DeviceConnectionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeviceConnectionCreateOrConnectWithoutUserInput | DeviceConnectionCreateOrConnectWithoutUserInput[]
    createMany?: DeviceConnectionCreateManyUserInputEnvelope
    connect?: DeviceConnectionWhereUniqueInput | DeviceConnectionWhereUniqueInput[]
  }

  export type WellnessSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<WellnessSessionCreateWithoutUserInput, WellnessSessionUncheckedCreateWithoutUserInput> | WellnessSessionCreateWithoutUserInput[] | WellnessSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WellnessSessionCreateOrConnectWithoutUserInput | WellnessSessionCreateOrConnectWithoutUserInput[]
    createMany?: WellnessSessionCreateManyUserInputEnvelope
    connect?: WellnessSessionWhereUniqueInput | WellnessSessionWhereUniqueInput[]
  }

  export type EnvironmentalDataCreateNestedManyWithoutUserInput = {
    create?: XOR<EnvironmentalDataCreateWithoutUserInput, EnvironmentalDataUncheckedCreateWithoutUserInput> | EnvironmentalDataCreateWithoutUserInput[] | EnvironmentalDataUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EnvironmentalDataCreateOrConnectWithoutUserInput | EnvironmentalDataCreateOrConnectWithoutUserInput[]
    createMany?: EnvironmentalDataCreateManyUserInputEnvelope
    connect?: EnvironmentalDataWhereUniqueInput | EnvironmentalDataWhereUniqueInput[]
  }

  export type GroupMembershipCreateNestedManyWithoutUserInput = {
    create?: XOR<GroupMembershipCreateWithoutUserInput, GroupMembershipUncheckedCreateWithoutUserInput> | GroupMembershipCreateWithoutUserInput[] | GroupMembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GroupMembershipCreateOrConnectWithoutUserInput | GroupMembershipCreateOrConnectWithoutUserInput[]
    createMany?: GroupMembershipCreateManyUserInputEnvelope
    connect?: GroupMembershipWhereUniqueInput | GroupMembershipWhereUniqueInput[]
  }

  export type WorkplaceIntegrationCreateNestedManyWithoutUserInput = {
    create?: XOR<WorkplaceIntegrationCreateWithoutUserInput, WorkplaceIntegrationUncheckedCreateWithoutUserInput> | WorkplaceIntegrationCreateWithoutUserInput[] | WorkplaceIntegrationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkplaceIntegrationCreateOrConnectWithoutUserInput | WorkplaceIntegrationCreateOrConnectWithoutUserInput[]
    createMany?: WorkplaceIntegrationCreateManyUserInputEnvelope
    connect?: WorkplaceIntegrationWhereUniqueInput | WorkplaceIntegrationWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput
    connect?: AccountWhereUniqueInput
  }

  export type JournalEntryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<JournalEntryCreateWithoutUserInput, JournalEntryUncheckedCreateWithoutUserInput> | JournalEntryCreateWithoutUserInput[] | JournalEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JournalEntryCreateOrConnectWithoutUserInput | JournalEntryCreateOrConnectWithoutUserInput[]
    createMany?: JournalEntryCreateManyUserInputEnvelope
    connect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
  }

  export type HabitUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<HabitCreateWithoutUserInput, HabitUncheckedCreateWithoutUserInput> | HabitCreateWithoutUserInput[] | HabitUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HabitCreateOrConnectWithoutUserInput | HabitCreateOrConnectWithoutUserInput[]
    createMany?: HabitCreateManyUserInputEnvelope
    connect?: HabitWhereUniqueInput | HabitWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type BiometricDataUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BiometricDataCreateWithoutUserInput, BiometricDataUncheckedCreateWithoutUserInput> | BiometricDataCreateWithoutUserInput[] | BiometricDataUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BiometricDataCreateOrConnectWithoutUserInput | BiometricDataCreateOrConnectWithoutUserInput[]
    createMany?: BiometricDataCreateManyUserInputEnvelope
    connect?: BiometricDataWhereUniqueInput | BiometricDataWhereUniqueInput[]
  }

  export type MoodEntryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MoodEntryCreateWithoutUserInput, MoodEntryUncheckedCreateWithoutUserInput> | MoodEntryCreateWithoutUserInput[] | MoodEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MoodEntryCreateOrConnectWithoutUserInput | MoodEntryCreateOrConnectWithoutUserInput[]
    createMany?: MoodEntryCreateManyUserInputEnvelope
    connect?: MoodEntryWhereUniqueInput | MoodEntryWhereUniqueInput[]
  }

  export type StressPredictionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<StressPredictionCreateWithoutUserInput, StressPredictionUncheckedCreateWithoutUserInput> | StressPredictionCreateWithoutUserInput[] | StressPredictionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StressPredictionCreateOrConnectWithoutUserInput | StressPredictionCreateOrConnectWithoutUserInput[]
    createMany?: StressPredictionCreateManyUserInputEnvelope
    connect?: StressPredictionWhereUniqueInput | StressPredictionWhereUniqueInput[]
  }

  export type ChallengeParticipantUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ChallengeParticipantCreateWithoutUserInput, ChallengeParticipantUncheckedCreateWithoutUserInput> | ChallengeParticipantCreateWithoutUserInput[] | ChallengeParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChallengeParticipantCreateOrConnectWithoutUserInput | ChallengeParticipantCreateOrConnectWithoutUserInput[]
    createMany?: ChallengeParticipantCreateManyUserInputEnvelope
    connect?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
  }

  export type AIRecommendationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AIRecommendationCreateWithoutUserInput, AIRecommendationUncheckedCreateWithoutUserInput> | AIRecommendationCreateWithoutUserInput[] | AIRecommendationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIRecommendationCreateOrConnectWithoutUserInput | AIRecommendationCreateOrConnectWithoutUserInput[]
    createMany?: AIRecommendationCreateManyUserInputEnvelope
    connect?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
  }

  export type DeviceConnectionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DeviceConnectionCreateWithoutUserInput, DeviceConnectionUncheckedCreateWithoutUserInput> | DeviceConnectionCreateWithoutUserInput[] | DeviceConnectionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeviceConnectionCreateOrConnectWithoutUserInput | DeviceConnectionCreateOrConnectWithoutUserInput[]
    createMany?: DeviceConnectionCreateManyUserInputEnvelope
    connect?: DeviceConnectionWhereUniqueInput | DeviceConnectionWhereUniqueInput[]
  }

  export type WellnessSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WellnessSessionCreateWithoutUserInput, WellnessSessionUncheckedCreateWithoutUserInput> | WellnessSessionCreateWithoutUserInput[] | WellnessSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WellnessSessionCreateOrConnectWithoutUserInput | WellnessSessionCreateOrConnectWithoutUserInput[]
    createMany?: WellnessSessionCreateManyUserInputEnvelope
    connect?: WellnessSessionWhereUniqueInput | WellnessSessionWhereUniqueInput[]
  }

  export type EnvironmentalDataUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EnvironmentalDataCreateWithoutUserInput, EnvironmentalDataUncheckedCreateWithoutUserInput> | EnvironmentalDataCreateWithoutUserInput[] | EnvironmentalDataUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EnvironmentalDataCreateOrConnectWithoutUserInput | EnvironmentalDataCreateOrConnectWithoutUserInput[]
    createMany?: EnvironmentalDataCreateManyUserInputEnvelope
    connect?: EnvironmentalDataWhereUniqueInput | EnvironmentalDataWhereUniqueInput[]
  }

  export type GroupMembershipUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<GroupMembershipCreateWithoutUserInput, GroupMembershipUncheckedCreateWithoutUserInput> | GroupMembershipCreateWithoutUserInput[] | GroupMembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GroupMembershipCreateOrConnectWithoutUserInput | GroupMembershipCreateOrConnectWithoutUserInput[]
    createMany?: GroupMembershipCreateManyUserInputEnvelope
    connect?: GroupMembershipWhereUniqueInput | GroupMembershipWhereUniqueInput[]
  }

  export type WorkplaceIntegrationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WorkplaceIntegrationCreateWithoutUserInput, WorkplaceIntegrationUncheckedCreateWithoutUserInput> | WorkplaceIntegrationCreateWithoutUserInput[] | WorkplaceIntegrationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkplaceIntegrationCreateOrConnectWithoutUserInput | WorkplaceIntegrationCreateOrConnectWithoutUserInput[]
    createMany?: WorkplaceIntegrationCreateManyUserInputEnvelope
    connect?: WorkplaceIntegrationWhereUniqueInput | WorkplaceIntegrationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUpdateOneWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput
    upsert?: AccountUpsertWithoutUserInput
    disconnect?: AccountWhereInput | boolean
    delete?: AccountWhereInput | boolean
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutUserInput, AccountUpdateWithoutUserInput>, AccountUncheckedUpdateWithoutUserInput>
  }

  export type JournalEntryUpdateManyWithoutUserNestedInput = {
    create?: XOR<JournalEntryCreateWithoutUserInput, JournalEntryUncheckedCreateWithoutUserInput> | JournalEntryCreateWithoutUserInput[] | JournalEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JournalEntryCreateOrConnectWithoutUserInput | JournalEntryCreateOrConnectWithoutUserInput[]
    upsert?: JournalEntryUpsertWithWhereUniqueWithoutUserInput | JournalEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: JournalEntryCreateManyUserInputEnvelope
    set?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    disconnect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    delete?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    connect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    update?: JournalEntryUpdateWithWhereUniqueWithoutUserInput | JournalEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: JournalEntryUpdateManyWithWhereWithoutUserInput | JournalEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: JournalEntryScalarWhereInput | JournalEntryScalarWhereInput[]
  }

  export type HabitUpdateManyWithoutUserNestedInput = {
    create?: XOR<HabitCreateWithoutUserInput, HabitUncheckedCreateWithoutUserInput> | HabitCreateWithoutUserInput[] | HabitUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HabitCreateOrConnectWithoutUserInput | HabitCreateOrConnectWithoutUserInput[]
    upsert?: HabitUpsertWithWhereUniqueWithoutUserInput | HabitUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: HabitCreateManyUserInputEnvelope
    set?: HabitWhereUniqueInput | HabitWhereUniqueInput[]
    disconnect?: HabitWhereUniqueInput | HabitWhereUniqueInput[]
    delete?: HabitWhereUniqueInput | HabitWhereUniqueInput[]
    connect?: HabitWhereUniqueInput | HabitWhereUniqueInput[]
    update?: HabitUpdateWithWhereUniqueWithoutUserInput | HabitUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: HabitUpdateManyWithWhereWithoutUserInput | HabitUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: HabitScalarWhereInput | HabitScalarWhereInput[]
  }

  export type BookingUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutUserInput | BookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutUserInput | BookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutUserInput | BookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type BiometricDataUpdateManyWithoutUserNestedInput = {
    create?: XOR<BiometricDataCreateWithoutUserInput, BiometricDataUncheckedCreateWithoutUserInput> | BiometricDataCreateWithoutUserInput[] | BiometricDataUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BiometricDataCreateOrConnectWithoutUserInput | BiometricDataCreateOrConnectWithoutUserInput[]
    upsert?: BiometricDataUpsertWithWhereUniqueWithoutUserInput | BiometricDataUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BiometricDataCreateManyUserInputEnvelope
    set?: BiometricDataWhereUniqueInput | BiometricDataWhereUniqueInput[]
    disconnect?: BiometricDataWhereUniqueInput | BiometricDataWhereUniqueInput[]
    delete?: BiometricDataWhereUniqueInput | BiometricDataWhereUniqueInput[]
    connect?: BiometricDataWhereUniqueInput | BiometricDataWhereUniqueInput[]
    update?: BiometricDataUpdateWithWhereUniqueWithoutUserInput | BiometricDataUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BiometricDataUpdateManyWithWhereWithoutUserInput | BiometricDataUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BiometricDataScalarWhereInput | BiometricDataScalarWhereInput[]
  }

  export type MoodEntryUpdateManyWithoutUserNestedInput = {
    create?: XOR<MoodEntryCreateWithoutUserInput, MoodEntryUncheckedCreateWithoutUserInput> | MoodEntryCreateWithoutUserInput[] | MoodEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MoodEntryCreateOrConnectWithoutUserInput | MoodEntryCreateOrConnectWithoutUserInput[]
    upsert?: MoodEntryUpsertWithWhereUniqueWithoutUserInput | MoodEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MoodEntryCreateManyUserInputEnvelope
    set?: MoodEntryWhereUniqueInput | MoodEntryWhereUniqueInput[]
    disconnect?: MoodEntryWhereUniqueInput | MoodEntryWhereUniqueInput[]
    delete?: MoodEntryWhereUniqueInput | MoodEntryWhereUniqueInput[]
    connect?: MoodEntryWhereUniqueInput | MoodEntryWhereUniqueInput[]
    update?: MoodEntryUpdateWithWhereUniqueWithoutUserInput | MoodEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MoodEntryUpdateManyWithWhereWithoutUserInput | MoodEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MoodEntryScalarWhereInput | MoodEntryScalarWhereInput[]
  }

  export type StressPredictionUpdateManyWithoutUserNestedInput = {
    create?: XOR<StressPredictionCreateWithoutUserInput, StressPredictionUncheckedCreateWithoutUserInput> | StressPredictionCreateWithoutUserInput[] | StressPredictionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StressPredictionCreateOrConnectWithoutUserInput | StressPredictionCreateOrConnectWithoutUserInput[]
    upsert?: StressPredictionUpsertWithWhereUniqueWithoutUserInput | StressPredictionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StressPredictionCreateManyUserInputEnvelope
    set?: StressPredictionWhereUniqueInput | StressPredictionWhereUniqueInput[]
    disconnect?: StressPredictionWhereUniqueInput | StressPredictionWhereUniqueInput[]
    delete?: StressPredictionWhereUniqueInput | StressPredictionWhereUniqueInput[]
    connect?: StressPredictionWhereUniqueInput | StressPredictionWhereUniqueInput[]
    update?: StressPredictionUpdateWithWhereUniqueWithoutUserInput | StressPredictionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StressPredictionUpdateManyWithWhereWithoutUserInput | StressPredictionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StressPredictionScalarWhereInput | StressPredictionScalarWhereInput[]
  }

  export type ChallengeParticipantUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChallengeParticipantCreateWithoutUserInput, ChallengeParticipantUncheckedCreateWithoutUserInput> | ChallengeParticipantCreateWithoutUserInput[] | ChallengeParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChallengeParticipantCreateOrConnectWithoutUserInput | ChallengeParticipantCreateOrConnectWithoutUserInput[]
    upsert?: ChallengeParticipantUpsertWithWhereUniqueWithoutUserInput | ChallengeParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChallengeParticipantCreateManyUserInputEnvelope
    set?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
    disconnect?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
    delete?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
    connect?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
    update?: ChallengeParticipantUpdateWithWhereUniqueWithoutUserInput | ChallengeParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChallengeParticipantUpdateManyWithWhereWithoutUserInput | ChallengeParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChallengeParticipantScalarWhereInput | ChallengeParticipantScalarWhereInput[]
  }

  export type AIRecommendationUpdateManyWithoutUserNestedInput = {
    create?: XOR<AIRecommendationCreateWithoutUserInput, AIRecommendationUncheckedCreateWithoutUserInput> | AIRecommendationCreateWithoutUserInput[] | AIRecommendationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIRecommendationCreateOrConnectWithoutUserInput | AIRecommendationCreateOrConnectWithoutUserInput[]
    upsert?: AIRecommendationUpsertWithWhereUniqueWithoutUserInput | AIRecommendationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AIRecommendationCreateManyUserInputEnvelope
    set?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
    disconnect?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
    delete?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
    connect?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
    update?: AIRecommendationUpdateWithWhereUniqueWithoutUserInput | AIRecommendationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AIRecommendationUpdateManyWithWhereWithoutUserInput | AIRecommendationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AIRecommendationScalarWhereInput | AIRecommendationScalarWhereInput[]
  }

  export type DeviceConnectionUpdateManyWithoutUserNestedInput = {
    create?: XOR<DeviceConnectionCreateWithoutUserInput, DeviceConnectionUncheckedCreateWithoutUserInput> | DeviceConnectionCreateWithoutUserInput[] | DeviceConnectionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeviceConnectionCreateOrConnectWithoutUserInput | DeviceConnectionCreateOrConnectWithoutUserInput[]
    upsert?: DeviceConnectionUpsertWithWhereUniqueWithoutUserInput | DeviceConnectionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DeviceConnectionCreateManyUserInputEnvelope
    set?: DeviceConnectionWhereUniqueInput | DeviceConnectionWhereUniqueInput[]
    disconnect?: DeviceConnectionWhereUniqueInput | DeviceConnectionWhereUniqueInput[]
    delete?: DeviceConnectionWhereUniqueInput | DeviceConnectionWhereUniqueInput[]
    connect?: DeviceConnectionWhereUniqueInput | DeviceConnectionWhereUniqueInput[]
    update?: DeviceConnectionUpdateWithWhereUniqueWithoutUserInput | DeviceConnectionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DeviceConnectionUpdateManyWithWhereWithoutUserInput | DeviceConnectionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DeviceConnectionScalarWhereInput | DeviceConnectionScalarWhereInput[]
  }

  export type WellnessSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<WellnessSessionCreateWithoutUserInput, WellnessSessionUncheckedCreateWithoutUserInput> | WellnessSessionCreateWithoutUserInput[] | WellnessSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WellnessSessionCreateOrConnectWithoutUserInput | WellnessSessionCreateOrConnectWithoutUserInput[]
    upsert?: WellnessSessionUpsertWithWhereUniqueWithoutUserInput | WellnessSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WellnessSessionCreateManyUserInputEnvelope
    set?: WellnessSessionWhereUniqueInput | WellnessSessionWhereUniqueInput[]
    disconnect?: WellnessSessionWhereUniqueInput | WellnessSessionWhereUniqueInput[]
    delete?: WellnessSessionWhereUniqueInput | WellnessSessionWhereUniqueInput[]
    connect?: WellnessSessionWhereUniqueInput | WellnessSessionWhereUniqueInput[]
    update?: WellnessSessionUpdateWithWhereUniqueWithoutUserInput | WellnessSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WellnessSessionUpdateManyWithWhereWithoutUserInput | WellnessSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WellnessSessionScalarWhereInput | WellnessSessionScalarWhereInput[]
  }

  export type EnvironmentalDataUpdateManyWithoutUserNestedInput = {
    create?: XOR<EnvironmentalDataCreateWithoutUserInput, EnvironmentalDataUncheckedCreateWithoutUserInput> | EnvironmentalDataCreateWithoutUserInput[] | EnvironmentalDataUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EnvironmentalDataCreateOrConnectWithoutUserInput | EnvironmentalDataCreateOrConnectWithoutUserInput[]
    upsert?: EnvironmentalDataUpsertWithWhereUniqueWithoutUserInput | EnvironmentalDataUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EnvironmentalDataCreateManyUserInputEnvelope
    set?: EnvironmentalDataWhereUniqueInput | EnvironmentalDataWhereUniqueInput[]
    disconnect?: EnvironmentalDataWhereUniqueInput | EnvironmentalDataWhereUniqueInput[]
    delete?: EnvironmentalDataWhereUniqueInput | EnvironmentalDataWhereUniqueInput[]
    connect?: EnvironmentalDataWhereUniqueInput | EnvironmentalDataWhereUniqueInput[]
    update?: EnvironmentalDataUpdateWithWhereUniqueWithoutUserInput | EnvironmentalDataUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EnvironmentalDataUpdateManyWithWhereWithoutUserInput | EnvironmentalDataUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EnvironmentalDataScalarWhereInput | EnvironmentalDataScalarWhereInput[]
  }

  export type GroupMembershipUpdateManyWithoutUserNestedInput = {
    create?: XOR<GroupMembershipCreateWithoutUserInput, GroupMembershipUncheckedCreateWithoutUserInput> | GroupMembershipCreateWithoutUserInput[] | GroupMembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GroupMembershipCreateOrConnectWithoutUserInput | GroupMembershipCreateOrConnectWithoutUserInput[]
    upsert?: GroupMembershipUpsertWithWhereUniqueWithoutUserInput | GroupMembershipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GroupMembershipCreateManyUserInputEnvelope
    set?: GroupMembershipWhereUniqueInput | GroupMembershipWhereUniqueInput[]
    disconnect?: GroupMembershipWhereUniqueInput | GroupMembershipWhereUniqueInput[]
    delete?: GroupMembershipWhereUniqueInput | GroupMembershipWhereUniqueInput[]
    connect?: GroupMembershipWhereUniqueInput | GroupMembershipWhereUniqueInput[]
    update?: GroupMembershipUpdateWithWhereUniqueWithoutUserInput | GroupMembershipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GroupMembershipUpdateManyWithWhereWithoutUserInput | GroupMembershipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GroupMembershipScalarWhereInput | GroupMembershipScalarWhereInput[]
  }

  export type WorkplaceIntegrationUpdateManyWithoutUserNestedInput = {
    create?: XOR<WorkplaceIntegrationCreateWithoutUserInput, WorkplaceIntegrationUncheckedCreateWithoutUserInput> | WorkplaceIntegrationCreateWithoutUserInput[] | WorkplaceIntegrationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkplaceIntegrationCreateOrConnectWithoutUserInput | WorkplaceIntegrationCreateOrConnectWithoutUserInput[]
    upsert?: WorkplaceIntegrationUpsertWithWhereUniqueWithoutUserInput | WorkplaceIntegrationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WorkplaceIntegrationCreateManyUserInputEnvelope
    set?: WorkplaceIntegrationWhereUniqueInput | WorkplaceIntegrationWhereUniqueInput[]
    disconnect?: WorkplaceIntegrationWhereUniqueInput | WorkplaceIntegrationWhereUniqueInput[]
    delete?: WorkplaceIntegrationWhereUniqueInput | WorkplaceIntegrationWhereUniqueInput[]
    connect?: WorkplaceIntegrationWhereUniqueInput | WorkplaceIntegrationWhereUniqueInput[]
    update?: WorkplaceIntegrationUpdateWithWhereUniqueWithoutUserInput | WorkplaceIntegrationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WorkplaceIntegrationUpdateManyWithWhereWithoutUserInput | WorkplaceIntegrationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WorkplaceIntegrationScalarWhereInput | WorkplaceIntegrationScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput
    upsert?: AccountUpsertWithoutUserInput
    disconnect?: AccountWhereInput | boolean
    delete?: AccountWhereInput | boolean
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutUserInput, AccountUpdateWithoutUserInput>, AccountUncheckedUpdateWithoutUserInput>
  }

  export type JournalEntryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<JournalEntryCreateWithoutUserInput, JournalEntryUncheckedCreateWithoutUserInput> | JournalEntryCreateWithoutUserInput[] | JournalEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JournalEntryCreateOrConnectWithoutUserInput | JournalEntryCreateOrConnectWithoutUserInput[]
    upsert?: JournalEntryUpsertWithWhereUniqueWithoutUserInput | JournalEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: JournalEntryCreateManyUserInputEnvelope
    set?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    disconnect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    delete?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    connect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    update?: JournalEntryUpdateWithWhereUniqueWithoutUserInput | JournalEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: JournalEntryUpdateManyWithWhereWithoutUserInput | JournalEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: JournalEntryScalarWhereInput | JournalEntryScalarWhereInput[]
  }

  export type HabitUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<HabitCreateWithoutUserInput, HabitUncheckedCreateWithoutUserInput> | HabitCreateWithoutUserInput[] | HabitUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HabitCreateOrConnectWithoutUserInput | HabitCreateOrConnectWithoutUserInput[]
    upsert?: HabitUpsertWithWhereUniqueWithoutUserInput | HabitUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: HabitCreateManyUserInputEnvelope
    set?: HabitWhereUniqueInput | HabitWhereUniqueInput[]
    disconnect?: HabitWhereUniqueInput | HabitWhereUniqueInput[]
    delete?: HabitWhereUniqueInput | HabitWhereUniqueInput[]
    connect?: HabitWhereUniqueInput | HabitWhereUniqueInput[]
    update?: HabitUpdateWithWhereUniqueWithoutUserInput | HabitUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: HabitUpdateManyWithWhereWithoutUserInput | HabitUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: HabitScalarWhereInput | HabitScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutUserInput | BookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutUserInput | BookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutUserInput | BookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type BiometricDataUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BiometricDataCreateWithoutUserInput, BiometricDataUncheckedCreateWithoutUserInput> | BiometricDataCreateWithoutUserInput[] | BiometricDataUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BiometricDataCreateOrConnectWithoutUserInput | BiometricDataCreateOrConnectWithoutUserInput[]
    upsert?: BiometricDataUpsertWithWhereUniqueWithoutUserInput | BiometricDataUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BiometricDataCreateManyUserInputEnvelope
    set?: BiometricDataWhereUniqueInput | BiometricDataWhereUniqueInput[]
    disconnect?: BiometricDataWhereUniqueInput | BiometricDataWhereUniqueInput[]
    delete?: BiometricDataWhereUniqueInput | BiometricDataWhereUniqueInput[]
    connect?: BiometricDataWhereUniqueInput | BiometricDataWhereUniqueInput[]
    update?: BiometricDataUpdateWithWhereUniqueWithoutUserInput | BiometricDataUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BiometricDataUpdateManyWithWhereWithoutUserInput | BiometricDataUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BiometricDataScalarWhereInput | BiometricDataScalarWhereInput[]
  }

  export type MoodEntryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MoodEntryCreateWithoutUserInput, MoodEntryUncheckedCreateWithoutUserInput> | MoodEntryCreateWithoutUserInput[] | MoodEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MoodEntryCreateOrConnectWithoutUserInput | MoodEntryCreateOrConnectWithoutUserInput[]
    upsert?: MoodEntryUpsertWithWhereUniqueWithoutUserInput | MoodEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MoodEntryCreateManyUserInputEnvelope
    set?: MoodEntryWhereUniqueInput | MoodEntryWhereUniqueInput[]
    disconnect?: MoodEntryWhereUniqueInput | MoodEntryWhereUniqueInput[]
    delete?: MoodEntryWhereUniqueInput | MoodEntryWhereUniqueInput[]
    connect?: MoodEntryWhereUniqueInput | MoodEntryWhereUniqueInput[]
    update?: MoodEntryUpdateWithWhereUniqueWithoutUserInput | MoodEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MoodEntryUpdateManyWithWhereWithoutUserInput | MoodEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MoodEntryScalarWhereInput | MoodEntryScalarWhereInput[]
  }

  export type StressPredictionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<StressPredictionCreateWithoutUserInput, StressPredictionUncheckedCreateWithoutUserInput> | StressPredictionCreateWithoutUserInput[] | StressPredictionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StressPredictionCreateOrConnectWithoutUserInput | StressPredictionCreateOrConnectWithoutUserInput[]
    upsert?: StressPredictionUpsertWithWhereUniqueWithoutUserInput | StressPredictionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StressPredictionCreateManyUserInputEnvelope
    set?: StressPredictionWhereUniqueInput | StressPredictionWhereUniqueInput[]
    disconnect?: StressPredictionWhereUniqueInput | StressPredictionWhereUniqueInput[]
    delete?: StressPredictionWhereUniqueInput | StressPredictionWhereUniqueInput[]
    connect?: StressPredictionWhereUniqueInput | StressPredictionWhereUniqueInput[]
    update?: StressPredictionUpdateWithWhereUniqueWithoutUserInput | StressPredictionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StressPredictionUpdateManyWithWhereWithoutUserInput | StressPredictionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StressPredictionScalarWhereInput | StressPredictionScalarWhereInput[]
  }

  export type ChallengeParticipantUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChallengeParticipantCreateWithoutUserInput, ChallengeParticipantUncheckedCreateWithoutUserInput> | ChallengeParticipantCreateWithoutUserInput[] | ChallengeParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChallengeParticipantCreateOrConnectWithoutUserInput | ChallengeParticipantCreateOrConnectWithoutUserInput[]
    upsert?: ChallengeParticipantUpsertWithWhereUniqueWithoutUserInput | ChallengeParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChallengeParticipantCreateManyUserInputEnvelope
    set?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
    disconnect?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
    delete?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
    connect?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
    update?: ChallengeParticipantUpdateWithWhereUniqueWithoutUserInput | ChallengeParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChallengeParticipantUpdateManyWithWhereWithoutUserInput | ChallengeParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChallengeParticipantScalarWhereInput | ChallengeParticipantScalarWhereInput[]
  }

  export type AIRecommendationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AIRecommendationCreateWithoutUserInput, AIRecommendationUncheckedCreateWithoutUserInput> | AIRecommendationCreateWithoutUserInput[] | AIRecommendationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIRecommendationCreateOrConnectWithoutUserInput | AIRecommendationCreateOrConnectWithoutUserInput[]
    upsert?: AIRecommendationUpsertWithWhereUniqueWithoutUserInput | AIRecommendationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AIRecommendationCreateManyUserInputEnvelope
    set?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
    disconnect?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
    delete?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
    connect?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
    update?: AIRecommendationUpdateWithWhereUniqueWithoutUserInput | AIRecommendationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AIRecommendationUpdateManyWithWhereWithoutUserInput | AIRecommendationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AIRecommendationScalarWhereInput | AIRecommendationScalarWhereInput[]
  }

  export type DeviceConnectionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DeviceConnectionCreateWithoutUserInput, DeviceConnectionUncheckedCreateWithoutUserInput> | DeviceConnectionCreateWithoutUserInput[] | DeviceConnectionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeviceConnectionCreateOrConnectWithoutUserInput | DeviceConnectionCreateOrConnectWithoutUserInput[]
    upsert?: DeviceConnectionUpsertWithWhereUniqueWithoutUserInput | DeviceConnectionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DeviceConnectionCreateManyUserInputEnvelope
    set?: DeviceConnectionWhereUniqueInput | DeviceConnectionWhereUniqueInput[]
    disconnect?: DeviceConnectionWhereUniqueInput | DeviceConnectionWhereUniqueInput[]
    delete?: DeviceConnectionWhereUniqueInput | DeviceConnectionWhereUniqueInput[]
    connect?: DeviceConnectionWhereUniqueInput | DeviceConnectionWhereUniqueInput[]
    update?: DeviceConnectionUpdateWithWhereUniqueWithoutUserInput | DeviceConnectionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DeviceConnectionUpdateManyWithWhereWithoutUserInput | DeviceConnectionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DeviceConnectionScalarWhereInput | DeviceConnectionScalarWhereInput[]
  }

  export type WellnessSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WellnessSessionCreateWithoutUserInput, WellnessSessionUncheckedCreateWithoutUserInput> | WellnessSessionCreateWithoutUserInput[] | WellnessSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WellnessSessionCreateOrConnectWithoutUserInput | WellnessSessionCreateOrConnectWithoutUserInput[]
    upsert?: WellnessSessionUpsertWithWhereUniqueWithoutUserInput | WellnessSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WellnessSessionCreateManyUserInputEnvelope
    set?: WellnessSessionWhereUniqueInput | WellnessSessionWhereUniqueInput[]
    disconnect?: WellnessSessionWhereUniqueInput | WellnessSessionWhereUniqueInput[]
    delete?: WellnessSessionWhereUniqueInput | WellnessSessionWhereUniqueInput[]
    connect?: WellnessSessionWhereUniqueInput | WellnessSessionWhereUniqueInput[]
    update?: WellnessSessionUpdateWithWhereUniqueWithoutUserInput | WellnessSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WellnessSessionUpdateManyWithWhereWithoutUserInput | WellnessSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WellnessSessionScalarWhereInput | WellnessSessionScalarWhereInput[]
  }

  export type EnvironmentalDataUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EnvironmentalDataCreateWithoutUserInput, EnvironmentalDataUncheckedCreateWithoutUserInput> | EnvironmentalDataCreateWithoutUserInput[] | EnvironmentalDataUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EnvironmentalDataCreateOrConnectWithoutUserInput | EnvironmentalDataCreateOrConnectWithoutUserInput[]
    upsert?: EnvironmentalDataUpsertWithWhereUniqueWithoutUserInput | EnvironmentalDataUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EnvironmentalDataCreateManyUserInputEnvelope
    set?: EnvironmentalDataWhereUniqueInput | EnvironmentalDataWhereUniqueInput[]
    disconnect?: EnvironmentalDataWhereUniqueInput | EnvironmentalDataWhereUniqueInput[]
    delete?: EnvironmentalDataWhereUniqueInput | EnvironmentalDataWhereUniqueInput[]
    connect?: EnvironmentalDataWhereUniqueInput | EnvironmentalDataWhereUniqueInput[]
    update?: EnvironmentalDataUpdateWithWhereUniqueWithoutUserInput | EnvironmentalDataUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EnvironmentalDataUpdateManyWithWhereWithoutUserInput | EnvironmentalDataUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EnvironmentalDataScalarWhereInput | EnvironmentalDataScalarWhereInput[]
  }

  export type GroupMembershipUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<GroupMembershipCreateWithoutUserInput, GroupMembershipUncheckedCreateWithoutUserInput> | GroupMembershipCreateWithoutUserInput[] | GroupMembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GroupMembershipCreateOrConnectWithoutUserInput | GroupMembershipCreateOrConnectWithoutUserInput[]
    upsert?: GroupMembershipUpsertWithWhereUniqueWithoutUserInput | GroupMembershipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GroupMembershipCreateManyUserInputEnvelope
    set?: GroupMembershipWhereUniqueInput | GroupMembershipWhereUniqueInput[]
    disconnect?: GroupMembershipWhereUniqueInput | GroupMembershipWhereUniqueInput[]
    delete?: GroupMembershipWhereUniqueInput | GroupMembershipWhereUniqueInput[]
    connect?: GroupMembershipWhereUniqueInput | GroupMembershipWhereUniqueInput[]
    update?: GroupMembershipUpdateWithWhereUniqueWithoutUserInput | GroupMembershipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GroupMembershipUpdateManyWithWhereWithoutUserInput | GroupMembershipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GroupMembershipScalarWhereInput | GroupMembershipScalarWhereInput[]
  }

  export type WorkplaceIntegrationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WorkplaceIntegrationCreateWithoutUserInput, WorkplaceIntegrationUncheckedCreateWithoutUserInput> | WorkplaceIntegrationCreateWithoutUserInput[] | WorkplaceIntegrationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkplaceIntegrationCreateOrConnectWithoutUserInput | WorkplaceIntegrationCreateOrConnectWithoutUserInput[]
    upsert?: WorkplaceIntegrationUpsertWithWhereUniqueWithoutUserInput | WorkplaceIntegrationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WorkplaceIntegrationCreateManyUserInputEnvelope
    set?: WorkplaceIntegrationWhereUniqueInput | WorkplaceIntegrationWhereUniqueInput[]
    disconnect?: WorkplaceIntegrationWhereUniqueInput | WorkplaceIntegrationWhereUniqueInput[]
    delete?: WorkplaceIntegrationWhereUniqueInput | WorkplaceIntegrationWhereUniqueInput[]
    connect?: WorkplaceIntegrationWhereUniqueInput | WorkplaceIntegrationWhereUniqueInput[]
    update?: WorkplaceIntegrationUpdateWithWhereUniqueWithoutUserInput | WorkplaceIntegrationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WorkplaceIntegrationUpdateManyWithWhereWithoutUserInput | WorkplaceIntegrationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WorkplaceIntegrationScalarWhereInput | WorkplaceIntegrationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutAccountInput = {
    create?: XOR<UserCreateWithoutAccountInput, UserUncheckedCreateWithoutAccountInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountInput
    connect?: UserWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutAccountNestedInput = {
    create?: XOR<UserCreateWithoutAccountInput, UserUncheckedCreateWithoutAccountInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountInput
    upsert?: UserUpsertWithoutAccountInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountInput, UserUpdateWithoutAccountInput>, UserUncheckedUpdateWithoutAccountInput>
  }

  export type UserCreateNestedOneWithoutJournalEntriesInput = {
    create?: XOR<UserCreateWithoutJournalEntriesInput, UserUncheckedCreateWithoutJournalEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutJournalEntriesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutJournalEntriesNestedInput = {
    create?: XOR<UserCreateWithoutJournalEntriesInput, UserUncheckedCreateWithoutJournalEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutJournalEntriesInput
    upsert?: UserUpsertWithoutJournalEntriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutJournalEntriesInput, UserUpdateWithoutJournalEntriesInput>, UserUncheckedUpdateWithoutJournalEntriesInput>
  }

  export type UserCreateNestedOneWithoutHabitsInput = {
    create?: XOR<UserCreateWithoutHabitsInput, UserUncheckedCreateWithoutHabitsInput>
    connectOrCreate?: UserCreateOrConnectWithoutHabitsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutHabitsNestedInput = {
    create?: XOR<UserCreateWithoutHabitsInput, UserUncheckedCreateWithoutHabitsInput>
    connectOrCreate?: UserCreateOrConnectWithoutHabitsInput
    upsert?: UserUpsertWithoutHabitsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutHabitsInput, UserUpdateWithoutHabitsInput>, UserUncheckedUpdateWithoutHabitsInput>
  }

  export type BookingCreateNestedManyWithoutClassInput = {
    create?: XOR<BookingCreateWithoutClassInput, BookingUncheckedCreateWithoutClassInput> | BookingCreateWithoutClassInput[] | BookingUncheckedCreateWithoutClassInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutClassInput | BookingCreateOrConnectWithoutClassInput[]
    createMany?: BookingCreateManyClassInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<BookingCreateWithoutClassInput, BookingUncheckedCreateWithoutClassInput> | BookingCreateWithoutClassInput[] | BookingUncheckedCreateWithoutClassInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutClassInput | BookingCreateOrConnectWithoutClassInput[]
    createMany?: BookingCreateManyClassInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BookingUpdateManyWithoutClassNestedInput = {
    create?: XOR<BookingCreateWithoutClassInput, BookingUncheckedCreateWithoutClassInput> | BookingCreateWithoutClassInput[] | BookingUncheckedCreateWithoutClassInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutClassInput | BookingCreateOrConnectWithoutClassInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutClassInput | BookingUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: BookingCreateManyClassInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutClassInput | BookingUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutClassInput | BookingUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<BookingCreateWithoutClassInput, BookingUncheckedCreateWithoutClassInput> | BookingCreateWithoutClassInput[] | BookingUncheckedCreateWithoutClassInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutClassInput | BookingCreateOrConnectWithoutClassInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutClassInput | BookingUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: BookingCreateManyClassInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutClassInput | BookingUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutClassInput | BookingUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutBookingsInput = {
    create?: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsInput
    connect?: UserWhereUniqueInput
  }

  export type ClassCreateNestedOneWithoutBookingsInput = {
    create?: XOR<ClassCreateWithoutBookingsInput, ClassUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutBookingsInput
    connect?: ClassWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsInput
    upsert?: UserUpsertWithoutBookingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBookingsInput, UserUpdateWithoutBookingsInput>, UserUncheckedUpdateWithoutBookingsInput>
  }

  export type ClassUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<ClassCreateWithoutBookingsInput, ClassUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutBookingsInput
    upsert?: ClassUpsertWithoutBookingsInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutBookingsInput, ClassUpdateWithoutBookingsInput>, ClassUncheckedUpdateWithoutBookingsInput>
  }

  export type UserCreateNestedOneWithoutBiometricDataInput = {
    create?: XOR<UserCreateWithoutBiometricDataInput, UserUncheckedCreateWithoutBiometricDataInput>
    connectOrCreate?: UserCreateOrConnectWithoutBiometricDataInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutBiometricDataNestedInput = {
    create?: XOR<UserCreateWithoutBiometricDataInput, UserUncheckedCreateWithoutBiometricDataInput>
    connectOrCreate?: UserCreateOrConnectWithoutBiometricDataInput
    upsert?: UserUpsertWithoutBiometricDataInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBiometricDataInput, UserUpdateWithoutBiometricDataInput>, UserUncheckedUpdateWithoutBiometricDataInput>
  }

  export type UserCreateNestedOneWithoutMoodEntriesInput = {
    create?: XOR<UserCreateWithoutMoodEntriesInput, UserUncheckedCreateWithoutMoodEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMoodEntriesInput
    connect?: UserWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutMoodEntriesNestedInput = {
    create?: XOR<UserCreateWithoutMoodEntriesInput, UserUncheckedCreateWithoutMoodEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMoodEntriesInput
    upsert?: UserUpsertWithoutMoodEntriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMoodEntriesInput, UserUpdateWithoutMoodEntriesInput>, UserUncheckedUpdateWithoutMoodEntriesInput>
  }

  export type UserCreateNestedOneWithoutStressPredictionsInput = {
    create?: XOR<UserCreateWithoutStressPredictionsInput, UserUncheckedCreateWithoutStressPredictionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStressPredictionsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type UserUpdateOneRequiredWithoutStressPredictionsNestedInput = {
    create?: XOR<UserCreateWithoutStressPredictionsInput, UserUncheckedCreateWithoutStressPredictionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStressPredictionsInput
    upsert?: UserUpsertWithoutStressPredictionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStressPredictionsInput, UserUpdateWithoutStressPredictionsInput>, UserUncheckedUpdateWithoutStressPredictionsInput>
  }

  export type ChallengeParticipantCreateNestedManyWithoutChallengeInput = {
    create?: XOR<ChallengeParticipantCreateWithoutChallengeInput, ChallengeParticipantUncheckedCreateWithoutChallengeInput> | ChallengeParticipantCreateWithoutChallengeInput[] | ChallengeParticipantUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeParticipantCreateOrConnectWithoutChallengeInput | ChallengeParticipantCreateOrConnectWithoutChallengeInput[]
    createMany?: ChallengeParticipantCreateManyChallengeInputEnvelope
    connect?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
  }

  export type ChallengeParticipantUncheckedCreateNestedManyWithoutChallengeInput = {
    create?: XOR<ChallengeParticipantCreateWithoutChallengeInput, ChallengeParticipantUncheckedCreateWithoutChallengeInput> | ChallengeParticipantCreateWithoutChallengeInput[] | ChallengeParticipantUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeParticipantCreateOrConnectWithoutChallengeInput | ChallengeParticipantCreateOrConnectWithoutChallengeInput[]
    createMany?: ChallengeParticipantCreateManyChallengeInputEnvelope
    connect?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
  }

  export type ChallengeParticipantUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<ChallengeParticipantCreateWithoutChallengeInput, ChallengeParticipantUncheckedCreateWithoutChallengeInput> | ChallengeParticipantCreateWithoutChallengeInput[] | ChallengeParticipantUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeParticipantCreateOrConnectWithoutChallengeInput | ChallengeParticipantCreateOrConnectWithoutChallengeInput[]
    upsert?: ChallengeParticipantUpsertWithWhereUniqueWithoutChallengeInput | ChallengeParticipantUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: ChallengeParticipantCreateManyChallengeInputEnvelope
    set?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
    disconnect?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
    delete?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
    connect?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
    update?: ChallengeParticipantUpdateWithWhereUniqueWithoutChallengeInput | ChallengeParticipantUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: ChallengeParticipantUpdateManyWithWhereWithoutChallengeInput | ChallengeParticipantUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: ChallengeParticipantScalarWhereInput | ChallengeParticipantScalarWhereInput[]
  }

  export type ChallengeParticipantUncheckedUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<ChallengeParticipantCreateWithoutChallengeInput, ChallengeParticipantUncheckedCreateWithoutChallengeInput> | ChallengeParticipantCreateWithoutChallengeInput[] | ChallengeParticipantUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeParticipantCreateOrConnectWithoutChallengeInput | ChallengeParticipantCreateOrConnectWithoutChallengeInput[]
    upsert?: ChallengeParticipantUpsertWithWhereUniqueWithoutChallengeInput | ChallengeParticipantUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: ChallengeParticipantCreateManyChallengeInputEnvelope
    set?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
    disconnect?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
    delete?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
    connect?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
    update?: ChallengeParticipantUpdateWithWhereUniqueWithoutChallengeInput | ChallengeParticipantUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: ChallengeParticipantUpdateManyWithWhereWithoutChallengeInput | ChallengeParticipantUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: ChallengeParticipantScalarWhereInput | ChallengeParticipantScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutChallengeParticipantsInput = {
    create?: XOR<UserCreateWithoutChallengeParticipantsInput, UserUncheckedCreateWithoutChallengeParticipantsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChallengeParticipantsInput
    connect?: UserWhereUniqueInput
  }

  export type WellnessChallengeCreateNestedOneWithoutParticipantsInput = {
    create?: XOR<WellnessChallengeCreateWithoutParticipantsInput, WellnessChallengeUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: WellnessChallengeCreateOrConnectWithoutParticipantsInput
    connect?: WellnessChallengeWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutChallengeParticipantsNestedInput = {
    create?: XOR<UserCreateWithoutChallengeParticipantsInput, UserUncheckedCreateWithoutChallengeParticipantsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChallengeParticipantsInput
    upsert?: UserUpsertWithoutChallengeParticipantsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChallengeParticipantsInput, UserUpdateWithoutChallengeParticipantsInput>, UserUncheckedUpdateWithoutChallengeParticipantsInput>
  }

  export type WellnessChallengeUpdateOneRequiredWithoutParticipantsNestedInput = {
    create?: XOR<WellnessChallengeCreateWithoutParticipantsInput, WellnessChallengeUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: WellnessChallengeCreateOrConnectWithoutParticipantsInput
    upsert?: WellnessChallengeUpsertWithoutParticipantsInput
    connect?: WellnessChallengeWhereUniqueInput
    update?: XOR<XOR<WellnessChallengeUpdateToOneWithWhereWithoutParticipantsInput, WellnessChallengeUpdateWithoutParticipantsInput>, WellnessChallengeUncheckedUpdateWithoutParticipantsInput>
  }

  export type UserCreateNestedOneWithoutAiRecommendationsInput = {
    create?: XOR<UserCreateWithoutAiRecommendationsInput, UserUncheckedCreateWithoutAiRecommendationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAiRecommendationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAiRecommendationsNestedInput = {
    create?: XOR<UserCreateWithoutAiRecommendationsInput, UserUncheckedCreateWithoutAiRecommendationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAiRecommendationsInput
    upsert?: UserUpsertWithoutAiRecommendationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAiRecommendationsInput, UserUpdateWithoutAiRecommendationsInput>, UserUncheckedUpdateWithoutAiRecommendationsInput>
  }

  export type UserCreateNestedOneWithoutDeviceConnectionsInput = {
    create?: XOR<UserCreateWithoutDeviceConnectionsInput, UserUncheckedCreateWithoutDeviceConnectionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeviceConnectionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDeviceConnectionsNestedInput = {
    create?: XOR<UserCreateWithoutDeviceConnectionsInput, UserUncheckedCreateWithoutDeviceConnectionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeviceConnectionsInput
    upsert?: UserUpsertWithoutDeviceConnectionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDeviceConnectionsInput, UserUpdateWithoutDeviceConnectionsInput>, UserUncheckedUpdateWithoutDeviceConnectionsInput>
  }

  export type UserCreateNestedOneWithoutWellnessSessionsInput = {
    create?: XOR<UserCreateWithoutWellnessSessionsInput, UserUncheckedCreateWithoutWellnessSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWellnessSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutWellnessSessionsNestedInput = {
    create?: XOR<UserCreateWithoutWellnessSessionsInput, UserUncheckedCreateWithoutWellnessSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWellnessSessionsInput
    upsert?: UserUpsertWithoutWellnessSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWellnessSessionsInput, UserUpdateWithoutWellnessSessionsInput>, UserUncheckedUpdateWithoutWellnessSessionsInput>
  }

  export type UserCreateNestedOneWithoutEnvironmentalDataInput = {
    create?: XOR<UserCreateWithoutEnvironmentalDataInput, UserUncheckedCreateWithoutEnvironmentalDataInput>
    connectOrCreate?: UserCreateOrConnectWithoutEnvironmentalDataInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutEnvironmentalDataNestedInput = {
    create?: XOR<UserCreateWithoutEnvironmentalDataInput, UserUncheckedCreateWithoutEnvironmentalDataInput>
    connectOrCreate?: UserCreateOrConnectWithoutEnvironmentalDataInput
    upsert?: UserUpsertWithoutEnvironmentalDataInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEnvironmentalDataInput, UserUpdateWithoutEnvironmentalDataInput>, UserUncheckedUpdateWithoutEnvironmentalDataInput>
  }

  export type GroupMembershipCreateNestedManyWithoutGroupInput = {
    create?: XOR<GroupMembershipCreateWithoutGroupInput, GroupMembershipUncheckedCreateWithoutGroupInput> | GroupMembershipCreateWithoutGroupInput[] | GroupMembershipUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupMembershipCreateOrConnectWithoutGroupInput | GroupMembershipCreateOrConnectWithoutGroupInput[]
    createMany?: GroupMembershipCreateManyGroupInputEnvelope
    connect?: GroupMembershipWhereUniqueInput | GroupMembershipWhereUniqueInput[]
  }

  export type GroupMembershipUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<GroupMembershipCreateWithoutGroupInput, GroupMembershipUncheckedCreateWithoutGroupInput> | GroupMembershipCreateWithoutGroupInput[] | GroupMembershipUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupMembershipCreateOrConnectWithoutGroupInput | GroupMembershipCreateOrConnectWithoutGroupInput[]
    createMany?: GroupMembershipCreateManyGroupInputEnvelope
    connect?: GroupMembershipWhereUniqueInput | GroupMembershipWhereUniqueInput[]
  }

  export type GroupMembershipUpdateManyWithoutGroupNestedInput = {
    create?: XOR<GroupMembershipCreateWithoutGroupInput, GroupMembershipUncheckedCreateWithoutGroupInput> | GroupMembershipCreateWithoutGroupInput[] | GroupMembershipUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupMembershipCreateOrConnectWithoutGroupInput | GroupMembershipCreateOrConnectWithoutGroupInput[]
    upsert?: GroupMembershipUpsertWithWhereUniqueWithoutGroupInput | GroupMembershipUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: GroupMembershipCreateManyGroupInputEnvelope
    set?: GroupMembershipWhereUniqueInput | GroupMembershipWhereUniqueInput[]
    disconnect?: GroupMembershipWhereUniqueInput | GroupMembershipWhereUniqueInput[]
    delete?: GroupMembershipWhereUniqueInput | GroupMembershipWhereUniqueInput[]
    connect?: GroupMembershipWhereUniqueInput | GroupMembershipWhereUniqueInput[]
    update?: GroupMembershipUpdateWithWhereUniqueWithoutGroupInput | GroupMembershipUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: GroupMembershipUpdateManyWithWhereWithoutGroupInput | GroupMembershipUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: GroupMembershipScalarWhereInput | GroupMembershipScalarWhereInput[]
  }

  export type GroupMembershipUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<GroupMembershipCreateWithoutGroupInput, GroupMembershipUncheckedCreateWithoutGroupInput> | GroupMembershipCreateWithoutGroupInput[] | GroupMembershipUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupMembershipCreateOrConnectWithoutGroupInput | GroupMembershipCreateOrConnectWithoutGroupInput[]
    upsert?: GroupMembershipUpsertWithWhereUniqueWithoutGroupInput | GroupMembershipUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: GroupMembershipCreateManyGroupInputEnvelope
    set?: GroupMembershipWhereUniqueInput | GroupMembershipWhereUniqueInput[]
    disconnect?: GroupMembershipWhereUniqueInput | GroupMembershipWhereUniqueInput[]
    delete?: GroupMembershipWhereUniqueInput | GroupMembershipWhereUniqueInput[]
    connect?: GroupMembershipWhereUniqueInput | GroupMembershipWhereUniqueInput[]
    update?: GroupMembershipUpdateWithWhereUniqueWithoutGroupInput | GroupMembershipUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: GroupMembershipUpdateManyWithWhereWithoutGroupInput | GroupMembershipUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: GroupMembershipScalarWhereInput | GroupMembershipScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCollaborativeGroupsInput = {
    create?: XOR<UserCreateWithoutCollaborativeGroupsInput, UserUncheckedCreateWithoutCollaborativeGroupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCollaborativeGroupsInput
    connect?: UserWhereUniqueInput
  }

  export type WellnessGroupCreateNestedOneWithoutMembersInput = {
    create?: XOR<WellnessGroupCreateWithoutMembersInput, WellnessGroupUncheckedCreateWithoutMembersInput>
    connectOrCreate?: WellnessGroupCreateOrConnectWithoutMembersInput
    connect?: WellnessGroupWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCollaborativeGroupsNestedInput = {
    create?: XOR<UserCreateWithoutCollaborativeGroupsInput, UserUncheckedCreateWithoutCollaborativeGroupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCollaborativeGroupsInput
    upsert?: UserUpsertWithoutCollaborativeGroupsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCollaborativeGroupsInput, UserUpdateWithoutCollaborativeGroupsInput>, UserUncheckedUpdateWithoutCollaborativeGroupsInput>
  }

  export type WellnessGroupUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<WellnessGroupCreateWithoutMembersInput, WellnessGroupUncheckedCreateWithoutMembersInput>
    connectOrCreate?: WellnessGroupCreateOrConnectWithoutMembersInput
    upsert?: WellnessGroupUpsertWithoutMembersInput
    connect?: WellnessGroupWhereUniqueInput
    update?: XOR<XOR<WellnessGroupUpdateToOneWithWhereWithoutMembersInput, WellnessGroupUpdateWithoutMembersInput>, WellnessGroupUncheckedUpdateWithoutMembersInput>
  }

  export type UserCreateNestedOneWithoutWorkplaceIntegrationsInput = {
    create?: XOR<UserCreateWithoutWorkplaceIntegrationsInput, UserUncheckedCreateWithoutWorkplaceIntegrationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkplaceIntegrationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutWorkplaceIntegrationsNestedInput = {
    create?: XOR<UserCreateWithoutWorkplaceIntegrationsInput, UserUncheckedCreateWithoutWorkplaceIntegrationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkplaceIntegrationsInput
    upsert?: UserUpsertWithoutWorkplaceIntegrationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWorkplaceIntegrationsInput, UserUpdateWithoutWorkplaceIntegrationsInput>, UserUncheckedUpdateWithoutWorkplaceIntegrationsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    idToken?: string | null
    password?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    idToken?: string | null
    password?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type JournalEntryCreateWithoutUserInput = {
    id?: string
    content: string
    date: Date | string
    mood?: string | null
    stressLevel?: number | null
    emotionScores?: NullableJsonNullValueInput | InputJsonValue
    topics?: NullableJsonNullValueInput | InputJsonValue
    sentiment?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JournalEntryUncheckedCreateWithoutUserInput = {
    id?: string
    content: string
    date: Date | string
    mood?: string | null
    stressLevel?: number | null
    emotionScores?: NullableJsonNullValueInput | InputJsonValue
    topics?: NullableJsonNullValueInput | InputJsonValue
    sentiment?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JournalEntryCreateOrConnectWithoutUserInput = {
    where: JournalEntryWhereUniqueInput
    create: XOR<JournalEntryCreateWithoutUserInput, JournalEntryUncheckedCreateWithoutUserInput>
  }

  export type JournalEntryCreateManyUserInputEnvelope = {
    data: JournalEntryCreateManyUserInput | JournalEntryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type HabitCreateWithoutUserInput = {
    id?: string
    title: string
    isCompleted?: boolean
    date: Date | string
    aiSuggested?: boolean
    adaptiveReminder?: NullableJsonNullValueInput | InputJsonValue
    difficultyLevel?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HabitUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    isCompleted?: boolean
    date: Date | string
    aiSuggested?: boolean
    adaptiveReminder?: NullableJsonNullValueInput | InputJsonValue
    difficultyLevel?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HabitCreateOrConnectWithoutUserInput = {
    where: HabitWhereUniqueInput
    create: XOR<HabitCreateWithoutUserInput, HabitUncheckedCreateWithoutUserInput>
  }

  export type HabitCreateManyUserInputEnvelope = {
    data: HabitCreateManyUserInput | HabitCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BookingCreateWithoutUserInput = {
    id?: string
    aiSuggested?: boolean
    predictedEffectiveness?: number | null
    createdAt?: Date | string
    class: ClassCreateNestedOneWithoutBookingsInput
  }

  export type BookingUncheckedCreateWithoutUserInput = {
    id?: string
    classId: string
    aiSuggested?: boolean
    predictedEffectiveness?: number | null
    createdAt?: Date | string
  }

  export type BookingCreateOrConnectWithoutUserInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput>
  }

  export type BookingCreateManyUserInputEnvelope = {
    data: BookingCreateManyUserInput | BookingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BiometricDataCreateWithoutUserInput = {
    id?: string
    heartRate?: number | null
    heartRateVariability?: number | null
    stressLevel?: number | null
    sleepQuality?: number | null
    sleepDuration?: number | null
    steps?: number | null
    calories?: number | null
    respiratoryRate?: number | null
    skinTemperature?: number | null
    bloodPressureSystolic?: number | null
    bloodPressureDiastolic?: number | null
    oxygenSaturation?: number | null
    wellnessScore?: number | null
    energyLevel?: number | null
    recoveryScore?: number | null
    deviceType?: string | null
    deviceId?: string | null
    accuracy?: number | null
    timestamp?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BiometricDataUncheckedCreateWithoutUserInput = {
    id?: string
    heartRate?: number | null
    heartRateVariability?: number | null
    stressLevel?: number | null
    sleepQuality?: number | null
    sleepDuration?: number | null
    steps?: number | null
    calories?: number | null
    respiratoryRate?: number | null
    skinTemperature?: number | null
    bloodPressureSystolic?: number | null
    bloodPressureDiastolic?: number | null
    oxygenSaturation?: number | null
    wellnessScore?: number | null
    energyLevel?: number | null
    recoveryScore?: number | null
    deviceType?: string | null
    deviceId?: string | null
    accuracy?: number | null
    timestamp?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BiometricDataCreateOrConnectWithoutUserInput = {
    where: BiometricDataWhereUniqueInput
    create: XOR<BiometricDataCreateWithoutUserInput, BiometricDataUncheckedCreateWithoutUserInput>
  }

  export type BiometricDataCreateManyUserInputEnvelope = {
    data: BiometricDataCreateManyUserInput | BiometricDataCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MoodEntryCreateWithoutUserInput = {
    id?: string
    mood: string
    confidence: number
    source: string
    emotions?: NullableJsonNullValueInput | InputJsonValue
    valence?: number | null
    arousal?: number | null
    location?: string | null
    weather?: string | null
    timeOfDay?: string | null
    activity?: string | null
    voiceFeatures?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MoodEntryUncheckedCreateWithoutUserInput = {
    id?: string
    mood: string
    confidence: number
    source: string
    emotions?: NullableJsonNullValueInput | InputJsonValue
    valence?: number | null
    arousal?: number | null
    location?: string | null
    weather?: string | null
    timeOfDay?: string | null
    activity?: string | null
    voiceFeatures?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MoodEntryCreateOrConnectWithoutUserInput = {
    where: MoodEntryWhereUniqueInput
    create: XOR<MoodEntryCreateWithoutUserInput, MoodEntryUncheckedCreateWithoutUserInput>
  }

  export type MoodEntryCreateManyUserInputEnvelope = {
    data: MoodEntryCreateManyUserInput | MoodEntryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type StressPredictionCreateWithoutUserInput = {
    id?: string
    predictedStressLevel: number
    confidence: number
    predictedAt: Date | string
    modelVersion?: string | null
    triggers?: NullableJsonNullValueInput | InputJsonValue
    riskFactors?: NullableJsonNullValueInput | InputJsonValue
    recommendedInterventions?: NullableJsonNullValueInput | InputJsonValue
    preventionStrategies?: NullableJsonNullValueInput | InputJsonValue
    actualStressLevel?: number | null
    wasAccurate?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StressPredictionUncheckedCreateWithoutUserInput = {
    id?: string
    predictedStressLevel: number
    confidence: number
    predictedAt: Date | string
    modelVersion?: string | null
    triggers?: NullableJsonNullValueInput | InputJsonValue
    riskFactors?: NullableJsonNullValueInput | InputJsonValue
    recommendedInterventions?: NullableJsonNullValueInput | InputJsonValue
    preventionStrategies?: NullableJsonNullValueInput | InputJsonValue
    actualStressLevel?: number | null
    wasAccurate?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StressPredictionCreateOrConnectWithoutUserInput = {
    where: StressPredictionWhereUniqueInput
    create: XOR<StressPredictionCreateWithoutUserInput, StressPredictionUncheckedCreateWithoutUserInput>
  }

  export type StressPredictionCreateManyUserInputEnvelope = {
    data: StressPredictionCreateManyUserInput | StressPredictionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ChallengeParticipantCreateWithoutUserInput = {
    id?: string
    progress: JsonNullValueInput | InputJsonValue
    completed?: boolean
    currentStreak?: number
    bestStreak?: number
    rank?: number | null
    joinedAt?: Date | string
    completedAt?: Date | string | null
    challenge: WellnessChallengeCreateNestedOneWithoutParticipantsInput
  }

  export type ChallengeParticipantUncheckedCreateWithoutUserInput = {
    id?: string
    challengeId: string
    progress: JsonNullValueInput | InputJsonValue
    completed?: boolean
    currentStreak?: number
    bestStreak?: number
    rank?: number | null
    joinedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type ChallengeParticipantCreateOrConnectWithoutUserInput = {
    where: ChallengeParticipantWhereUniqueInput
    create: XOR<ChallengeParticipantCreateWithoutUserInput, ChallengeParticipantUncheckedCreateWithoutUserInput>
  }

  export type ChallengeParticipantCreateManyUserInputEnvelope = {
    data: ChallengeParticipantCreateManyUserInput | ChallengeParticipantCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AIRecommendationCreateWithoutUserInput = {
    id?: string
    type: string
    title: string
    description: string
    priority: number
    reasoning: string
    actionUrl?: string | null
    duration?: number | null
    intensity?: string | null
    triggeredBy?: NullableJsonNullValueInput | InputJsonValue
    biometricState?: NullableJsonNullValueInput | InputJsonValue
    effectivenessScore?: number | null
    isRead?: boolean
    isCompleted?: boolean
    createdAt?: Date | string
    expiresAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type AIRecommendationUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    title: string
    description: string
    priority: number
    reasoning: string
    actionUrl?: string | null
    duration?: number | null
    intensity?: string | null
    triggeredBy?: NullableJsonNullValueInput | InputJsonValue
    biometricState?: NullableJsonNullValueInput | InputJsonValue
    effectivenessScore?: number | null
    isRead?: boolean
    isCompleted?: boolean
    createdAt?: Date | string
    expiresAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type AIRecommendationCreateOrConnectWithoutUserInput = {
    where: AIRecommendationWhereUniqueInput
    create: XOR<AIRecommendationCreateWithoutUserInput, AIRecommendationUncheckedCreateWithoutUserInput>
  }

  export type AIRecommendationCreateManyUserInputEnvelope = {
    data: AIRecommendationCreateManyUserInput | AIRecommendationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DeviceConnectionCreateWithoutUserInput = {
    id?: string
    deviceType: string
    deviceId: string
    deviceName?: string | null
    isConnected?: boolean
    lastSync?: Date | string | null
    syncInterval?: number | null
    reliability?: number | null
    batteryLevel?: number | null
    signalStrength?: number | null
    permissions: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeviceConnectionUncheckedCreateWithoutUserInput = {
    id?: string
    deviceType: string
    deviceId: string
    deviceName?: string | null
    isConnected?: boolean
    lastSync?: Date | string | null
    syncInterval?: number | null
    reliability?: number | null
    batteryLevel?: number | null
    signalStrength?: number | null
    permissions: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeviceConnectionCreateOrConnectWithoutUserInput = {
    where: DeviceConnectionWhereUniqueInput
    create: XOR<DeviceConnectionCreateWithoutUserInput, DeviceConnectionUncheckedCreateWithoutUserInput>
  }

  export type DeviceConnectionCreateManyUserInputEnvelope = {
    data: DeviceConnectionCreateManyUserInput | DeviceConnectionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WellnessSessionCreateWithoutUserInput = {
    id?: string
    sessionType: string
    title: string
    duration: number
    startingStress?: number | null
    endingStress?: number | null
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    avgHeartRate?: number | null
    stressReduction?: number | null
    userRating?: number | null
    completionRate?: number | null
    startedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type WellnessSessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionType: string
    title: string
    duration: number
    startingStress?: number | null
    endingStress?: number | null
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    avgHeartRate?: number | null
    stressReduction?: number | null
    userRating?: number | null
    completionRate?: number | null
    startedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type WellnessSessionCreateOrConnectWithoutUserInput = {
    where: WellnessSessionWhereUniqueInput
    create: XOR<WellnessSessionCreateWithoutUserInput, WellnessSessionUncheckedCreateWithoutUserInput>
  }

  export type WellnessSessionCreateManyUserInputEnvelope = {
    data: WellnessSessionCreateManyUserInput | WellnessSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EnvironmentalDataCreateWithoutUserInput = {
    id?: string
    location?: string | null
    timezone?: string | null
    temperature?: number | null
    humidity?: number | null
    pressure?: number | null
    weather?: string | null
    airQuality?: number | null
    pollutants?: NullableJsonNullValueInput | InputJsonValue
    lightLevel?: number | null
    uvIndex?: number | null
    noiseLevel?: number | null
    timestamp?: Date | string
  }

  export type EnvironmentalDataUncheckedCreateWithoutUserInput = {
    id?: string
    location?: string | null
    timezone?: string | null
    temperature?: number | null
    humidity?: number | null
    pressure?: number | null
    weather?: string | null
    airQuality?: number | null
    pollutants?: NullableJsonNullValueInput | InputJsonValue
    lightLevel?: number | null
    uvIndex?: number | null
    noiseLevel?: number | null
    timestamp?: Date | string
  }

  export type EnvironmentalDataCreateOrConnectWithoutUserInput = {
    where: EnvironmentalDataWhereUniqueInput
    create: XOR<EnvironmentalDataCreateWithoutUserInput, EnvironmentalDataUncheckedCreateWithoutUserInput>
  }

  export type EnvironmentalDataCreateManyUserInputEnvelope = {
    data: EnvironmentalDataCreateManyUserInput | EnvironmentalDataCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type GroupMembershipCreateWithoutUserInput = {
    id?: string
    role?: string
    shareProgress?: boolean
    shareGoals?: boolean
    joinedAt?: Date | string
    group: WellnessGroupCreateNestedOneWithoutMembersInput
  }

  export type GroupMembershipUncheckedCreateWithoutUserInput = {
    id?: string
    groupId: string
    role?: string
    shareProgress?: boolean
    shareGoals?: boolean
    joinedAt?: Date | string
  }

  export type GroupMembershipCreateOrConnectWithoutUserInput = {
    where: GroupMembershipWhereUniqueInput
    create: XOR<GroupMembershipCreateWithoutUserInput, GroupMembershipUncheckedCreateWithoutUserInput>
  }

  export type GroupMembershipCreateManyUserInputEnvelope = {
    data: GroupMembershipCreateManyUserInput | GroupMembershipCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WorkplaceIntegrationCreateWithoutUserInput = {
    id?: string
    platform: string
    enabled?: boolean
    frequency?: string
    canSuggestBreaks?: boolean
    canAccessCalendar?: boolean
    canSendReminders?: boolean
    workHours?: NullableJsonNullValueInput | InputJsonValue
    breakPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkplaceIntegrationUncheckedCreateWithoutUserInput = {
    id?: string
    platform: string
    enabled?: boolean
    frequency?: string
    canSuggestBreaks?: boolean
    canAccessCalendar?: boolean
    canSendReminders?: boolean
    workHours?: NullableJsonNullValueInput | InputJsonValue
    breakPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkplaceIntegrationCreateOrConnectWithoutUserInput = {
    where: WorkplaceIntegrationWhereUniqueInput
    create: XOR<WorkplaceIntegrationCreateWithoutUserInput, WorkplaceIntegrationUncheckedCreateWithoutUserInput>
  }

  export type WorkplaceIntegrationCreateManyUserInputEnvelope = {
    data: WorkplaceIntegrationCreateManyUserInput | WorkplaceIntegrationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type AccountUpsertWithoutUserInput = {
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutUserInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalEntryUpsertWithWhereUniqueWithoutUserInput = {
    where: JournalEntryWhereUniqueInput
    update: XOR<JournalEntryUpdateWithoutUserInput, JournalEntryUncheckedUpdateWithoutUserInput>
    create: XOR<JournalEntryCreateWithoutUserInput, JournalEntryUncheckedCreateWithoutUserInput>
  }

  export type JournalEntryUpdateWithWhereUniqueWithoutUserInput = {
    where: JournalEntryWhereUniqueInput
    data: XOR<JournalEntryUpdateWithoutUserInput, JournalEntryUncheckedUpdateWithoutUserInput>
  }

  export type JournalEntryUpdateManyWithWhereWithoutUserInput = {
    where: JournalEntryScalarWhereInput
    data: XOR<JournalEntryUpdateManyMutationInput, JournalEntryUncheckedUpdateManyWithoutUserInput>
  }

  export type JournalEntryScalarWhereInput = {
    AND?: JournalEntryScalarWhereInput | JournalEntryScalarWhereInput[]
    OR?: JournalEntryScalarWhereInput[]
    NOT?: JournalEntryScalarWhereInput | JournalEntryScalarWhereInput[]
    id?: StringFilter<"JournalEntry"> | string
    userId?: StringFilter<"JournalEntry"> | string
    content?: StringFilter<"JournalEntry"> | string
    date?: DateTimeFilter<"JournalEntry"> | Date | string
    mood?: StringNullableFilter<"JournalEntry"> | string | null
    stressLevel?: IntNullableFilter<"JournalEntry"> | number | null
    emotionScores?: JsonNullableFilter<"JournalEntry">
    topics?: JsonNullableFilter<"JournalEntry">
    sentiment?: FloatNullableFilter<"JournalEntry"> | number | null
    createdAt?: DateTimeFilter<"JournalEntry"> | Date | string
    updatedAt?: DateTimeFilter<"JournalEntry"> | Date | string
  }

  export type HabitUpsertWithWhereUniqueWithoutUserInput = {
    where: HabitWhereUniqueInput
    update: XOR<HabitUpdateWithoutUserInput, HabitUncheckedUpdateWithoutUserInput>
    create: XOR<HabitCreateWithoutUserInput, HabitUncheckedCreateWithoutUserInput>
  }

  export type HabitUpdateWithWhereUniqueWithoutUserInput = {
    where: HabitWhereUniqueInput
    data: XOR<HabitUpdateWithoutUserInput, HabitUncheckedUpdateWithoutUserInput>
  }

  export type HabitUpdateManyWithWhereWithoutUserInput = {
    where: HabitScalarWhereInput
    data: XOR<HabitUpdateManyMutationInput, HabitUncheckedUpdateManyWithoutUserInput>
  }

  export type HabitScalarWhereInput = {
    AND?: HabitScalarWhereInput | HabitScalarWhereInput[]
    OR?: HabitScalarWhereInput[]
    NOT?: HabitScalarWhereInput | HabitScalarWhereInput[]
    id?: StringFilter<"Habit"> | string
    userId?: StringFilter<"Habit"> | string
    title?: StringFilter<"Habit"> | string
    isCompleted?: BoolFilter<"Habit"> | boolean
    date?: DateTimeFilter<"Habit"> | Date | string
    aiSuggested?: BoolFilter<"Habit"> | boolean
    adaptiveReminder?: JsonNullableFilter<"Habit">
    difficultyLevel?: IntNullableFilter<"Habit"> | number | null
    createdAt?: DateTimeFilter<"Habit"> | Date | string
    updatedAt?: DateTimeFilter<"Habit"> | Date | string
  }

  export type BookingUpsertWithWhereUniqueWithoutUserInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutUserInput, BookingUncheckedUpdateWithoutUserInput>
    create: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutUserInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutUserInput, BookingUncheckedUpdateWithoutUserInput>
  }

  export type BookingUpdateManyWithWhereWithoutUserInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutUserInput>
  }

  export type BookingScalarWhereInput = {
    AND?: BookingScalarWhereInput | BookingScalarWhereInput[]
    OR?: BookingScalarWhereInput[]
    NOT?: BookingScalarWhereInput | BookingScalarWhereInput[]
    id?: StringFilter<"Booking"> | string
    userId?: StringFilter<"Booking"> | string
    classId?: StringFilter<"Booking"> | string
    aiSuggested?: BoolFilter<"Booking"> | boolean
    predictedEffectiveness?: FloatNullableFilter<"Booking"> | number | null
    createdAt?: DateTimeFilter<"Booking"> | Date | string
  }

  export type BiometricDataUpsertWithWhereUniqueWithoutUserInput = {
    where: BiometricDataWhereUniqueInput
    update: XOR<BiometricDataUpdateWithoutUserInput, BiometricDataUncheckedUpdateWithoutUserInput>
    create: XOR<BiometricDataCreateWithoutUserInput, BiometricDataUncheckedCreateWithoutUserInput>
  }

  export type BiometricDataUpdateWithWhereUniqueWithoutUserInput = {
    where: BiometricDataWhereUniqueInput
    data: XOR<BiometricDataUpdateWithoutUserInput, BiometricDataUncheckedUpdateWithoutUserInput>
  }

  export type BiometricDataUpdateManyWithWhereWithoutUserInput = {
    where: BiometricDataScalarWhereInput
    data: XOR<BiometricDataUpdateManyMutationInput, BiometricDataUncheckedUpdateManyWithoutUserInput>
  }

  export type BiometricDataScalarWhereInput = {
    AND?: BiometricDataScalarWhereInput | BiometricDataScalarWhereInput[]
    OR?: BiometricDataScalarWhereInput[]
    NOT?: BiometricDataScalarWhereInput | BiometricDataScalarWhereInput[]
    id?: StringFilter<"BiometricData"> | string
    userId?: StringFilter<"BiometricData"> | string
    heartRate?: IntNullableFilter<"BiometricData"> | number | null
    heartRateVariability?: FloatNullableFilter<"BiometricData"> | number | null
    stressLevel?: IntNullableFilter<"BiometricData"> | number | null
    sleepQuality?: IntNullableFilter<"BiometricData"> | number | null
    sleepDuration?: FloatNullableFilter<"BiometricData"> | number | null
    steps?: IntNullableFilter<"BiometricData"> | number | null
    calories?: IntNullableFilter<"BiometricData"> | number | null
    respiratoryRate?: IntNullableFilter<"BiometricData"> | number | null
    skinTemperature?: FloatNullableFilter<"BiometricData"> | number | null
    bloodPressureSystolic?: IntNullableFilter<"BiometricData"> | number | null
    bloodPressureDiastolic?: IntNullableFilter<"BiometricData"> | number | null
    oxygenSaturation?: FloatNullableFilter<"BiometricData"> | number | null
    wellnessScore?: FloatNullableFilter<"BiometricData"> | number | null
    energyLevel?: IntNullableFilter<"BiometricData"> | number | null
    recoveryScore?: FloatNullableFilter<"BiometricData"> | number | null
    deviceType?: StringNullableFilter<"BiometricData"> | string | null
    deviceId?: StringNullableFilter<"BiometricData"> | string | null
    accuracy?: FloatNullableFilter<"BiometricData"> | number | null
    timestamp?: DateTimeFilter<"BiometricData"> | Date | string
    createdAt?: DateTimeFilter<"BiometricData"> | Date | string
    updatedAt?: DateTimeFilter<"BiometricData"> | Date | string
  }

  export type MoodEntryUpsertWithWhereUniqueWithoutUserInput = {
    where: MoodEntryWhereUniqueInput
    update: XOR<MoodEntryUpdateWithoutUserInput, MoodEntryUncheckedUpdateWithoutUserInput>
    create: XOR<MoodEntryCreateWithoutUserInput, MoodEntryUncheckedCreateWithoutUserInput>
  }

  export type MoodEntryUpdateWithWhereUniqueWithoutUserInput = {
    where: MoodEntryWhereUniqueInput
    data: XOR<MoodEntryUpdateWithoutUserInput, MoodEntryUncheckedUpdateWithoutUserInput>
  }

  export type MoodEntryUpdateManyWithWhereWithoutUserInput = {
    where: MoodEntryScalarWhereInput
    data: XOR<MoodEntryUpdateManyMutationInput, MoodEntryUncheckedUpdateManyWithoutUserInput>
  }

  export type MoodEntryScalarWhereInput = {
    AND?: MoodEntryScalarWhereInput | MoodEntryScalarWhereInput[]
    OR?: MoodEntryScalarWhereInput[]
    NOT?: MoodEntryScalarWhereInput | MoodEntryScalarWhereInput[]
    id?: StringFilter<"MoodEntry"> | string
    userId?: StringFilter<"MoodEntry"> | string
    mood?: StringFilter<"MoodEntry"> | string
    confidence?: FloatFilter<"MoodEntry"> | number
    source?: StringFilter<"MoodEntry"> | string
    emotions?: JsonNullableFilter<"MoodEntry">
    valence?: FloatNullableFilter<"MoodEntry"> | number | null
    arousal?: FloatNullableFilter<"MoodEntry"> | number | null
    location?: StringNullableFilter<"MoodEntry"> | string | null
    weather?: StringNullableFilter<"MoodEntry"> | string | null
    timeOfDay?: StringNullableFilter<"MoodEntry"> | string | null
    activity?: StringNullableFilter<"MoodEntry"> | string | null
    voiceFeatures?: JsonNullableFilter<"MoodEntry">
    timestamp?: DateTimeFilter<"MoodEntry"> | Date | string
    createdAt?: DateTimeFilter<"MoodEntry"> | Date | string
    updatedAt?: DateTimeFilter<"MoodEntry"> | Date | string
  }

  export type StressPredictionUpsertWithWhereUniqueWithoutUserInput = {
    where: StressPredictionWhereUniqueInput
    update: XOR<StressPredictionUpdateWithoutUserInput, StressPredictionUncheckedUpdateWithoutUserInput>
    create: XOR<StressPredictionCreateWithoutUserInput, StressPredictionUncheckedCreateWithoutUserInput>
  }

  export type StressPredictionUpdateWithWhereUniqueWithoutUserInput = {
    where: StressPredictionWhereUniqueInput
    data: XOR<StressPredictionUpdateWithoutUserInput, StressPredictionUncheckedUpdateWithoutUserInput>
  }

  export type StressPredictionUpdateManyWithWhereWithoutUserInput = {
    where: StressPredictionScalarWhereInput
    data: XOR<StressPredictionUpdateManyMutationInput, StressPredictionUncheckedUpdateManyWithoutUserInput>
  }

  export type StressPredictionScalarWhereInput = {
    AND?: StressPredictionScalarWhereInput | StressPredictionScalarWhereInput[]
    OR?: StressPredictionScalarWhereInput[]
    NOT?: StressPredictionScalarWhereInput | StressPredictionScalarWhereInput[]
    id?: StringFilter<"StressPrediction"> | string
    userId?: StringFilter<"StressPrediction"> | string
    predictedStressLevel?: IntFilter<"StressPrediction"> | number
    confidence?: FloatFilter<"StressPrediction"> | number
    predictedAt?: DateTimeFilter<"StressPrediction"> | Date | string
    modelVersion?: StringNullableFilter<"StressPrediction"> | string | null
    triggers?: JsonNullableFilter<"StressPrediction">
    riskFactors?: JsonNullableFilter<"StressPrediction">
    recommendedInterventions?: JsonNullableFilter<"StressPrediction">
    preventionStrategies?: JsonNullableFilter<"StressPrediction">
    actualStressLevel?: IntNullableFilter<"StressPrediction"> | number | null
    wasAccurate?: BoolNullableFilter<"StressPrediction"> | boolean | null
    createdAt?: DateTimeFilter<"StressPrediction"> | Date | string
    updatedAt?: DateTimeFilter<"StressPrediction"> | Date | string
  }

  export type ChallengeParticipantUpsertWithWhereUniqueWithoutUserInput = {
    where: ChallengeParticipantWhereUniqueInput
    update: XOR<ChallengeParticipantUpdateWithoutUserInput, ChallengeParticipantUncheckedUpdateWithoutUserInput>
    create: XOR<ChallengeParticipantCreateWithoutUserInput, ChallengeParticipantUncheckedCreateWithoutUserInput>
  }

  export type ChallengeParticipantUpdateWithWhereUniqueWithoutUserInput = {
    where: ChallengeParticipantWhereUniqueInput
    data: XOR<ChallengeParticipantUpdateWithoutUserInput, ChallengeParticipantUncheckedUpdateWithoutUserInput>
  }

  export type ChallengeParticipantUpdateManyWithWhereWithoutUserInput = {
    where: ChallengeParticipantScalarWhereInput
    data: XOR<ChallengeParticipantUpdateManyMutationInput, ChallengeParticipantUncheckedUpdateManyWithoutUserInput>
  }

  export type ChallengeParticipantScalarWhereInput = {
    AND?: ChallengeParticipantScalarWhereInput | ChallengeParticipantScalarWhereInput[]
    OR?: ChallengeParticipantScalarWhereInput[]
    NOT?: ChallengeParticipantScalarWhereInput | ChallengeParticipantScalarWhereInput[]
    id?: StringFilter<"ChallengeParticipant"> | string
    userId?: StringFilter<"ChallengeParticipant"> | string
    challengeId?: StringFilter<"ChallengeParticipant"> | string
    progress?: JsonFilter<"ChallengeParticipant">
    completed?: BoolFilter<"ChallengeParticipant"> | boolean
    currentStreak?: IntFilter<"ChallengeParticipant"> | number
    bestStreak?: IntFilter<"ChallengeParticipant"> | number
    rank?: IntNullableFilter<"ChallengeParticipant"> | number | null
    joinedAt?: DateTimeFilter<"ChallengeParticipant"> | Date | string
    completedAt?: DateTimeNullableFilter<"ChallengeParticipant"> | Date | string | null
  }

  export type AIRecommendationUpsertWithWhereUniqueWithoutUserInput = {
    where: AIRecommendationWhereUniqueInput
    update: XOR<AIRecommendationUpdateWithoutUserInput, AIRecommendationUncheckedUpdateWithoutUserInput>
    create: XOR<AIRecommendationCreateWithoutUserInput, AIRecommendationUncheckedCreateWithoutUserInput>
  }

  export type AIRecommendationUpdateWithWhereUniqueWithoutUserInput = {
    where: AIRecommendationWhereUniqueInput
    data: XOR<AIRecommendationUpdateWithoutUserInput, AIRecommendationUncheckedUpdateWithoutUserInput>
  }

  export type AIRecommendationUpdateManyWithWhereWithoutUserInput = {
    where: AIRecommendationScalarWhereInput
    data: XOR<AIRecommendationUpdateManyMutationInput, AIRecommendationUncheckedUpdateManyWithoutUserInput>
  }

  export type AIRecommendationScalarWhereInput = {
    AND?: AIRecommendationScalarWhereInput | AIRecommendationScalarWhereInput[]
    OR?: AIRecommendationScalarWhereInput[]
    NOT?: AIRecommendationScalarWhereInput | AIRecommendationScalarWhereInput[]
    id?: StringFilter<"AIRecommendation"> | string
    userId?: StringFilter<"AIRecommendation"> | string
    type?: StringFilter<"AIRecommendation"> | string
    title?: StringFilter<"AIRecommendation"> | string
    description?: StringFilter<"AIRecommendation"> | string
    priority?: IntFilter<"AIRecommendation"> | number
    reasoning?: StringFilter<"AIRecommendation"> | string
    actionUrl?: StringNullableFilter<"AIRecommendation"> | string | null
    duration?: IntNullableFilter<"AIRecommendation"> | number | null
    intensity?: StringNullableFilter<"AIRecommendation"> | string | null
    triggeredBy?: JsonNullableFilter<"AIRecommendation">
    biometricState?: JsonNullableFilter<"AIRecommendation">
    effectivenessScore?: FloatNullableFilter<"AIRecommendation"> | number | null
    isRead?: BoolFilter<"AIRecommendation"> | boolean
    isCompleted?: BoolFilter<"AIRecommendation"> | boolean
    createdAt?: DateTimeFilter<"AIRecommendation"> | Date | string
    expiresAt?: DateTimeNullableFilter<"AIRecommendation"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"AIRecommendation"> | Date | string | null
  }

  export type DeviceConnectionUpsertWithWhereUniqueWithoutUserInput = {
    where: DeviceConnectionWhereUniqueInput
    update: XOR<DeviceConnectionUpdateWithoutUserInput, DeviceConnectionUncheckedUpdateWithoutUserInput>
    create: XOR<DeviceConnectionCreateWithoutUserInput, DeviceConnectionUncheckedCreateWithoutUserInput>
  }

  export type DeviceConnectionUpdateWithWhereUniqueWithoutUserInput = {
    where: DeviceConnectionWhereUniqueInput
    data: XOR<DeviceConnectionUpdateWithoutUserInput, DeviceConnectionUncheckedUpdateWithoutUserInput>
  }

  export type DeviceConnectionUpdateManyWithWhereWithoutUserInput = {
    where: DeviceConnectionScalarWhereInput
    data: XOR<DeviceConnectionUpdateManyMutationInput, DeviceConnectionUncheckedUpdateManyWithoutUserInput>
  }

  export type DeviceConnectionScalarWhereInput = {
    AND?: DeviceConnectionScalarWhereInput | DeviceConnectionScalarWhereInput[]
    OR?: DeviceConnectionScalarWhereInput[]
    NOT?: DeviceConnectionScalarWhereInput | DeviceConnectionScalarWhereInput[]
    id?: StringFilter<"DeviceConnection"> | string
    userId?: StringFilter<"DeviceConnection"> | string
    deviceType?: StringFilter<"DeviceConnection"> | string
    deviceId?: StringFilter<"DeviceConnection"> | string
    deviceName?: StringNullableFilter<"DeviceConnection"> | string | null
    isConnected?: BoolFilter<"DeviceConnection"> | boolean
    lastSync?: DateTimeNullableFilter<"DeviceConnection"> | Date | string | null
    syncInterval?: IntNullableFilter<"DeviceConnection"> | number | null
    reliability?: FloatNullableFilter<"DeviceConnection"> | number | null
    batteryLevel?: IntNullableFilter<"DeviceConnection"> | number | null
    signalStrength?: FloatNullableFilter<"DeviceConnection"> | number | null
    permissions?: JsonFilter<"DeviceConnection">
    createdAt?: DateTimeFilter<"DeviceConnection"> | Date | string
    updatedAt?: DateTimeFilter<"DeviceConnection"> | Date | string
  }

  export type WellnessSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: WellnessSessionWhereUniqueInput
    update: XOR<WellnessSessionUpdateWithoutUserInput, WellnessSessionUncheckedUpdateWithoutUserInput>
    create: XOR<WellnessSessionCreateWithoutUserInput, WellnessSessionUncheckedCreateWithoutUserInput>
  }

  export type WellnessSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: WellnessSessionWhereUniqueInput
    data: XOR<WellnessSessionUpdateWithoutUserInput, WellnessSessionUncheckedUpdateWithoutUserInput>
  }

  export type WellnessSessionUpdateManyWithWhereWithoutUserInput = {
    where: WellnessSessionScalarWhereInput
    data: XOR<WellnessSessionUpdateManyMutationInput, WellnessSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type WellnessSessionScalarWhereInput = {
    AND?: WellnessSessionScalarWhereInput | WellnessSessionScalarWhereInput[]
    OR?: WellnessSessionScalarWhereInput[]
    NOT?: WellnessSessionScalarWhereInput | WellnessSessionScalarWhereInput[]
    id?: StringFilter<"WellnessSession"> | string
    userId?: StringFilter<"WellnessSession"> | string
    sessionType?: StringFilter<"WellnessSession"> | string
    title?: StringFilter<"WellnessSession"> | string
    duration?: IntFilter<"WellnessSession"> | number
    startingStress?: IntNullableFilter<"WellnessSession"> | number | null
    endingStress?: IntNullableFilter<"WellnessSession"> | number | null
    adaptations?: JsonNullableFilter<"WellnessSession">
    avgHeartRate?: IntNullableFilter<"WellnessSession"> | number | null
    stressReduction?: FloatNullableFilter<"WellnessSession"> | number | null
    userRating?: IntNullableFilter<"WellnessSession"> | number | null
    completionRate?: FloatNullableFilter<"WellnessSession"> | number | null
    startedAt?: DateTimeFilter<"WellnessSession"> | Date | string
    completedAt?: DateTimeNullableFilter<"WellnessSession"> | Date | string | null
  }

  export type EnvironmentalDataUpsertWithWhereUniqueWithoutUserInput = {
    where: EnvironmentalDataWhereUniqueInput
    update: XOR<EnvironmentalDataUpdateWithoutUserInput, EnvironmentalDataUncheckedUpdateWithoutUserInput>
    create: XOR<EnvironmentalDataCreateWithoutUserInput, EnvironmentalDataUncheckedCreateWithoutUserInput>
  }

  export type EnvironmentalDataUpdateWithWhereUniqueWithoutUserInput = {
    where: EnvironmentalDataWhereUniqueInput
    data: XOR<EnvironmentalDataUpdateWithoutUserInput, EnvironmentalDataUncheckedUpdateWithoutUserInput>
  }

  export type EnvironmentalDataUpdateManyWithWhereWithoutUserInput = {
    where: EnvironmentalDataScalarWhereInput
    data: XOR<EnvironmentalDataUpdateManyMutationInput, EnvironmentalDataUncheckedUpdateManyWithoutUserInput>
  }

  export type EnvironmentalDataScalarWhereInput = {
    AND?: EnvironmentalDataScalarWhereInput | EnvironmentalDataScalarWhereInput[]
    OR?: EnvironmentalDataScalarWhereInput[]
    NOT?: EnvironmentalDataScalarWhereInput | EnvironmentalDataScalarWhereInput[]
    id?: StringFilter<"EnvironmentalData"> | string
    userId?: StringFilter<"EnvironmentalData"> | string
    location?: StringNullableFilter<"EnvironmentalData"> | string | null
    timezone?: StringNullableFilter<"EnvironmentalData"> | string | null
    temperature?: FloatNullableFilter<"EnvironmentalData"> | number | null
    humidity?: FloatNullableFilter<"EnvironmentalData"> | number | null
    pressure?: FloatNullableFilter<"EnvironmentalData"> | number | null
    weather?: StringNullableFilter<"EnvironmentalData"> | string | null
    airQuality?: IntNullableFilter<"EnvironmentalData"> | number | null
    pollutants?: JsonNullableFilter<"EnvironmentalData">
    lightLevel?: FloatNullableFilter<"EnvironmentalData"> | number | null
    uvIndex?: FloatNullableFilter<"EnvironmentalData"> | number | null
    noiseLevel?: FloatNullableFilter<"EnvironmentalData"> | number | null
    timestamp?: DateTimeFilter<"EnvironmentalData"> | Date | string
  }

  export type GroupMembershipUpsertWithWhereUniqueWithoutUserInput = {
    where: GroupMembershipWhereUniqueInput
    update: XOR<GroupMembershipUpdateWithoutUserInput, GroupMembershipUncheckedUpdateWithoutUserInput>
    create: XOR<GroupMembershipCreateWithoutUserInput, GroupMembershipUncheckedCreateWithoutUserInput>
  }

  export type GroupMembershipUpdateWithWhereUniqueWithoutUserInput = {
    where: GroupMembershipWhereUniqueInput
    data: XOR<GroupMembershipUpdateWithoutUserInput, GroupMembershipUncheckedUpdateWithoutUserInput>
  }

  export type GroupMembershipUpdateManyWithWhereWithoutUserInput = {
    where: GroupMembershipScalarWhereInput
    data: XOR<GroupMembershipUpdateManyMutationInput, GroupMembershipUncheckedUpdateManyWithoutUserInput>
  }

  export type GroupMembershipScalarWhereInput = {
    AND?: GroupMembershipScalarWhereInput | GroupMembershipScalarWhereInput[]
    OR?: GroupMembershipScalarWhereInput[]
    NOT?: GroupMembershipScalarWhereInput | GroupMembershipScalarWhereInput[]
    id?: StringFilter<"GroupMembership"> | string
    userId?: StringFilter<"GroupMembership"> | string
    groupId?: StringFilter<"GroupMembership"> | string
    role?: StringFilter<"GroupMembership"> | string
    shareProgress?: BoolFilter<"GroupMembership"> | boolean
    shareGoals?: BoolFilter<"GroupMembership"> | boolean
    joinedAt?: DateTimeFilter<"GroupMembership"> | Date | string
  }

  export type WorkplaceIntegrationUpsertWithWhereUniqueWithoutUserInput = {
    where: WorkplaceIntegrationWhereUniqueInput
    update: XOR<WorkplaceIntegrationUpdateWithoutUserInput, WorkplaceIntegrationUncheckedUpdateWithoutUserInput>
    create: XOR<WorkplaceIntegrationCreateWithoutUserInput, WorkplaceIntegrationUncheckedCreateWithoutUserInput>
  }

  export type WorkplaceIntegrationUpdateWithWhereUniqueWithoutUserInput = {
    where: WorkplaceIntegrationWhereUniqueInput
    data: XOR<WorkplaceIntegrationUpdateWithoutUserInput, WorkplaceIntegrationUncheckedUpdateWithoutUserInput>
  }

  export type WorkplaceIntegrationUpdateManyWithWhereWithoutUserInput = {
    where: WorkplaceIntegrationScalarWhereInput
    data: XOR<WorkplaceIntegrationUpdateManyMutationInput, WorkplaceIntegrationUncheckedUpdateManyWithoutUserInput>
  }

  export type WorkplaceIntegrationScalarWhereInput = {
    AND?: WorkplaceIntegrationScalarWhereInput | WorkplaceIntegrationScalarWhereInput[]
    OR?: WorkplaceIntegrationScalarWhereInput[]
    NOT?: WorkplaceIntegrationScalarWhereInput | WorkplaceIntegrationScalarWhereInput[]
    id?: StringFilter<"WorkplaceIntegration"> | string
    userId?: StringFilter<"WorkplaceIntegration"> | string
    platform?: StringFilter<"WorkplaceIntegration"> | string
    enabled?: BoolFilter<"WorkplaceIntegration"> | boolean
    frequency?: StringFilter<"WorkplaceIntegration"> | string
    canSuggestBreaks?: BoolFilter<"WorkplaceIntegration"> | boolean
    canAccessCalendar?: BoolFilter<"WorkplaceIntegration"> | boolean
    canSendReminders?: BoolFilter<"WorkplaceIntegration"> | boolean
    workHours?: JsonNullableFilter<"WorkplaceIntegration">
    breakPreferences?: JsonNullableFilter<"WorkplaceIntegration">
    createdAt?: DateTimeFilter<"WorkplaceIntegration"> | Date | string
    updatedAt?: DateTimeFilter<"WorkplaceIntegration"> | Date | string
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timezone?: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: boolean
    biometricSyncEnabled?: boolean
    baseStressLevel?: number | null
    sleepGoal?: number | null
    stepsGoal?: number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    account?: AccountCreateNestedOneWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    habits?: HabitCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    biometricData?: BiometricDataCreateNestedManyWithoutUserInput
    moodEntries?: MoodEntryCreateNestedManyWithoutUserInput
    stressPredictions?: StressPredictionCreateNestedManyWithoutUserInput
    challengeParticipants?: ChallengeParticipantCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutUserInput
    deviceConnections?: DeviceConnectionCreateNestedManyWithoutUserInput
    wellnessSessions?: WellnessSessionCreateNestedManyWithoutUserInput
    environmentalData?: EnvironmentalDataCreateNestedManyWithoutUserInput
    collaborativeGroups?: GroupMembershipCreateNestedManyWithoutUserInput
    workplaceIntegrations?: WorkplaceIntegrationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timezone?: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: boolean
    biometricSyncEnabled?: boolean
    baseStressLevel?: number | null
    sleepGoal?: number | null
    stepsGoal?: number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    account?: AccountUncheckedCreateNestedOneWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    habits?: HabitUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    biometricData?: BiometricDataUncheckedCreateNestedManyWithoutUserInput
    moodEntries?: MoodEntryUncheckedCreateNestedManyWithoutUserInput
    stressPredictions?: StressPredictionUncheckedCreateNestedManyWithoutUserInput
    challengeParticipants?: ChallengeParticipantUncheckedCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutUserInput
    deviceConnections?: DeviceConnectionUncheckedCreateNestedManyWithoutUserInput
    wellnessSessions?: WellnessSessionUncheckedCreateNestedManyWithoutUserInput
    environmentalData?: EnvironmentalDataUncheckedCreateNestedManyWithoutUserInput
    collaborativeGroups?: GroupMembershipUncheckedCreateNestedManyWithoutUserInput
    workplaceIntegrations?: WorkplaceIntegrationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: BoolFieldUpdateOperationsInput | boolean
    biometricSyncEnabled?: BoolFieldUpdateOperationsInput | boolean
    baseStressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    sleepGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    stepsGoal?: NullableIntFieldUpdateOperationsInput | number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    account?: AccountUpdateOneWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    habits?: HabitUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    biometricData?: BiometricDataUpdateManyWithoutUserNestedInput
    moodEntries?: MoodEntryUpdateManyWithoutUserNestedInput
    stressPredictions?: StressPredictionUpdateManyWithoutUserNestedInput
    challengeParticipants?: ChallengeParticipantUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUpdateManyWithoutUserNestedInput
    deviceConnections?: DeviceConnectionUpdateManyWithoutUserNestedInput
    wellnessSessions?: WellnessSessionUpdateManyWithoutUserNestedInput
    environmentalData?: EnvironmentalDataUpdateManyWithoutUserNestedInput
    collaborativeGroups?: GroupMembershipUpdateManyWithoutUserNestedInput
    workplaceIntegrations?: WorkplaceIntegrationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: BoolFieldUpdateOperationsInput | boolean
    biometricSyncEnabled?: BoolFieldUpdateOperationsInput | boolean
    baseStressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    sleepGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    stepsGoal?: NullableIntFieldUpdateOperationsInput | number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    account?: AccountUncheckedUpdateOneWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    habits?: HabitUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    biometricData?: BiometricDataUncheckedUpdateManyWithoutUserNestedInput
    moodEntries?: MoodEntryUncheckedUpdateManyWithoutUserNestedInput
    stressPredictions?: StressPredictionUncheckedUpdateManyWithoutUserNestedInput
    challengeParticipants?: ChallengeParticipantUncheckedUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutUserNestedInput
    deviceConnections?: DeviceConnectionUncheckedUpdateManyWithoutUserNestedInput
    wellnessSessions?: WellnessSessionUncheckedUpdateManyWithoutUserNestedInput
    environmentalData?: EnvironmentalDataUncheckedUpdateManyWithoutUserNestedInput
    collaborativeGroups?: GroupMembershipUncheckedUpdateManyWithoutUserNestedInput
    workplaceIntegrations?: WorkplaceIntegrationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAccountInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timezone?: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: boolean
    biometricSyncEnabled?: boolean
    baseStressLevel?: number | null
    sleepGoal?: number | null
    stepsGoal?: number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    habits?: HabitCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    biometricData?: BiometricDataCreateNestedManyWithoutUserInput
    moodEntries?: MoodEntryCreateNestedManyWithoutUserInput
    stressPredictions?: StressPredictionCreateNestedManyWithoutUserInput
    challengeParticipants?: ChallengeParticipantCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutUserInput
    deviceConnections?: DeviceConnectionCreateNestedManyWithoutUserInput
    wellnessSessions?: WellnessSessionCreateNestedManyWithoutUserInput
    environmentalData?: EnvironmentalDataCreateNestedManyWithoutUserInput
    collaborativeGroups?: GroupMembershipCreateNestedManyWithoutUserInput
    workplaceIntegrations?: WorkplaceIntegrationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timezone?: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: boolean
    biometricSyncEnabled?: boolean
    baseStressLevel?: number | null
    sleepGoal?: number | null
    stepsGoal?: number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    habits?: HabitUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    biometricData?: BiometricDataUncheckedCreateNestedManyWithoutUserInput
    moodEntries?: MoodEntryUncheckedCreateNestedManyWithoutUserInput
    stressPredictions?: StressPredictionUncheckedCreateNestedManyWithoutUserInput
    challengeParticipants?: ChallengeParticipantUncheckedCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutUserInput
    deviceConnections?: DeviceConnectionUncheckedCreateNestedManyWithoutUserInput
    wellnessSessions?: WellnessSessionUncheckedCreateNestedManyWithoutUserInput
    environmentalData?: EnvironmentalDataUncheckedCreateNestedManyWithoutUserInput
    collaborativeGroups?: GroupMembershipUncheckedCreateNestedManyWithoutUserInput
    workplaceIntegrations?: WorkplaceIntegrationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountInput, UserUncheckedCreateWithoutAccountInput>
  }

  export type UserUpsertWithoutAccountInput = {
    update: XOR<UserUpdateWithoutAccountInput, UserUncheckedUpdateWithoutAccountInput>
    create: XOR<UserCreateWithoutAccountInput, UserUncheckedCreateWithoutAccountInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountInput, UserUncheckedUpdateWithoutAccountInput>
  }

  export type UserUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: BoolFieldUpdateOperationsInput | boolean
    biometricSyncEnabled?: BoolFieldUpdateOperationsInput | boolean
    baseStressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    sleepGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    stepsGoal?: NullableIntFieldUpdateOperationsInput | number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    habits?: HabitUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    biometricData?: BiometricDataUpdateManyWithoutUserNestedInput
    moodEntries?: MoodEntryUpdateManyWithoutUserNestedInput
    stressPredictions?: StressPredictionUpdateManyWithoutUserNestedInput
    challengeParticipants?: ChallengeParticipantUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUpdateManyWithoutUserNestedInput
    deviceConnections?: DeviceConnectionUpdateManyWithoutUserNestedInput
    wellnessSessions?: WellnessSessionUpdateManyWithoutUserNestedInput
    environmentalData?: EnvironmentalDataUpdateManyWithoutUserNestedInput
    collaborativeGroups?: GroupMembershipUpdateManyWithoutUserNestedInput
    workplaceIntegrations?: WorkplaceIntegrationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: BoolFieldUpdateOperationsInput | boolean
    biometricSyncEnabled?: BoolFieldUpdateOperationsInput | boolean
    baseStressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    sleepGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    stepsGoal?: NullableIntFieldUpdateOperationsInput | number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    habits?: HabitUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    biometricData?: BiometricDataUncheckedUpdateManyWithoutUserNestedInput
    moodEntries?: MoodEntryUncheckedUpdateManyWithoutUserNestedInput
    stressPredictions?: StressPredictionUncheckedUpdateManyWithoutUserNestedInput
    challengeParticipants?: ChallengeParticipantUncheckedUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutUserNestedInput
    deviceConnections?: DeviceConnectionUncheckedUpdateManyWithoutUserNestedInput
    wellnessSessions?: WellnessSessionUncheckedUpdateManyWithoutUserNestedInput
    environmentalData?: EnvironmentalDataUncheckedUpdateManyWithoutUserNestedInput
    collaborativeGroups?: GroupMembershipUncheckedUpdateManyWithoutUserNestedInput
    workplaceIntegrations?: WorkplaceIntegrationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutJournalEntriesInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timezone?: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: boolean
    biometricSyncEnabled?: boolean
    baseStressLevel?: number | null
    sleepGoal?: number | null
    stepsGoal?: number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionCreateNestedManyWithoutUserInput
    account?: AccountCreateNestedOneWithoutUserInput
    habits?: HabitCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    biometricData?: BiometricDataCreateNestedManyWithoutUserInput
    moodEntries?: MoodEntryCreateNestedManyWithoutUserInput
    stressPredictions?: StressPredictionCreateNestedManyWithoutUserInput
    challengeParticipants?: ChallengeParticipantCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutUserInput
    deviceConnections?: DeviceConnectionCreateNestedManyWithoutUserInput
    wellnessSessions?: WellnessSessionCreateNestedManyWithoutUserInput
    environmentalData?: EnvironmentalDataCreateNestedManyWithoutUserInput
    collaborativeGroups?: GroupMembershipCreateNestedManyWithoutUserInput
    workplaceIntegrations?: WorkplaceIntegrationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutJournalEntriesInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timezone?: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: boolean
    biometricSyncEnabled?: boolean
    baseStressLevel?: number | null
    sleepGoal?: number | null
    stepsGoal?: number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    account?: AccountUncheckedCreateNestedOneWithoutUserInput
    habits?: HabitUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    biometricData?: BiometricDataUncheckedCreateNestedManyWithoutUserInput
    moodEntries?: MoodEntryUncheckedCreateNestedManyWithoutUserInput
    stressPredictions?: StressPredictionUncheckedCreateNestedManyWithoutUserInput
    challengeParticipants?: ChallengeParticipantUncheckedCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutUserInput
    deviceConnections?: DeviceConnectionUncheckedCreateNestedManyWithoutUserInput
    wellnessSessions?: WellnessSessionUncheckedCreateNestedManyWithoutUserInput
    environmentalData?: EnvironmentalDataUncheckedCreateNestedManyWithoutUserInput
    collaborativeGroups?: GroupMembershipUncheckedCreateNestedManyWithoutUserInput
    workplaceIntegrations?: WorkplaceIntegrationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutJournalEntriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutJournalEntriesInput, UserUncheckedCreateWithoutJournalEntriesInput>
  }

  export type UserUpsertWithoutJournalEntriesInput = {
    update: XOR<UserUpdateWithoutJournalEntriesInput, UserUncheckedUpdateWithoutJournalEntriesInput>
    create: XOR<UserCreateWithoutJournalEntriesInput, UserUncheckedCreateWithoutJournalEntriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutJournalEntriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutJournalEntriesInput, UserUncheckedUpdateWithoutJournalEntriesInput>
  }

  export type UserUpdateWithoutJournalEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: BoolFieldUpdateOperationsInput | boolean
    biometricSyncEnabled?: BoolFieldUpdateOperationsInput | boolean
    baseStressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    sleepGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    stepsGoal?: NullableIntFieldUpdateOperationsInput | number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUpdateManyWithoutUserNestedInput
    account?: AccountUpdateOneWithoutUserNestedInput
    habits?: HabitUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    biometricData?: BiometricDataUpdateManyWithoutUserNestedInput
    moodEntries?: MoodEntryUpdateManyWithoutUserNestedInput
    stressPredictions?: StressPredictionUpdateManyWithoutUserNestedInput
    challengeParticipants?: ChallengeParticipantUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUpdateManyWithoutUserNestedInput
    deviceConnections?: DeviceConnectionUpdateManyWithoutUserNestedInput
    wellnessSessions?: WellnessSessionUpdateManyWithoutUserNestedInput
    environmentalData?: EnvironmentalDataUpdateManyWithoutUserNestedInput
    collaborativeGroups?: GroupMembershipUpdateManyWithoutUserNestedInput
    workplaceIntegrations?: WorkplaceIntegrationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutJournalEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: BoolFieldUpdateOperationsInput | boolean
    biometricSyncEnabled?: BoolFieldUpdateOperationsInput | boolean
    baseStressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    sleepGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    stepsGoal?: NullableIntFieldUpdateOperationsInput | number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    account?: AccountUncheckedUpdateOneWithoutUserNestedInput
    habits?: HabitUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    biometricData?: BiometricDataUncheckedUpdateManyWithoutUserNestedInput
    moodEntries?: MoodEntryUncheckedUpdateManyWithoutUserNestedInput
    stressPredictions?: StressPredictionUncheckedUpdateManyWithoutUserNestedInput
    challengeParticipants?: ChallengeParticipantUncheckedUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutUserNestedInput
    deviceConnections?: DeviceConnectionUncheckedUpdateManyWithoutUserNestedInput
    wellnessSessions?: WellnessSessionUncheckedUpdateManyWithoutUserNestedInput
    environmentalData?: EnvironmentalDataUncheckedUpdateManyWithoutUserNestedInput
    collaborativeGroups?: GroupMembershipUncheckedUpdateManyWithoutUserNestedInput
    workplaceIntegrations?: WorkplaceIntegrationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutHabitsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timezone?: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: boolean
    biometricSyncEnabled?: boolean
    baseStressLevel?: number | null
    sleepGoal?: number | null
    stepsGoal?: number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionCreateNestedManyWithoutUserInput
    account?: AccountCreateNestedOneWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    biometricData?: BiometricDataCreateNestedManyWithoutUserInput
    moodEntries?: MoodEntryCreateNestedManyWithoutUserInput
    stressPredictions?: StressPredictionCreateNestedManyWithoutUserInput
    challengeParticipants?: ChallengeParticipantCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutUserInput
    deviceConnections?: DeviceConnectionCreateNestedManyWithoutUserInput
    wellnessSessions?: WellnessSessionCreateNestedManyWithoutUserInput
    environmentalData?: EnvironmentalDataCreateNestedManyWithoutUserInput
    collaborativeGroups?: GroupMembershipCreateNestedManyWithoutUserInput
    workplaceIntegrations?: WorkplaceIntegrationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutHabitsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timezone?: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: boolean
    biometricSyncEnabled?: boolean
    baseStressLevel?: number | null
    sleepGoal?: number | null
    stepsGoal?: number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    account?: AccountUncheckedCreateNestedOneWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    biometricData?: BiometricDataUncheckedCreateNestedManyWithoutUserInput
    moodEntries?: MoodEntryUncheckedCreateNestedManyWithoutUserInput
    stressPredictions?: StressPredictionUncheckedCreateNestedManyWithoutUserInput
    challengeParticipants?: ChallengeParticipantUncheckedCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutUserInput
    deviceConnections?: DeviceConnectionUncheckedCreateNestedManyWithoutUserInput
    wellnessSessions?: WellnessSessionUncheckedCreateNestedManyWithoutUserInput
    environmentalData?: EnvironmentalDataUncheckedCreateNestedManyWithoutUserInput
    collaborativeGroups?: GroupMembershipUncheckedCreateNestedManyWithoutUserInput
    workplaceIntegrations?: WorkplaceIntegrationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutHabitsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHabitsInput, UserUncheckedCreateWithoutHabitsInput>
  }

  export type UserUpsertWithoutHabitsInput = {
    update: XOR<UserUpdateWithoutHabitsInput, UserUncheckedUpdateWithoutHabitsInput>
    create: XOR<UserCreateWithoutHabitsInput, UserUncheckedCreateWithoutHabitsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutHabitsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutHabitsInput, UserUncheckedUpdateWithoutHabitsInput>
  }

  export type UserUpdateWithoutHabitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: BoolFieldUpdateOperationsInput | boolean
    biometricSyncEnabled?: BoolFieldUpdateOperationsInput | boolean
    baseStressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    sleepGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    stepsGoal?: NullableIntFieldUpdateOperationsInput | number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUpdateManyWithoutUserNestedInput
    account?: AccountUpdateOneWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    biometricData?: BiometricDataUpdateManyWithoutUserNestedInput
    moodEntries?: MoodEntryUpdateManyWithoutUserNestedInput
    stressPredictions?: StressPredictionUpdateManyWithoutUserNestedInput
    challengeParticipants?: ChallengeParticipantUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUpdateManyWithoutUserNestedInput
    deviceConnections?: DeviceConnectionUpdateManyWithoutUserNestedInput
    wellnessSessions?: WellnessSessionUpdateManyWithoutUserNestedInput
    environmentalData?: EnvironmentalDataUpdateManyWithoutUserNestedInput
    collaborativeGroups?: GroupMembershipUpdateManyWithoutUserNestedInput
    workplaceIntegrations?: WorkplaceIntegrationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutHabitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: BoolFieldUpdateOperationsInput | boolean
    biometricSyncEnabled?: BoolFieldUpdateOperationsInput | boolean
    baseStressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    sleepGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    stepsGoal?: NullableIntFieldUpdateOperationsInput | number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    account?: AccountUncheckedUpdateOneWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    biometricData?: BiometricDataUncheckedUpdateManyWithoutUserNestedInput
    moodEntries?: MoodEntryUncheckedUpdateManyWithoutUserNestedInput
    stressPredictions?: StressPredictionUncheckedUpdateManyWithoutUserNestedInput
    challengeParticipants?: ChallengeParticipantUncheckedUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutUserNestedInput
    deviceConnections?: DeviceConnectionUncheckedUpdateManyWithoutUserNestedInput
    wellnessSessions?: WellnessSessionUncheckedUpdateManyWithoutUserNestedInput
    environmentalData?: EnvironmentalDataUncheckedUpdateManyWithoutUserNestedInput
    collaborativeGroups?: GroupMembershipUncheckedUpdateManyWithoutUserNestedInput
    workplaceIntegrations?: WorkplaceIntegrationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BookingCreateWithoutClassInput = {
    id?: string
    aiSuggested?: boolean
    predictedEffectiveness?: number | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutBookingsInput
  }

  export type BookingUncheckedCreateWithoutClassInput = {
    id?: string
    userId: string
    aiSuggested?: boolean
    predictedEffectiveness?: number | null
    createdAt?: Date | string
  }

  export type BookingCreateOrConnectWithoutClassInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutClassInput, BookingUncheckedCreateWithoutClassInput>
  }

  export type BookingCreateManyClassInputEnvelope = {
    data: BookingCreateManyClassInput | BookingCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type BookingUpsertWithWhereUniqueWithoutClassInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutClassInput, BookingUncheckedUpdateWithoutClassInput>
    create: XOR<BookingCreateWithoutClassInput, BookingUncheckedCreateWithoutClassInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutClassInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutClassInput, BookingUncheckedUpdateWithoutClassInput>
  }

  export type BookingUpdateManyWithWhereWithoutClassInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutClassInput>
  }

  export type UserCreateWithoutBookingsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timezone?: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: boolean
    biometricSyncEnabled?: boolean
    baseStressLevel?: number | null
    sleepGoal?: number | null
    stepsGoal?: number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionCreateNestedManyWithoutUserInput
    account?: AccountCreateNestedOneWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    habits?: HabitCreateNestedManyWithoutUserInput
    biometricData?: BiometricDataCreateNestedManyWithoutUserInput
    moodEntries?: MoodEntryCreateNestedManyWithoutUserInput
    stressPredictions?: StressPredictionCreateNestedManyWithoutUserInput
    challengeParticipants?: ChallengeParticipantCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutUserInput
    deviceConnections?: DeviceConnectionCreateNestedManyWithoutUserInput
    wellnessSessions?: WellnessSessionCreateNestedManyWithoutUserInput
    environmentalData?: EnvironmentalDataCreateNestedManyWithoutUserInput
    collaborativeGroups?: GroupMembershipCreateNestedManyWithoutUserInput
    workplaceIntegrations?: WorkplaceIntegrationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBookingsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timezone?: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: boolean
    biometricSyncEnabled?: boolean
    baseStressLevel?: number | null
    sleepGoal?: number | null
    stepsGoal?: number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    account?: AccountUncheckedCreateNestedOneWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    habits?: HabitUncheckedCreateNestedManyWithoutUserInput
    biometricData?: BiometricDataUncheckedCreateNestedManyWithoutUserInput
    moodEntries?: MoodEntryUncheckedCreateNestedManyWithoutUserInput
    stressPredictions?: StressPredictionUncheckedCreateNestedManyWithoutUserInput
    challengeParticipants?: ChallengeParticipantUncheckedCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutUserInput
    deviceConnections?: DeviceConnectionUncheckedCreateNestedManyWithoutUserInput
    wellnessSessions?: WellnessSessionUncheckedCreateNestedManyWithoutUserInput
    environmentalData?: EnvironmentalDataUncheckedCreateNestedManyWithoutUserInput
    collaborativeGroups?: GroupMembershipUncheckedCreateNestedManyWithoutUserInput
    workplaceIntegrations?: WorkplaceIntegrationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBookingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
  }

  export type ClassCreateWithoutBookingsInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    durationMins?: number
    instructor: string
    imageUrl?: string | null
    capacity?: number
    intensity?: string
    stressLevel?: number | null
    aiOptimized?: boolean
    adaptiveContent?: NullableJsonNullValueInput | InputJsonValue
    prerequisites?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassUncheckedCreateWithoutBookingsInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    durationMins?: number
    instructor: string
    imageUrl?: string | null
    capacity?: number
    intensity?: string
    stressLevel?: number | null
    aiOptimized?: boolean
    adaptiveContent?: NullableJsonNullValueInput | InputJsonValue
    prerequisites?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassCreateOrConnectWithoutBookingsInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutBookingsInput, ClassUncheckedCreateWithoutBookingsInput>
  }

  export type UserUpsertWithoutBookingsInput = {
    update: XOR<UserUpdateWithoutBookingsInput, UserUncheckedUpdateWithoutBookingsInput>
    create: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBookingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBookingsInput, UserUncheckedUpdateWithoutBookingsInput>
  }

  export type UserUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: BoolFieldUpdateOperationsInput | boolean
    biometricSyncEnabled?: BoolFieldUpdateOperationsInput | boolean
    baseStressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    sleepGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    stepsGoal?: NullableIntFieldUpdateOperationsInput | number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUpdateManyWithoutUserNestedInput
    account?: AccountUpdateOneWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    habits?: HabitUpdateManyWithoutUserNestedInput
    biometricData?: BiometricDataUpdateManyWithoutUserNestedInput
    moodEntries?: MoodEntryUpdateManyWithoutUserNestedInput
    stressPredictions?: StressPredictionUpdateManyWithoutUserNestedInput
    challengeParticipants?: ChallengeParticipantUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUpdateManyWithoutUserNestedInput
    deviceConnections?: DeviceConnectionUpdateManyWithoutUserNestedInput
    wellnessSessions?: WellnessSessionUpdateManyWithoutUserNestedInput
    environmentalData?: EnvironmentalDataUpdateManyWithoutUserNestedInput
    collaborativeGroups?: GroupMembershipUpdateManyWithoutUserNestedInput
    workplaceIntegrations?: WorkplaceIntegrationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: BoolFieldUpdateOperationsInput | boolean
    biometricSyncEnabled?: BoolFieldUpdateOperationsInput | boolean
    baseStressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    sleepGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    stepsGoal?: NullableIntFieldUpdateOperationsInput | number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    account?: AccountUncheckedUpdateOneWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    habits?: HabitUncheckedUpdateManyWithoutUserNestedInput
    biometricData?: BiometricDataUncheckedUpdateManyWithoutUserNestedInput
    moodEntries?: MoodEntryUncheckedUpdateManyWithoutUserNestedInput
    stressPredictions?: StressPredictionUncheckedUpdateManyWithoutUserNestedInput
    challengeParticipants?: ChallengeParticipantUncheckedUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutUserNestedInput
    deviceConnections?: DeviceConnectionUncheckedUpdateManyWithoutUserNestedInput
    wellnessSessions?: WellnessSessionUncheckedUpdateManyWithoutUserNestedInput
    environmentalData?: EnvironmentalDataUncheckedUpdateManyWithoutUserNestedInput
    collaborativeGroups?: GroupMembershipUncheckedUpdateManyWithoutUserNestedInput
    workplaceIntegrations?: WorkplaceIntegrationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ClassUpsertWithoutBookingsInput = {
    update: XOR<ClassUpdateWithoutBookingsInput, ClassUncheckedUpdateWithoutBookingsInput>
    create: XOR<ClassCreateWithoutBookingsInput, ClassUncheckedCreateWithoutBookingsInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutBookingsInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutBookingsInput, ClassUncheckedUpdateWithoutBookingsInput>
  }

  export type ClassUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMins?: IntFieldUpdateOperationsInput | number
    instructor?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    intensity?: StringFieldUpdateOperationsInput | string
    stressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    aiOptimized?: BoolFieldUpdateOperationsInput | boolean
    adaptiveContent?: NullableJsonNullValueInput | InputJsonValue
    prerequisites?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMins?: IntFieldUpdateOperationsInput | number
    instructor?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    intensity?: StringFieldUpdateOperationsInput | string
    stressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    aiOptimized?: BoolFieldUpdateOperationsInput | boolean
    adaptiveContent?: NullableJsonNullValueInput | InputJsonValue
    prerequisites?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutBiometricDataInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timezone?: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: boolean
    biometricSyncEnabled?: boolean
    baseStressLevel?: number | null
    sleepGoal?: number | null
    stepsGoal?: number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionCreateNestedManyWithoutUserInput
    account?: AccountCreateNestedOneWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    habits?: HabitCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    moodEntries?: MoodEntryCreateNestedManyWithoutUserInput
    stressPredictions?: StressPredictionCreateNestedManyWithoutUserInput
    challengeParticipants?: ChallengeParticipantCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutUserInput
    deviceConnections?: DeviceConnectionCreateNestedManyWithoutUserInput
    wellnessSessions?: WellnessSessionCreateNestedManyWithoutUserInput
    environmentalData?: EnvironmentalDataCreateNestedManyWithoutUserInput
    collaborativeGroups?: GroupMembershipCreateNestedManyWithoutUserInput
    workplaceIntegrations?: WorkplaceIntegrationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBiometricDataInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timezone?: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: boolean
    biometricSyncEnabled?: boolean
    baseStressLevel?: number | null
    sleepGoal?: number | null
    stepsGoal?: number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    account?: AccountUncheckedCreateNestedOneWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    habits?: HabitUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    moodEntries?: MoodEntryUncheckedCreateNestedManyWithoutUserInput
    stressPredictions?: StressPredictionUncheckedCreateNestedManyWithoutUserInput
    challengeParticipants?: ChallengeParticipantUncheckedCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutUserInput
    deviceConnections?: DeviceConnectionUncheckedCreateNestedManyWithoutUserInput
    wellnessSessions?: WellnessSessionUncheckedCreateNestedManyWithoutUserInput
    environmentalData?: EnvironmentalDataUncheckedCreateNestedManyWithoutUserInput
    collaborativeGroups?: GroupMembershipUncheckedCreateNestedManyWithoutUserInput
    workplaceIntegrations?: WorkplaceIntegrationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBiometricDataInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBiometricDataInput, UserUncheckedCreateWithoutBiometricDataInput>
  }

  export type UserUpsertWithoutBiometricDataInput = {
    update: XOR<UserUpdateWithoutBiometricDataInput, UserUncheckedUpdateWithoutBiometricDataInput>
    create: XOR<UserCreateWithoutBiometricDataInput, UserUncheckedCreateWithoutBiometricDataInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBiometricDataInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBiometricDataInput, UserUncheckedUpdateWithoutBiometricDataInput>
  }

  export type UserUpdateWithoutBiometricDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: BoolFieldUpdateOperationsInput | boolean
    biometricSyncEnabled?: BoolFieldUpdateOperationsInput | boolean
    baseStressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    sleepGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    stepsGoal?: NullableIntFieldUpdateOperationsInput | number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUpdateManyWithoutUserNestedInput
    account?: AccountUpdateOneWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    habits?: HabitUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    moodEntries?: MoodEntryUpdateManyWithoutUserNestedInput
    stressPredictions?: StressPredictionUpdateManyWithoutUserNestedInput
    challengeParticipants?: ChallengeParticipantUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUpdateManyWithoutUserNestedInput
    deviceConnections?: DeviceConnectionUpdateManyWithoutUserNestedInput
    wellnessSessions?: WellnessSessionUpdateManyWithoutUserNestedInput
    environmentalData?: EnvironmentalDataUpdateManyWithoutUserNestedInput
    collaborativeGroups?: GroupMembershipUpdateManyWithoutUserNestedInput
    workplaceIntegrations?: WorkplaceIntegrationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBiometricDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: BoolFieldUpdateOperationsInput | boolean
    biometricSyncEnabled?: BoolFieldUpdateOperationsInput | boolean
    baseStressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    sleepGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    stepsGoal?: NullableIntFieldUpdateOperationsInput | number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    account?: AccountUncheckedUpdateOneWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    habits?: HabitUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    moodEntries?: MoodEntryUncheckedUpdateManyWithoutUserNestedInput
    stressPredictions?: StressPredictionUncheckedUpdateManyWithoutUserNestedInput
    challengeParticipants?: ChallengeParticipantUncheckedUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutUserNestedInput
    deviceConnections?: DeviceConnectionUncheckedUpdateManyWithoutUserNestedInput
    wellnessSessions?: WellnessSessionUncheckedUpdateManyWithoutUserNestedInput
    environmentalData?: EnvironmentalDataUncheckedUpdateManyWithoutUserNestedInput
    collaborativeGroups?: GroupMembershipUncheckedUpdateManyWithoutUserNestedInput
    workplaceIntegrations?: WorkplaceIntegrationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutMoodEntriesInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timezone?: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: boolean
    biometricSyncEnabled?: boolean
    baseStressLevel?: number | null
    sleepGoal?: number | null
    stepsGoal?: number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionCreateNestedManyWithoutUserInput
    account?: AccountCreateNestedOneWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    habits?: HabitCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    biometricData?: BiometricDataCreateNestedManyWithoutUserInput
    stressPredictions?: StressPredictionCreateNestedManyWithoutUserInput
    challengeParticipants?: ChallengeParticipantCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutUserInput
    deviceConnections?: DeviceConnectionCreateNestedManyWithoutUserInput
    wellnessSessions?: WellnessSessionCreateNestedManyWithoutUserInput
    environmentalData?: EnvironmentalDataCreateNestedManyWithoutUserInput
    collaborativeGroups?: GroupMembershipCreateNestedManyWithoutUserInput
    workplaceIntegrations?: WorkplaceIntegrationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMoodEntriesInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timezone?: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: boolean
    biometricSyncEnabled?: boolean
    baseStressLevel?: number | null
    sleepGoal?: number | null
    stepsGoal?: number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    account?: AccountUncheckedCreateNestedOneWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    habits?: HabitUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    biometricData?: BiometricDataUncheckedCreateNestedManyWithoutUserInput
    stressPredictions?: StressPredictionUncheckedCreateNestedManyWithoutUserInput
    challengeParticipants?: ChallengeParticipantUncheckedCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutUserInput
    deviceConnections?: DeviceConnectionUncheckedCreateNestedManyWithoutUserInput
    wellnessSessions?: WellnessSessionUncheckedCreateNestedManyWithoutUserInput
    environmentalData?: EnvironmentalDataUncheckedCreateNestedManyWithoutUserInput
    collaborativeGroups?: GroupMembershipUncheckedCreateNestedManyWithoutUserInput
    workplaceIntegrations?: WorkplaceIntegrationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMoodEntriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMoodEntriesInput, UserUncheckedCreateWithoutMoodEntriesInput>
  }

  export type UserUpsertWithoutMoodEntriesInput = {
    update: XOR<UserUpdateWithoutMoodEntriesInput, UserUncheckedUpdateWithoutMoodEntriesInput>
    create: XOR<UserCreateWithoutMoodEntriesInput, UserUncheckedCreateWithoutMoodEntriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMoodEntriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMoodEntriesInput, UserUncheckedUpdateWithoutMoodEntriesInput>
  }

  export type UserUpdateWithoutMoodEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: BoolFieldUpdateOperationsInput | boolean
    biometricSyncEnabled?: BoolFieldUpdateOperationsInput | boolean
    baseStressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    sleepGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    stepsGoal?: NullableIntFieldUpdateOperationsInput | number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUpdateManyWithoutUserNestedInput
    account?: AccountUpdateOneWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    habits?: HabitUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    biometricData?: BiometricDataUpdateManyWithoutUserNestedInput
    stressPredictions?: StressPredictionUpdateManyWithoutUserNestedInput
    challengeParticipants?: ChallengeParticipantUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUpdateManyWithoutUserNestedInput
    deviceConnections?: DeviceConnectionUpdateManyWithoutUserNestedInput
    wellnessSessions?: WellnessSessionUpdateManyWithoutUserNestedInput
    environmentalData?: EnvironmentalDataUpdateManyWithoutUserNestedInput
    collaborativeGroups?: GroupMembershipUpdateManyWithoutUserNestedInput
    workplaceIntegrations?: WorkplaceIntegrationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMoodEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: BoolFieldUpdateOperationsInput | boolean
    biometricSyncEnabled?: BoolFieldUpdateOperationsInput | boolean
    baseStressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    sleepGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    stepsGoal?: NullableIntFieldUpdateOperationsInput | number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    account?: AccountUncheckedUpdateOneWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    habits?: HabitUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    biometricData?: BiometricDataUncheckedUpdateManyWithoutUserNestedInput
    stressPredictions?: StressPredictionUncheckedUpdateManyWithoutUserNestedInput
    challengeParticipants?: ChallengeParticipantUncheckedUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutUserNestedInput
    deviceConnections?: DeviceConnectionUncheckedUpdateManyWithoutUserNestedInput
    wellnessSessions?: WellnessSessionUncheckedUpdateManyWithoutUserNestedInput
    environmentalData?: EnvironmentalDataUncheckedUpdateManyWithoutUserNestedInput
    collaborativeGroups?: GroupMembershipUncheckedUpdateManyWithoutUserNestedInput
    workplaceIntegrations?: WorkplaceIntegrationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutStressPredictionsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timezone?: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: boolean
    biometricSyncEnabled?: boolean
    baseStressLevel?: number | null
    sleepGoal?: number | null
    stepsGoal?: number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionCreateNestedManyWithoutUserInput
    account?: AccountCreateNestedOneWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    habits?: HabitCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    biometricData?: BiometricDataCreateNestedManyWithoutUserInput
    moodEntries?: MoodEntryCreateNestedManyWithoutUserInput
    challengeParticipants?: ChallengeParticipantCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutUserInput
    deviceConnections?: DeviceConnectionCreateNestedManyWithoutUserInput
    wellnessSessions?: WellnessSessionCreateNestedManyWithoutUserInput
    environmentalData?: EnvironmentalDataCreateNestedManyWithoutUserInput
    collaborativeGroups?: GroupMembershipCreateNestedManyWithoutUserInput
    workplaceIntegrations?: WorkplaceIntegrationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStressPredictionsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timezone?: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: boolean
    biometricSyncEnabled?: boolean
    baseStressLevel?: number | null
    sleepGoal?: number | null
    stepsGoal?: number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    account?: AccountUncheckedCreateNestedOneWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    habits?: HabitUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    biometricData?: BiometricDataUncheckedCreateNestedManyWithoutUserInput
    moodEntries?: MoodEntryUncheckedCreateNestedManyWithoutUserInput
    challengeParticipants?: ChallengeParticipantUncheckedCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutUserInput
    deviceConnections?: DeviceConnectionUncheckedCreateNestedManyWithoutUserInput
    wellnessSessions?: WellnessSessionUncheckedCreateNestedManyWithoutUserInput
    environmentalData?: EnvironmentalDataUncheckedCreateNestedManyWithoutUserInput
    collaborativeGroups?: GroupMembershipUncheckedCreateNestedManyWithoutUserInput
    workplaceIntegrations?: WorkplaceIntegrationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStressPredictionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStressPredictionsInput, UserUncheckedCreateWithoutStressPredictionsInput>
  }

  export type UserUpsertWithoutStressPredictionsInput = {
    update: XOR<UserUpdateWithoutStressPredictionsInput, UserUncheckedUpdateWithoutStressPredictionsInput>
    create: XOR<UserCreateWithoutStressPredictionsInput, UserUncheckedCreateWithoutStressPredictionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStressPredictionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStressPredictionsInput, UserUncheckedUpdateWithoutStressPredictionsInput>
  }

  export type UserUpdateWithoutStressPredictionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: BoolFieldUpdateOperationsInput | boolean
    biometricSyncEnabled?: BoolFieldUpdateOperationsInput | boolean
    baseStressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    sleepGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    stepsGoal?: NullableIntFieldUpdateOperationsInput | number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUpdateManyWithoutUserNestedInput
    account?: AccountUpdateOneWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    habits?: HabitUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    biometricData?: BiometricDataUpdateManyWithoutUserNestedInput
    moodEntries?: MoodEntryUpdateManyWithoutUserNestedInput
    challengeParticipants?: ChallengeParticipantUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUpdateManyWithoutUserNestedInput
    deviceConnections?: DeviceConnectionUpdateManyWithoutUserNestedInput
    wellnessSessions?: WellnessSessionUpdateManyWithoutUserNestedInput
    environmentalData?: EnvironmentalDataUpdateManyWithoutUserNestedInput
    collaborativeGroups?: GroupMembershipUpdateManyWithoutUserNestedInput
    workplaceIntegrations?: WorkplaceIntegrationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStressPredictionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: BoolFieldUpdateOperationsInput | boolean
    biometricSyncEnabled?: BoolFieldUpdateOperationsInput | boolean
    baseStressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    sleepGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    stepsGoal?: NullableIntFieldUpdateOperationsInput | number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    account?: AccountUncheckedUpdateOneWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    habits?: HabitUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    biometricData?: BiometricDataUncheckedUpdateManyWithoutUserNestedInput
    moodEntries?: MoodEntryUncheckedUpdateManyWithoutUserNestedInput
    challengeParticipants?: ChallengeParticipantUncheckedUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutUserNestedInput
    deviceConnections?: DeviceConnectionUncheckedUpdateManyWithoutUserNestedInput
    wellnessSessions?: WellnessSessionUncheckedUpdateManyWithoutUserNestedInput
    environmentalData?: EnvironmentalDataUncheckedUpdateManyWithoutUserNestedInput
    collaborativeGroups?: GroupMembershipUncheckedUpdateManyWithoutUserNestedInput
    workplaceIntegrations?: WorkplaceIntegrationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ChallengeParticipantCreateWithoutChallengeInput = {
    id?: string
    progress: JsonNullValueInput | InputJsonValue
    completed?: boolean
    currentStreak?: number
    bestStreak?: number
    rank?: number | null
    joinedAt?: Date | string
    completedAt?: Date | string | null
    user: UserCreateNestedOneWithoutChallengeParticipantsInput
  }

  export type ChallengeParticipantUncheckedCreateWithoutChallengeInput = {
    id?: string
    userId: string
    progress: JsonNullValueInput | InputJsonValue
    completed?: boolean
    currentStreak?: number
    bestStreak?: number
    rank?: number | null
    joinedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type ChallengeParticipantCreateOrConnectWithoutChallengeInput = {
    where: ChallengeParticipantWhereUniqueInput
    create: XOR<ChallengeParticipantCreateWithoutChallengeInput, ChallengeParticipantUncheckedCreateWithoutChallengeInput>
  }

  export type ChallengeParticipantCreateManyChallengeInputEnvelope = {
    data: ChallengeParticipantCreateManyChallengeInput | ChallengeParticipantCreateManyChallengeInput[]
    skipDuplicates?: boolean
  }

  export type ChallengeParticipantUpsertWithWhereUniqueWithoutChallengeInput = {
    where: ChallengeParticipantWhereUniqueInput
    update: XOR<ChallengeParticipantUpdateWithoutChallengeInput, ChallengeParticipantUncheckedUpdateWithoutChallengeInput>
    create: XOR<ChallengeParticipantCreateWithoutChallengeInput, ChallengeParticipantUncheckedCreateWithoutChallengeInput>
  }

  export type ChallengeParticipantUpdateWithWhereUniqueWithoutChallengeInput = {
    where: ChallengeParticipantWhereUniqueInput
    data: XOR<ChallengeParticipantUpdateWithoutChallengeInput, ChallengeParticipantUncheckedUpdateWithoutChallengeInput>
  }

  export type ChallengeParticipantUpdateManyWithWhereWithoutChallengeInput = {
    where: ChallengeParticipantScalarWhereInput
    data: XOR<ChallengeParticipantUpdateManyMutationInput, ChallengeParticipantUncheckedUpdateManyWithoutChallengeInput>
  }

  export type UserCreateWithoutChallengeParticipantsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timezone?: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: boolean
    biometricSyncEnabled?: boolean
    baseStressLevel?: number | null
    sleepGoal?: number | null
    stepsGoal?: number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionCreateNestedManyWithoutUserInput
    account?: AccountCreateNestedOneWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    habits?: HabitCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    biometricData?: BiometricDataCreateNestedManyWithoutUserInput
    moodEntries?: MoodEntryCreateNestedManyWithoutUserInput
    stressPredictions?: StressPredictionCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutUserInput
    deviceConnections?: DeviceConnectionCreateNestedManyWithoutUserInput
    wellnessSessions?: WellnessSessionCreateNestedManyWithoutUserInput
    environmentalData?: EnvironmentalDataCreateNestedManyWithoutUserInput
    collaborativeGroups?: GroupMembershipCreateNestedManyWithoutUserInput
    workplaceIntegrations?: WorkplaceIntegrationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutChallengeParticipantsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timezone?: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: boolean
    biometricSyncEnabled?: boolean
    baseStressLevel?: number | null
    sleepGoal?: number | null
    stepsGoal?: number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    account?: AccountUncheckedCreateNestedOneWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    habits?: HabitUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    biometricData?: BiometricDataUncheckedCreateNestedManyWithoutUserInput
    moodEntries?: MoodEntryUncheckedCreateNestedManyWithoutUserInput
    stressPredictions?: StressPredictionUncheckedCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutUserInput
    deviceConnections?: DeviceConnectionUncheckedCreateNestedManyWithoutUserInput
    wellnessSessions?: WellnessSessionUncheckedCreateNestedManyWithoutUserInput
    environmentalData?: EnvironmentalDataUncheckedCreateNestedManyWithoutUserInput
    collaborativeGroups?: GroupMembershipUncheckedCreateNestedManyWithoutUserInput
    workplaceIntegrations?: WorkplaceIntegrationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutChallengeParticipantsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChallengeParticipantsInput, UserUncheckedCreateWithoutChallengeParticipantsInput>
  }

  export type WellnessChallengeCreateWithoutParticipantsInput = {
    id?: string
    title: string
    description: string
    type: string
    duration: number
    target: JsonNullValueInput | InputJsonValue
    reward?: string | null
    isActive?: boolean
    startDate: Date | string
    endDate: Date | string
    maxParticipants?: number | null
    isPublic?: boolean
    teamBased?: boolean
    aiGenerated?: boolean
    adaptiveDifficulty?: boolean
    personalizedGoals?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WellnessChallengeUncheckedCreateWithoutParticipantsInput = {
    id?: string
    title: string
    description: string
    type: string
    duration: number
    target: JsonNullValueInput | InputJsonValue
    reward?: string | null
    isActive?: boolean
    startDate: Date | string
    endDate: Date | string
    maxParticipants?: number | null
    isPublic?: boolean
    teamBased?: boolean
    aiGenerated?: boolean
    adaptiveDifficulty?: boolean
    personalizedGoals?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WellnessChallengeCreateOrConnectWithoutParticipantsInput = {
    where: WellnessChallengeWhereUniqueInput
    create: XOR<WellnessChallengeCreateWithoutParticipantsInput, WellnessChallengeUncheckedCreateWithoutParticipantsInput>
  }

  export type UserUpsertWithoutChallengeParticipantsInput = {
    update: XOR<UserUpdateWithoutChallengeParticipantsInput, UserUncheckedUpdateWithoutChallengeParticipantsInput>
    create: XOR<UserCreateWithoutChallengeParticipantsInput, UserUncheckedCreateWithoutChallengeParticipantsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChallengeParticipantsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChallengeParticipantsInput, UserUncheckedUpdateWithoutChallengeParticipantsInput>
  }

  export type UserUpdateWithoutChallengeParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: BoolFieldUpdateOperationsInput | boolean
    biometricSyncEnabled?: BoolFieldUpdateOperationsInput | boolean
    baseStressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    sleepGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    stepsGoal?: NullableIntFieldUpdateOperationsInput | number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUpdateManyWithoutUserNestedInput
    account?: AccountUpdateOneWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    habits?: HabitUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    biometricData?: BiometricDataUpdateManyWithoutUserNestedInput
    moodEntries?: MoodEntryUpdateManyWithoutUserNestedInput
    stressPredictions?: StressPredictionUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUpdateManyWithoutUserNestedInput
    deviceConnections?: DeviceConnectionUpdateManyWithoutUserNestedInput
    wellnessSessions?: WellnessSessionUpdateManyWithoutUserNestedInput
    environmentalData?: EnvironmentalDataUpdateManyWithoutUserNestedInput
    collaborativeGroups?: GroupMembershipUpdateManyWithoutUserNestedInput
    workplaceIntegrations?: WorkplaceIntegrationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutChallengeParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: BoolFieldUpdateOperationsInput | boolean
    biometricSyncEnabled?: BoolFieldUpdateOperationsInput | boolean
    baseStressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    sleepGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    stepsGoal?: NullableIntFieldUpdateOperationsInput | number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    account?: AccountUncheckedUpdateOneWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    habits?: HabitUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    biometricData?: BiometricDataUncheckedUpdateManyWithoutUserNestedInput
    moodEntries?: MoodEntryUncheckedUpdateManyWithoutUserNestedInput
    stressPredictions?: StressPredictionUncheckedUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutUserNestedInput
    deviceConnections?: DeviceConnectionUncheckedUpdateManyWithoutUserNestedInput
    wellnessSessions?: WellnessSessionUncheckedUpdateManyWithoutUserNestedInput
    environmentalData?: EnvironmentalDataUncheckedUpdateManyWithoutUserNestedInput
    collaborativeGroups?: GroupMembershipUncheckedUpdateManyWithoutUserNestedInput
    workplaceIntegrations?: WorkplaceIntegrationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WellnessChallengeUpsertWithoutParticipantsInput = {
    update: XOR<WellnessChallengeUpdateWithoutParticipantsInput, WellnessChallengeUncheckedUpdateWithoutParticipantsInput>
    create: XOR<WellnessChallengeCreateWithoutParticipantsInput, WellnessChallengeUncheckedCreateWithoutParticipantsInput>
    where?: WellnessChallengeWhereInput
  }

  export type WellnessChallengeUpdateToOneWithWhereWithoutParticipantsInput = {
    where?: WellnessChallengeWhereInput
    data: XOR<WellnessChallengeUpdateWithoutParticipantsInput, WellnessChallengeUncheckedUpdateWithoutParticipantsInput>
  }

  export type WellnessChallengeUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    target?: JsonNullValueInput | InputJsonValue
    reward?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    teamBased?: BoolFieldUpdateOperationsInput | boolean
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    adaptiveDifficulty?: BoolFieldUpdateOperationsInput | boolean
    personalizedGoals?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WellnessChallengeUncheckedUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    target?: JsonNullValueInput | InputJsonValue
    reward?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    teamBased?: BoolFieldUpdateOperationsInput | boolean
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    adaptiveDifficulty?: BoolFieldUpdateOperationsInput | boolean
    personalizedGoals?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutAiRecommendationsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timezone?: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: boolean
    biometricSyncEnabled?: boolean
    baseStressLevel?: number | null
    sleepGoal?: number | null
    stepsGoal?: number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionCreateNestedManyWithoutUserInput
    account?: AccountCreateNestedOneWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    habits?: HabitCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    biometricData?: BiometricDataCreateNestedManyWithoutUserInput
    moodEntries?: MoodEntryCreateNestedManyWithoutUserInput
    stressPredictions?: StressPredictionCreateNestedManyWithoutUserInput
    challengeParticipants?: ChallengeParticipantCreateNestedManyWithoutUserInput
    deviceConnections?: DeviceConnectionCreateNestedManyWithoutUserInput
    wellnessSessions?: WellnessSessionCreateNestedManyWithoutUserInput
    environmentalData?: EnvironmentalDataCreateNestedManyWithoutUserInput
    collaborativeGroups?: GroupMembershipCreateNestedManyWithoutUserInput
    workplaceIntegrations?: WorkplaceIntegrationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAiRecommendationsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timezone?: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: boolean
    biometricSyncEnabled?: boolean
    baseStressLevel?: number | null
    sleepGoal?: number | null
    stepsGoal?: number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    account?: AccountUncheckedCreateNestedOneWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    habits?: HabitUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    biometricData?: BiometricDataUncheckedCreateNestedManyWithoutUserInput
    moodEntries?: MoodEntryUncheckedCreateNestedManyWithoutUserInput
    stressPredictions?: StressPredictionUncheckedCreateNestedManyWithoutUserInput
    challengeParticipants?: ChallengeParticipantUncheckedCreateNestedManyWithoutUserInput
    deviceConnections?: DeviceConnectionUncheckedCreateNestedManyWithoutUserInput
    wellnessSessions?: WellnessSessionUncheckedCreateNestedManyWithoutUserInput
    environmentalData?: EnvironmentalDataUncheckedCreateNestedManyWithoutUserInput
    collaborativeGroups?: GroupMembershipUncheckedCreateNestedManyWithoutUserInput
    workplaceIntegrations?: WorkplaceIntegrationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAiRecommendationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAiRecommendationsInput, UserUncheckedCreateWithoutAiRecommendationsInput>
  }

  export type UserUpsertWithoutAiRecommendationsInput = {
    update: XOR<UserUpdateWithoutAiRecommendationsInput, UserUncheckedUpdateWithoutAiRecommendationsInput>
    create: XOR<UserCreateWithoutAiRecommendationsInput, UserUncheckedCreateWithoutAiRecommendationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAiRecommendationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAiRecommendationsInput, UserUncheckedUpdateWithoutAiRecommendationsInput>
  }

  export type UserUpdateWithoutAiRecommendationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: BoolFieldUpdateOperationsInput | boolean
    biometricSyncEnabled?: BoolFieldUpdateOperationsInput | boolean
    baseStressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    sleepGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    stepsGoal?: NullableIntFieldUpdateOperationsInput | number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUpdateManyWithoutUserNestedInput
    account?: AccountUpdateOneWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    habits?: HabitUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    biometricData?: BiometricDataUpdateManyWithoutUserNestedInput
    moodEntries?: MoodEntryUpdateManyWithoutUserNestedInput
    stressPredictions?: StressPredictionUpdateManyWithoutUserNestedInput
    challengeParticipants?: ChallengeParticipantUpdateManyWithoutUserNestedInput
    deviceConnections?: DeviceConnectionUpdateManyWithoutUserNestedInput
    wellnessSessions?: WellnessSessionUpdateManyWithoutUserNestedInput
    environmentalData?: EnvironmentalDataUpdateManyWithoutUserNestedInput
    collaborativeGroups?: GroupMembershipUpdateManyWithoutUserNestedInput
    workplaceIntegrations?: WorkplaceIntegrationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAiRecommendationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: BoolFieldUpdateOperationsInput | boolean
    biometricSyncEnabled?: BoolFieldUpdateOperationsInput | boolean
    baseStressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    sleepGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    stepsGoal?: NullableIntFieldUpdateOperationsInput | number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    account?: AccountUncheckedUpdateOneWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    habits?: HabitUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    biometricData?: BiometricDataUncheckedUpdateManyWithoutUserNestedInput
    moodEntries?: MoodEntryUncheckedUpdateManyWithoutUserNestedInput
    stressPredictions?: StressPredictionUncheckedUpdateManyWithoutUserNestedInput
    challengeParticipants?: ChallengeParticipantUncheckedUpdateManyWithoutUserNestedInput
    deviceConnections?: DeviceConnectionUncheckedUpdateManyWithoutUserNestedInput
    wellnessSessions?: WellnessSessionUncheckedUpdateManyWithoutUserNestedInput
    environmentalData?: EnvironmentalDataUncheckedUpdateManyWithoutUserNestedInput
    collaborativeGroups?: GroupMembershipUncheckedUpdateManyWithoutUserNestedInput
    workplaceIntegrations?: WorkplaceIntegrationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutDeviceConnectionsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timezone?: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: boolean
    biometricSyncEnabled?: boolean
    baseStressLevel?: number | null
    sleepGoal?: number | null
    stepsGoal?: number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionCreateNestedManyWithoutUserInput
    account?: AccountCreateNestedOneWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    habits?: HabitCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    biometricData?: BiometricDataCreateNestedManyWithoutUserInput
    moodEntries?: MoodEntryCreateNestedManyWithoutUserInput
    stressPredictions?: StressPredictionCreateNestedManyWithoutUserInput
    challengeParticipants?: ChallengeParticipantCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutUserInput
    wellnessSessions?: WellnessSessionCreateNestedManyWithoutUserInput
    environmentalData?: EnvironmentalDataCreateNestedManyWithoutUserInput
    collaborativeGroups?: GroupMembershipCreateNestedManyWithoutUserInput
    workplaceIntegrations?: WorkplaceIntegrationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDeviceConnectionsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timezone?: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: boolean
    biometricSyncEnabled?: boolean
    baseStressLevel?: number | null
    sleepGoal?: number | null
    stepsGoal?: number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    account?: AccountUncheckedCreateNestedOneWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    habits?: HabitUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    biometricData?: BiometricDataUncheckedCreateNestedManyWithoutUserInput
    moodEntries?: MoodEntryUncheckedCreateNestedManyWithoutUserInput
    stressPredictions?: StressPredictionUncheckedCreateNestedManyWithoutUserInput
    challengeParticipants?: ChallengeParticipantUncheckedCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutUserInput
    wellnessSessions?: WellnessSessionUncheckedCreateNestedManyWithoutUserInput
    environmentalData?: EnvironmentalDataUncheckedCreateNestedManyWithoutUserInput
    collaborativeGroups?: GroupMembershipUncheckedCreateNestedManyWithoutUserInput
    workplaceIntegrations?: WorkplaceIntegrationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDeviceConnectionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDeviceConnectionsInput, UserUncheckedCreateWithoutDeviceConnectionsInput>
  }

  export type UserUpsertWithoutDeviceConnectionsInput = {
    update: XOR<UserUpdateWithoutDeviceConnectionsInput, UserUncheckedUpdateWithoutDeviceConnectionsInput>
    create: XOR<UserCreateWithoutDeviceConnectionsInput, UserUncheckedCreateWithoutDeviceConnectionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDeviceConnectionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDeviceConnectionsInput, UserUncheckedUpdateWithoutDeviceConnectionsInput>
  }

  export type UserUpdateWithoutDeviceConnectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: BoolFieldUpdateOperationsInput | boolean
    biometricSyncEnabled?: BoolFieldUpdateOperationsInput | boolean
    baseStressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    sleepGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    stepsGoal?: NullableIntFieldUpdateOperationsInput | number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUpdateManyWithoutUserNestedInput
    account?: AccountUpdateOneWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    habits?: HabitUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    biometricData?: BiometricDataUpdateManyWithoutUserNestedInput
    moodEntries?: MoodEntryUpdateManyWithoutUserNestedInput
    stressPredictions?: StressPredictionUpdateManyWithoutUserNestedInput
    challengeParticipants?: ChallengeParticipantUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUpdateManyWithoutUserNestedInput
    wellnessSessions?: WellnessSessionUpdateManyWithoutUserNestedInput
    environmentalData?: EnvironmentalDataUpdateManyWithoutUserNestedInput
    collaborativeGroups?: GroupMembershipUpdateManyWithoutUserNestedInput
    workplaceIntegrations?: WorkplaceIntegrationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDeviceConnectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: BoolFieldUpdateOperationsInput | boolean
    biometricSyncEnabled?: BoolFieldUpdateOperationsInput | boolean
    baseStressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    sleepGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    stepsGoal?: NullableIntFieldUpdateOperationsInput | number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    account?: AccountUncheckedUpdateOneWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    habits?: HabitUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    biometricData?: BiometricDataUncheckedUpdateManyWithoutUserNestedInput
    moodEntries?: MoodEntryUncheckedUpdateManyWithoutUserNestedInput
    stressPredictions?: StressPredictionUncheckedUpdateManyWithoutUserNestedInput
    challengeParticipants?: ChallengeParticipantUncheckedUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutUserNestedInput
    wellnessSessions?: WellnessSessionUncheckedUpdateManyWithoutUserNestedInput
    environmentalData?: EnvironmentalDataUncheckedUpdateManyWithoutUserNestedInput
    collaborativeGroups?: GroupMembershipUncheckedUpdateManyWithoutUserNestedInput
    workplaceIntegrations?: WorkplaceIntegrationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutWellnessSessionsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timezone?: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: boolean
    biometricSyncEnabled?: boolean
    baseStressLevel?: number | null
    sleepGoal?: number | null
    stepsGoal?: number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionCreateNestedManyWithoutUserInput
    account?: AccountCreateNestedOneWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    habits?: HabitCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    biometricData?: BiometricDataCreateNestedManyWithoutUserInput
    moodEntries?: MoodEntryCreateNestedManyWithoutUserInput
    stressPredictions?: StressPredictionCreateNestedManyWithoutUserInput
    challengeParticipants?: ChallengeParticipantCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutUserInput
    deviceConnections?: DeviceConnectionCreateNestedManyWithoutUserInput
    environmentalData?: EnvironmentalDataCreateNestedManyWithoutUserInput
    collaborativeGroups?: GroupMembershipCreateNestedManyWithoutUserInput
    workplaceIntegrations?: WorkplaceIntegrationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWellnessSessionsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timezone?: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: boolean
    biometricSyncEnabled?: boolean
    baseStressLevel?: number | null
    sleepGoal?: number | null
    stepsGoal?: number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    account?: AccountUncheckedCreateNestedOneWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    habits?: HabitUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    biometricData?: BiometricDataUncheckedCreateNestedManyWithoutUserInput
    moodEntries?: MoodEntryUncheckedCreateNestedManyWithoutUserInput
    stressPredictions?: StressPredictionUncheckedCreateNestedManyWithoutUserInput
    challengeParticipants?: ChallengeParticipantUncheckedCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutUserInput
    deviceConnections?: DeviceConnectionUncheckedCreateNestedManyWithoutUserInput
    environmentalData?: EnvironmentalDataUncheckedCreateNestedManyWithoutUserInput
    collaborativeGroups?: GroupMembershipUncheckedCreateNestedManyWithoutUserInput
    workplaceIntegrations?: WorkplaceIntegrationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWellnessSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWellnessSessionsInput, UserUncheckedCreateWithoutWellnessSessionsInput>
  }

  export type UserUpsertWithoutWellnessSessionsInput = {
    update: XOR<UserUpdateWithoutWellnessSessionsInput, UserUncheckedUpdateWithoutWellnessSessionsInput>
    create: XOR<UserCreateWithoutWellnessSessionsInput, UserUncheckedCreateWithoutWellnessSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWellnessSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWellnessSessionsInput, UserUncheckedUpdateWithoutWellnessSessionsInput>
  }

  export type UserUpdateWithoutWellnessSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: BoolFieldUpdateOperationsInput | boolean
    biometricSyncEnabled?: BoolFieldUpdateOperationsInput | boolean
    baseStressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    sleepGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    stepsGoal?: NullableIntFieldUpdateOperationsInput | number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUpdateManyWithoutUserNestedInput
    account?: AccountUpdateOneWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    habits?: HabitUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    biometricData?: BiometricDataUpdateManyWithoutUserNestedInput
    moodEntries?: MoodEntryUpdateManyWithoutUserNestedInput
    stressPredictions?: StressPredictionUpdateManyWithoutUserNestedInput
    challengeParticipants?: ChallengeParticipantUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUpdateManyWithoutUserNestedInput
    deviceConnections?: DeviceConnectionUpdateManyWithoutUserNestedInput
    environmentalData?: EnvironmentalDataUpdateManyWithoutUserNestedInput
    collaborativeGroups?: GroupMembershipUpdateManyWithoutUserNestedInput
    workplaceIntegrations?: WorkplaceIntegrationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWellnessSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: BoolFieldUpdateOperationsInput | boolean
    biometricSyncEnabled?: BoolFieldUpdateOperationsInput | boolean
    baseStressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    sleepGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    stepsGoal?: NullableIntFieldUpdateOperationsInput | number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    account?: AccountUncheckedUpdateOneWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    habits?: HabitUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    biometricData?: BiometricDataUncheckedUpdateManyWithoutUserNestedInput
    moodEntries?: MoodEntryUncheckedUpdateManyWithoutUserNestedInput
    stressPredictions?: StressPredictionUncheckedUpdateManyWithoutUserNestedInput
    challengeParticipants?: ChallengeParticipantUncheckedUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutUserNestedInput
    deviceConnections?: DeviceConnectionUncheckedUpdateManyWithoutUserNestedInput
    environmentalData?: EnvironmentalDataUncheckedUpdateManyWithoutUserNestedInput
    collaborativeGroups?: GroupMembershipUncheckedUpdateManyWithoutUserNestedInput
    workplaceIntegrations?: WorkplaceIntegrationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutEnvironmentalDataInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timezone?: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: boolean
    biometricSyncEnabled?: boolean
    baseStressLevel?: number | null
    sleepGoal?: number | null
    stepsGoal?: number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionCreateNestedManyWithoutUserInput
    account?: AccountCreateNestedOneWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    habits?: HabitCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    biometricData?: BiometricDataCreateNestedManyWithoutUserInput
    moodEntries?: MoodEntryCreateNestedManyWithoutUserInput
    stressPredictions?: StressPredictionCreateNestedManyWithoutUserInput
    challengeParticipants?: ChallengeParticipantCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutUserInput
    deviceConnections?: DeviceConnectionCreateNestedManyWithoutUserInput
    wellnessSessions?: WellnessSessionCreateNestedManyWithoutUserInput
    collaborativeGroups?: GroupMembershipCreateNestedManyWithoutUserInput
    workplaceIntegrations?: WorkplaceIntegrationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEnvironmentalDataInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timezone?: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: boolean
    biometricSyncEnabled?: boolean
    baseStressLevel?: number | null
    sleepGoal?: number | null
    stepsGoal?: number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    account?: AccountUncheckedCreateNestedOneWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    habits?: HabitUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    biometricData?: BiometricDataUncheckedCreateNestedManyWithoutUserInput
    moodEntries?: MoodEntryUncheckedCreateNestedManyWithoutUserInput
    stressPredictions?: StressPredictionUncheckedCreateNestedManyWithoutUserInput
    challengeParticipants?: ChallengeParticipantUncheckedCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutUserInput
    deviceConnections?: DeviceConnectionUncheckedCreateNestedManyWithoutUserInput
    wellnessSessions?: WellnessSessionUncheckedCreateNestedManyWithoutUserInput
    collaborativeGroups?: GroupMembershipUncheckedCreateNestedManyWithoutUserInput
    workplaceIntegrations?: WorkplaceIntegrationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEnvironmentalDataInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEnvironmentalDataInput, UserUncheckedCreateWithoutEnvironmentalDataInput>
  }

  export type UserUpsertWithoutEnvironmentalDataInput = {
    update: XOR<UserUpdateWithoutEnvironmentalDataInput, UserUncheckedUpdateWithoutEnvironmentalDataInput>
    create: XOR<UserCreateWithoutEnvironmentalDataInput, UserUncheckedCreateWithoutEnvironmentalDataInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEnvironmentalDataInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEnvironmentalDataInput, UserUncheckedUpdateWithoutEnvironmentalDataInput>
  }

  export type UserUpdateWithoutEnvironmentalDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: BoolFieldUpdateOperationsInput | boolean
    biometricSyncEnabled?: BoolFieldUpdateOperationsInput | boolean
    baseStressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    sleepGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    stepsGoal?: NullableIntFieldUpdateOperationsInput | number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUpdateManyWithoutUserNestedInput
    account?: AccountUpdateOneWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    habits?: HabitUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    biometricData?: BiometricDataUpdateManyWithoutUserNestedInput
    moodEntries?: MoodEntryUpdateManyWithoutUserNestedInput
    stressPredictions?: StressPredictionUpdateManyWithoutUserNestedInput
    challengeParticipants?: ChallengeParticipantUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUpdateManyWithoutUserNestedInput
    deviceConnections?: DeviceConnectionUpdateManyWithoutUserNestedInput
    wellnessSessions?: WellnessSessionUpdateManyWithoutUserNestedInput
    collaborativeGroups?: GroupMembershipUpdateManyWithoutUserNestedInput
    workplaceIntegrations?: WorkplaceIntegrationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEnvironmentalDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: BoolFieldUpdateOperationsInput | boolean
    biometricSyncEnabled?: BoolFieldUpdateOperationsInput | boolean
    baseStressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    sleepGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    stepsGoal?: NullableIntFieldUpdateOperationsInput | number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    account?: AccountUncheckedUpdateOneWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    habits?: HabitUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    biometricData?: BiometricDataUncheckedUpdateManyWithoutUserNestedInput
    moodEntries?: MoodEntryUncheckedUpdateManyWithoutUserNestedInput
    stressPredictions?: StressPredictionUncheckedUpdateManyWithoutUserNestedInput
    challengeParticipants?: ChallengeParticipantUncheckedUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutUserNestedInput
    deviceConnections?: DeviceConnectionUncheckedUpdateManyWithoutUserNestedInput
    wellnessSessions?: WellnessSessionUncheckedUpdateManyWithoutUserNestedInput
    collaborativeGroups?: GroupMembershipUncheckedUpdateManyWithoutUserNestedInput
    workplaceIntegrations?: WorkplaceIntegrationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type GroupMembershipCreateWithoutGroupInput = {
    id?: string
    role?: string
    shareProgress?: boolean
    shareGoals?: boolean
    joinedAt?: Date | string
    user: UserCreateNestedOneWithoutCollaborativeGroupsInput
  }

  export type GroupMembershipUncheckedCreateWithoutGroupInput = {
    id?: string
    userId: string
    role?: string
    shareProgress?: boolean
    shareGoals?: boolean
    joinedAt?: Date | string
  }

  export type GroupMembershipCreateOrConnectWithoutGroupInput = {
    where: GroupMembershipWhereUniqueInput
    create: XOR<GroupMembershipCreateWithoutGroupInput, GroupMembershipUncheckedCreateWithoutGroupInput>
  }

  export type GroupMembershipCreateManyGroupInputEnvelope = {
    data: GroupMembershipCreateManyGroupInput | GroupMembershipCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type GroupMembershipUpsertWithWhereUniqueWithoutGroupInput = {
    where: GroupMembershipWhereUniqueInput
    update: XOR<GroupMembershipUpdateWithoutGroupInput, GroupMembershipUncheckedUpdateWithoutGroupInput>
    create: XOR<GroupMembershipCreateWithoutGroupInput, GroupMembershipUncheckedCreateWithoutGroupInput>
  }

  export type GroupMembershipUpdateWithWhereUniqueWithoutGroupInput = {
    where: GroupMembershipWhereUniqueInput
    data: XOR<GroupMembershipUpdateWithoutGroupInput, GroupMembershipUncheckedUpdateWithoutGroupInput>
  }

  export type GroupMembershipUpdateManyWithWhereWithoutGroupInput = {
    where: GroupMembershipScalarWhereInput
    data: XOR<GroupMembershipUpdateManyMutationInput, GroupMembershipUncheckedUpdateManyWithoutGroupInput>
  }

  export type UserCreateWithoutCollaborativeGroupsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timezone?: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: boolean
    biometricSyncEnabled?: boolean
    baseStressLevel?: number | null
    sleepGoal?: number | null
    stepsGoal?: number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionCreateNestedManyWithoutUserInput
    account?: AccountCreateNestedOneWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    habits?: HabitCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    biometricData?: BiometricDataCreateNestedManyWithoutUserInput
    moodEntries?: MoodEntryCreateNestedManyWithoutUserInput
    stressPredictions?: StressPredictionCreateNestedManyWithoutUserInput
    challengeParticipants?: ChallengeParticipantCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutUserInput
    deviceConnections?: DeviceConnectionCreateNestedManyWithoutUserInput
    wellnessSessions?: WellnessSessionCreateNestedManyWithoutUserInput
    environmentalData?: EnvironmentalDataCreateNestedManyWithoutUserInput
    workplaceIntegrations?: WorkplaceIntegrationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCollaborativeGroupsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timezone?: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: boolean
    biometricSyncEnabled?: boolean
    baseStressLevel?: number | null
    sleepGoal?: number | null
    stepsGoal?: number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    account?: AccountUncheckedCreateNestedOneWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    habits?: HabitUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    biometricData?: BiometricDataUncheckedCreateNestedManyWithoutUserInput
    moodEntries?: MoodEntryUncheckedCreateNestedManyWithoutUserInput
    stressPredictions?: StressPredictionUncheckedCreateNestedManyWithoutUserInput
    challengeParticipants?: ChallengeParticipantUncheckedCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutUserInput
    deviceConnections?: DeviceConnectionUncheckedCreateNestedManyWithoutUserInput
    wellnessSessions?: WellnessSessionUncheckedCreateNestedManyWithoutUserInput
    environmentalData?: EnvironmentalDataUncheckedCreateNestedManyWithoutUserInput
    workplaceIntegrations?: WorkplaceIntegrationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCollaborativeGroupsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCollaborativeGroupsInput, UserUncheckedCreateWithoutCollaborativeGroupsInput>
  }

  export type WellnessGroupCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    isPublic?: boolean
    maxMembers?: number | null
    groupGoals?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WellnessGroupUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    isPublic?: boolean
    maxMembers?: number | null
    groupGoals?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WellnessGroupCreateOrConnectWithoutMembersInput = {
    where: WellnessGroupWhereUniqueInput
    create: XOR<WellnessGroupCreateWithoutMembersInput, WellnessGroupUncheckedCreateWithoutMembersInput>
  }

  export type UserUpsertWithoutCollaborativeGroupsInput = {
    update: XOR<UserUpdateWithoutCollaborativeGroupsInput, UserUncheckedUpdateWithoutCollaborativeGroupsInput>
    create: XOR<UserCreateWithoutCollaborativeGroupsInput, UserUncheckedCreateWithoutCollaborativeGroupsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCollaborativeGroupsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCollaborativeGroupsInput, UserUncheckedUpdateWithoutCollaborativeGroupsInput>
  }

  export type UserUpdateWithoutCollaborativeGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: BoolFieldUpdateOperationsInput | boolean
    biometricSyncEnabled?: BoolFieldUpdateOperationsInput | boolean
    baseStressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    sleepGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    stepsGoal?: NullableIntFieldUpdateOperationsInput | number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUpdateManyWithoutUserNestedInput
    account?: AccountUpdateOneWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    habits?: HabitUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    biometricData?: BiometricDataUpdateManyWithoutUserNestedInput
    moodEntries?: MoodEntryUpdateManyWithoutUserNestedInput
    stressPredictions?: StressPredictionUpdateManyWithoutUserNestedInput
    challengeParticipants?: ChallengeParticipantUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUpdateManyWithoutUserNestedInput
    deviceConnections?: DeviceConnectionUpdateManyWithoutUserNestedInput
    wellnessSessions?: WellnessSessionUpdateManyWithoutUserNestedInput
    environmentalData?: EnvironmentalDataUpdateManyWithoutUserNestedInput
    workplaceIntegrations?: WorkplaceIntegrationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCollaborativeGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: BoolFieldUpdateOperationsInput | boolean
    biometricSyncEnabled?: BoolFieldUpdateOperationsInput | boolean
    baseStressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    sleepGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    stepsGoal?: NullableIntFieldUpdateOperationsInput | number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    account?: AccountUncheckedUpdateOneWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    habits?: HabitUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    biometricData?: BiometricDataUncheckedUpdateManyWithoutUserNestedInput
    moodEntries?: MoodEntryUncheckedUpdateManyWithoutUserNestedInput
    stressPredictions?: StressPredictionUncheckedUpdateManyWithoutUserNestedInput
    challengeParticipants?: ChallengeParticipantUncheckedUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutUserNestedInput
    deviceConnections?: DeviceConnectionUncheckedUpdateManyWithoutUserNestedInput
    wellnessSessions?: WellnessSessionUncheckedUpdateManyWithoutUserNestedInput
    environmentalData?: EnvironmentalDataUncheckedUpdateManyWithoutUserNestedInput
    workplaceIntegrations?: WorkplaceIntegrationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WellnessGroupUpsertWithoutMembersInput = {
    update: XOR<WellnessGroupUpdateWithoutMembersInput, WellnessGroupUncheckedUpdateWithoutMembersInput>
    create: XOR<WellnessGroupCreateWithoutMembersInput, WellnessGroupUncheckedCreateWithoutMembersInput>
    where?: WellnessGroupWhereInput
  }

  export type WellnessGroupUpdateToOneWithWhereWithoutMembersInput = {
    where?: WellnessGroupWhereInput
    data: XOR<WellnessGroupUpdateWithoutMembersInput, WellnessGroupUncheckedUpdateWithoutMembersInput>
  }

  export type WellnessGroupUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    maxMembers?: NullableIntFieldUpdateOperationsInput | number | null
    groupGoals?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WellnessGroupUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    maxMembers?: NullableIntFieldUpdateOperationsInput | number | null
    groupGoals?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutWorkplaceIntegrationsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timezone?: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: boolean
    biometricSyncEnabled?: boolean
    baseStressLevel?: number | null
    sleepGoal?: number | null
    stepsGoal?: number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionCreateNestedManyWithoutUserInput
    account?: AccountCreateNestedOneWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    habits?: HabitCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    biometricData?: BiometricDataCreateNestedManyWithoutUserInput
    moodEntries?: MoodEntryCreateNestedManyWithoutUserInput
    stressPredictions?: StressPredictionCreateNestedManyWithoutUserInput
    challengeParticipants?: ChallengeParticipantCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutUserInput
    deviceConnections?: DeviceConnectionCreateNestedManyWithoutUserInput
    wellnessSessions?: WellnessSessionCreateNestedManyWithoutUserInput
    environmentalData?: EnvironmentalDataCreateNestedManyWithoutUserInput
    collaborativeGroups?: GroupMembershipCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWorkplaceIntegrationsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timezone?: string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: boolean
    biometricSyncEnabled?: boolean
    baseStressLevel?: number | null
    sleepGoal?: number | null
    stepsGoal?: number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    account?: AccountUncheckedCreateNestedOneWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    habits?: HabitUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    biometricData?: BiometricDataUncheckedCreateNestedManyWithoutUserInput
    moodEntries?: MoodEntryUncheckedCreateNestedManyWithoutUserInput
    stressPredictions?: StressPredictionUncheckedCreateNestedManyWithoutUserInput
    challengeParticipants?: ChallengeParticipantUncheckedCreateNestedManyWithoutUserInput
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutUserInput
    deviceConnections?: DeviceConnectionUncheckedCreateNestedManyWithoutUserInput
    wellnessSessions?: WellnessSessionUncheckedCreateNestedManyWithoutUserInput
    environmentalData?: EnvironmentalDataUncheckedCreateNestedManyWithoutUserInput
    collaborativeGroups?: GroupMembershipUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWorkplaceIntegrationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWorkplaceIntegrationsInput, UserUncheckedCreateWithoutWorkplaceIntegrationsInput>
  }

  export type UserUpsertWithoutWorkplaceIntegrationsInput = {
    update: XOR<UserUpdateWithoutWorkplaceIntegrationsInput, UserUncheckedUpdateWithoutWorkplaceIntegrationsInput>
    create: XOR<UserCreateWithoutWorkplaceIntegrationsInput, UserUncheckedCreateWithoutWorkplaceIntegrationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWorkplaceIntegrationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWorkplaceIntegrationsInput, UserUncheckedUpdateWithoutWorkplaceIntegrationsInput>
  }

  export type UserUpdateWithoutWorkplaceIntegrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: BoolFieldUpdateOperationsInput | boolean
    biometricSyncEnabled?: BoolFieldUpdateOperationsInput | boolean
    baseStressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    sleepGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    stepsGoal?: NullableIntFieldUpdateOperationsInput | number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUpdateManyWithoutUserNestedInput
    account?: AccountUpdateOneWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    habits?: HabitUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    biometricData?: BiometricDataUpdateManyWithoutUserNestedInput
    moodEntries?: MoodEntryUpdateManyWithoutUserNestedInput
    stressPredictions?: StressPredictionUpdateManyWithoutUserNestedInput
    challengeParticipants?: ChallengeParticipantUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUpdateManyWithoutUserNestedInput
    deviceConnections?: DeviceConnectionUpdateManyWithoutUserNestedInput
    wellnessSessions?: WellnessSessionUpdateManyWithoutUserNestedInput
    environmentalData?: EnvironmentalDataUpdateManyWithoutUserNestedInput
    collaborativeGroups?: GroupMembershipUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWorkplaceIntegrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
    preferences?: NullableJsonNullValueInput | InputJsonValue
    aiCoachEnabled?: BoolFieldUpdateOperationsInput | boolean
    biometricSyncEnabled?: BoolFieldUpdateOperationsInput | boolean
    baseStressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    sleepGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    stepsGoal?: NullableIntFieldUpdateOperationsInput | number | null
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    personalityProfile?: NullableJsonNullValueInput | InputJsonValue
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    account?: AccountUncheckedUpdateOneWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    habits?: HabitUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    biometricData?: BiometricDataUncheckedUpdateManyWithoutUserNestedInput
    moodEntries?: MoodEntryUncheckedUpdateManyWithoutUserNestedInput
    stressPredictions?: StressPredictionUncheckedUpdateManyWithoutUserNestedInput
    challengeParticipants?: ChallengeParticipantUncheckedUpdateManyWithoutUserNestedInput
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutUserNestedInput
    deviceConnections?: DeviceConnectionUncheckedUpdateManyWithoutUserNestedInput
    wellnessSessions?: WellnessSessionUncheckedUpdateManyWithoutUserNestedInput
    environmentalData?: EnvironmentalDataUncheckedUpdateManyWithoutUserNestedInput
    collaborativeGroups?: GroupMembershipUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SessionCreateManyUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JournalEntryCreateManyUserInput = {
    id?: string
    content: string
    date: Date | string
    mood?: string | null
    stressLevel?: number | null
    emotionScores?: NullableJsonNullValueInput | InputJsonValue
    topics?: NullableJsonNullValueInput | InputJsonValue
    sentiment?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HabitCreateManyUserInput = {
    id?: string
    title: string
    isCompleted?: boolean
    date: Date | string
    aiSuggested?: boolean
    adaptiveReminder?: NullableJsonNullValueInput | InputJsonValue
    difficultyLevel?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingCreateManyUserInput = {
    id?: string
    classId: string
    aiSuggested?: boolean
    predictedEffectiveness?: number | null
    createdAt?: Date | string
  }

  export type BiometricDataCreateManyUserInput = {
    id?: string
    heartRate?: number | null
    heartRateVariability?: number | null
    stressLevel?: number | null
    sleepQuality?: number | null
    sleepDuration?: number | null
    steps?: number | null
    calories?: number | null
    respiratoryRate?: number | null
    skinTemperature?: number | null
    bloodPressureSystolic?: number | null
    bloodPressureDiastolic?: number | null
    oxygenSaturation?: number | null
    wellnessScore?: number | null
    energyLevel?: number | null
    recoveryScore?: number | null
    deviceType?: string | null
    deviceId?: string | null
    accuracy?: number | null
    timestamp?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MoodEntryCreateManyUserInput = {
    id?: string
    mood: string
    confidence: number
    source: string
    emotions?: NullableJsonNullValueInput | InputJsonValue
    valence?: number | null
    arousal?: number | null
    location?: string | null
    weather?: string | null
    timeOfDay?: string | null
    activity?: string | null
    voiceFeatures?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StressPredictionCreateManyUserInput = {
    id?: string
    predictedStressLevel: number
    confidence: number
    predictedAt: Date | string
    modelVersion?: string | null
    triggers?: NullableJsonNullValueInput | InputJsonValue
    riskFactors?: NullableJsonNullValueInput | InputJsonValue
    recommendedInterventions?: NullableJsonNullValueInput | InputJsonValue
    preventionStrategies?: NullableJsonNullValueInput | InputJsonValue
    actualStressLevel?: number | null
    wasAccurate?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChallengeParticipantCreateManyUserInput = {
    id?: string
    challengeId: string
    progress: JsonNullValueInput | InputJsonValue
    completed?: boolean
    currentStreak?: number
    bestStreak?: number
    rank?: number | null
    joinedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type AIRecommendationCreateManyUserInput = {
    id?: string
    type: string
    title: string
    description: string
    priority: number
    reasoning: string
    actionUrl?: string | null
    duration?: number | null
    intensity?: string | null
    triggeredBy?: NullableJsonNullValueInput | InputJsonValue
    biometricState?: NullableJsonNullValueInput | InputJsonValue
    effectivenessScore?: number | null
    isRead?: boolean
    isCompleted?: boolean
    createdAt?: Date | string
    expiresAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type DeviceConnectionCreateManyUserInput = {
    id?: string
    deviceType: string
    deviceId: string
    deviceName?: string | null
    isConnected?: boolean
    lastSync?: Date | string | null
    syncInterval?: number | null
    reliability?: number | null
    batteryLevel?: number | null
    signalStrength?: number | null
    permissions: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WellnessSessionCreateManyUserInput = {
    id?: string
    sessionType: string
    title: string
    duration: number
    startingStress?: number | null
    endingStress?: number | null
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    avgHeartRate?: number | null
    stressReduction?: number | null
    userRating?: number | null
    completionRate?: number | null
    startedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type EnvironmentalDataCreateManyUserInput = {
    id?: string
    location?: string | null
    timezone?: string | null
    temperature?: number | null
    humidity?: number | null
    pressure?: number | null
    weather?: string | null
    airQuality?: number | null
    pollutants?: NullableJsonNullValueInput | InputJsonValue
    lightLevel?: number | null
    uvIndex?: number | null
    noiseLevel?: number | null
    timestamp?: Date | string
  }

  export type GroupMembershipCreateManyUserInput = {
    id?: string
    groupId: string
    role?: string
    shareProgress?: boolean
    shareGoals?: boolean
    joinedAt?: Date | string
  }

  export type WorkplaceIntegrationCreateManyUserInput = {
    id?: string
    platform: string
    enabled?: boolean
    frequency?: string
    canSuggestBreaks?: boolean
    canAccessCalendar?: boolean
    canSendReminders?: boolean
    workHours?: NullableJsonNullValueInput | InputJsonValue
    breakPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalEntryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    mood?: NullableStringFieldUpdateOperationsInput | string | null
    stressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    emotionScores?: NullableJsonNullValueInput | InputJsonValue
    topics?: NullableJsonNullValueInput | InputJsonValue
    sentiment?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalEntryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    mood?: NullableStringFieldUpdateOperationsInput | string | null
    stressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    emotionScores?: NullableJsonNullValueInput | InputJsonValue
    topics?: NullableJsonNullValueInput | InputJsonValue
    sentiment?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalEntryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    mood?: NullableStringFieldUpdateOperationsInput | string | null
    stressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    emotionScores?: NullableJsonNullValueInput | InputJsonValue
    topics?: NullableJsonNullValueInput | InputJsonValue
    sentiment?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HabitUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    aiSuggested?: BoolFieldUpdateOperationsInput | boolean
    adaptiveReminder?: NullableJsonNullValueInput | InputJsonValue
    difficultyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HabitUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    aiSuggested?: BoolFieldUpdateOperationsInput | boolean
    adaptiveReminder?: NullableJsonNullValueInput | InputJsonValue
    difficultyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HabitUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    aiSuggested?: BoolFieldUpdateOperationsInput | boolean
    adaptiveReminder?: NullableJsonNullValueInput | InputJsonValue
    difficultyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    aiSuggested?: BoolFieldUpdateOperationsInput | boolean
    predictedEffectiveness?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type BookingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    aiSuggested?: BoolFieldUpdateOperationsInput | boolean
    predictedEffectiveness?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    aiSuggested?: BoolFieldUpdateOperationsInput | boolean
    predictedEffectiveness?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BiometricDataUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    heartRateVariability?: NullableFloatFieldUpdateOperationsInput | number | null
    stressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    sleepQuality?: NullableIntFieldUpdateOperationsInput | number | null
    sleepDuration?: NullableFloatFieldUpdateOperationsInput | number | null
    steps?: NullableIntFieldUpdateOperationsInput | number | null
    calories?: NullableIntFieldUpdateOperationsInput | number | null
    respiratoryRate?: NullableIntFieldUpdateOperationsInput | number | null
    skinTemperature?: NullableFloatFieldUpdateOperationsInput | number | null
    bloodPressureSystolic?: NullableIntFieldUpdateOperationsInput | number | null
    bloodPressureDiastolic?: NullableIntFieldUpdateOperationsInput | number | null
    oxygenSaturation?: NullableFloatFieldUpdateOperationsInput | number | null
    wellnessScore?: NullableFloatFieldUpdateOperationsInput | number | null
    energyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    recoveryScore?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BiometricDataUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    heartRateVariability?: NullableFloatFieldUpdateOperationsInput | number | null
    stressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    sleepQuality?: NullableIntFieldUpdateOperationsInput | number | null
    sleepDuration?: NullableFloatFieldUpdateOperationsInput | number | null
    steps?: NullableIntFieldUpdateOperationsInput | number | null
    calories?: NullableIntFieldUpdateOperationsInput | number | null
    respiratoryRate?: NullableIntFieldUpdateOperationsInput | number | null
    skinTemperature?: NullableFloatFieldUpdateOperationsInput | number | null
    bloodPressureSystolic?: NullableIntFieldUpdateOperationsInput | number | null
    bloodPressureDiastolic?: NullableIntFieldUpdateOperationsInput | number | null
    oxygenSaturation?: NullableFloatFieldUpdateOperationsInput | number | null
    wellnessScore?: NullableFloatFieldUpdateOperationsInput | number | null
    energyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    recoveryScore?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BiometricDataUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    heartRateVariability?: NullableFloatFieldUpdateOperationsInput | number | null
    stressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    sleepQuality?: NullableIntFieldUpdateOperationsInput | number | null
    sleepDuration?: NullableFloatFieldUpdateOperationsInput | number | null
    steps?: NullableIntFieldUpdateOperationsInput | number | null
    calories?: NullableIntFieldUpdateOperationsInput | number | null
    respiratoryRate?: NullableIntFieldUpdateOperationsInput | number | null
    skinTemperature?: NullableFloatFieldUpdateOperationsInput | number | null
    bloodPressureSystolic?: NullableIntFieldUpdateOperationsInput | number | null
    bloodPressureDiastolic?: NullableIntFieldUpdateOperationsInput | number | null
    oxygenSaturation?: NullableFloatFieldUpdateOperationsInput | number | null
    wellnessScore?: NullableFloatFieldUpdateOperationsInput | number | null
    energyLevel?: NullableIntFieldUpdateOperationsInput | number | null
    recoveryScore?: NullableFloatFieldUpdateOperationsInput | number | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MoodEntryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    mood?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    emotions?: NullableJsonNullValueInput | InputJsonValue
    valence?: NullableFloatFieldUpdateOperationsInput | number | null
    arousal?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    weather?: NullableStringFieldUpdateOperationsInput | string | null
    timeOfDay?: NullableStringFieldUpdateOperationsInput | string | null
    activity?: NullableStringFieldUpdateOperationsInput | string | null
    voiceFeatures?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MoodEntryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    mood?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    emotions?: NullableJsonNullValueInput | InputJsonValue
    valence?: NullableFloatFieldUpdateOperationsInput | number | null
    arousal?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    weather?: NullableStringFieldUpdateOperationsInput | string | null
    timeOfDay?: NullableStringFieldUpdateOperationsInput | string | null
    activity?: NullableStringFieldUpdateOperationsInput | string | null
    voiceFeatures?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MoodEntryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    mood?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    emotions?: NullableJsonNullValueInput | InputJsonValue
    valence?: NullableFloatFieldUpdateOperationsInput | number | null
    arousal?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    weather?: NullableStringFieldUpdateOperationsInput | string | null
    timeOfDay?: NullableStringFieldUpdateOperationsInput | string | null
    activity?: NullableStringFieldUpdateOperationsInput | string | null
    voiceFeatures?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StressPredictionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    predictedStressLevel?: IntFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    predictedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    triggers?: NullableJsonNullValueInput | InputJsonValue
    riskFactors?: NullableJsonNullValueInput | InputJsonValue
    recommendedInterventions?: NullableJsonNullValueInput | InputJsonValue
    preventionStrategies?: NullableJsonNullValueInput | InputJsonValue
    actualStressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    wasAccurate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StressPredictionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    predictedStressLevel?: IntFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    predictedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    triggers?: NullableJsonNullValueInput | InputJsonValue
    riskFactors?: NullableJsonNullValueInput | InputJsonValue
    recommendedInterventions?: NullableJsonNullValueInput | InputJsonValue
    preventionStrategies?: NullableJsonNullValueInput | InputJsonValue
    actualStressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    wasAccurate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StressPredictionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    predictedStressLevel?: IntFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    predictedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    triggers?: NullableJsonNullValueInput | InputJsonValue
    riskFactors?: NullableJsonNullValueInput | InputJsonValue
    recommendedInterventions?: NullableJsonNullValueInput | InputJsonValue
    preventionStrategies?: NullableJsonNullValueInput | InputJsonValue
    actualStressLevel?: NullableIntFieldUpdateOperationsInput | number | null
    wasAccurate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeParticipantUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: JsonNullValueInput | InputJsonValue
    completed?: BoolFieldUpdateOperationsInput | boolean
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    challenge?: WellnessChallengeUpdateOneRequiredWithoutParticipantsNestedInput
  }

  export type ChallengeParticipantUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    progress?: JsonNullValueInput | InputJsonValue
    completed?: BoolFieldUpdateOperationsInput | boolean
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChallengeParticipantUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    progress?: JsonNullValueInput | InputJsonValue
    completed?: BoolFieldUpdateOperationsInput | boolean
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AIRecommendationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    reasoning?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    intensity?: NullableStringFieldUpdateOperationsInput | string | null
    triggeredBy?: NullableJsonNullValueInput | InputJsonValue
    biometricState?: NullableJsonNullValueInput | InputJsonValue
    effectivenessScore?: NullableFloatFieldUpdateOperationsInput | number | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AIRecommendationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    reasoning?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    intensity?: NullableStringFieldUpdateOperationsInput | string | null
    triggeredBy?: NullableJsonNullValueInput | InputJsonValue
    biometricState?: NullableJsonNullValueInput | InputJsonValue
    effectivenessScore?: NullableFloatFieldUpdateOperationsInput | number | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AIRecommendationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    reasoning?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    intensity?: NullableStringFieldUpdateOperationsInput | string | null
    triggeredBy?: NullableJsonNullValueInput | InputJsonValue
    biometricState?: NullableJsonNullValueInput | InputJsonValue
    effectivenessScore?: NullableFloatFieldUpdateOperationsInput | number | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeviceConnectionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceType?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    isConnected?: BoolFieldUpdateOperationsInput | boolean
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncInterval?: NullableIntFieldUpdateOperationsInput | number | null
    reliability?: NullableFloatFieldUpdateOperationsInput | number | null
    batteryLevel?: NullableIntFieldUpdateOperationsInput | number | null
    signalStrength?: NullableFloatFieldUpdateOperationsInput | number | null
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceConnectionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceType?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    isConnected?: BoolFieldUpdateOperationsInput | boolean
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncInterval?: NullableIntFieldUpdateOperationsInput | number | null
    reliability?: NullableFloatFieldUpdateOperationsInput | number | null
    batteryLevel?: NullableIntFieldUpdateOperationsInput | number | null
    signalStrength?: NullableFloatFieldUpdateOperationsInput | number | null
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceConnectionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceType?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    isConnected?: BoolFieldUpdateOperationsInput | boolean
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncInterval?: NullableIntFieldUpdateOperationsInput | number | null
    reliability?: NullableFloatFieldUpdateOperationsInput | number | null
    batteryLevel?: NullableIntFieldUpdateOperationsInput | number | null
    signalStrength?: NullableFloatFieldUpdateOperationsInput | number | null
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WellnessSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    startingStress?: NullableIntFieldUpdateOperationsInput | number | null
    endingStress?: NullableIntFieldUpdateOperationsInput | number | null
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    avgHeartRate?: NullableIntFieldUpdateOperationsInput | number | null
    stressReduction?: NullableFloatFieldUpdateOperationsInput | number | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    completionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WellnessSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    startingStress?: NullableIntFieldUpdateOperationsInput | number | null
    endingStress?: NullableIntFieldUpdateOperationsInput | number | null
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    avgHeartRate?: NullableIntFieldUpdateOperationsInput | number | null
    stressReduction?: NullableFloatFieldUpdateOperationsInput | number | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    completionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WellnessSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    startingStress?: NullableIntFieldUpdateOperationsInput | number | null
    endingStress?: NullableIntFieldUpdateOperationsInput | number | null
    adaptations?: NullableJsonNullValueInput | InputJsonValue
    avgHeartRate?: NullableIntFieldUpdateOperationsInput | number | null
    stressReduction?: NullableFloatFieldUpdateOperationsInput | number | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    completionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EnvironmentalDataUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    humidity?: NullableFloatFieldUpdateOperationsInput | number | null
    pressure?: NullableFloatFieldUpdateOperationsInput | number | null
    weather?: NullableStringFieldUpdateOperationsInput | string | null
    airQuality?: NullableIntFieldUpdateOperationsInput | number | null
    pollutants?: NullableJsonNullValueInput | InputJsonValue
    lightLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    uvIndex?: NullableFloatFieldUpdateOperationsInput | number | null
    noiseLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnvironmentalDataUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    humidity?: NullableFloatFieldUpdateOperationsInput | number | null
    pressure?: NullableFloatFieldUpdateOperationsInput | number | null
    weather?: NullableStringFieldUpdateOperationsInput | string | null
    airQuality?: NullableIntFieldUpdateOperationsInput | number | null
    pollutants?: NullableJsonNullValueInput | InputJsonValue
    lightLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    uvIndex?: NullableFloatFieldUpdateOperationsInput | number | null
    noiseLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnvironmentalDataUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    humidity?: NullableFloatFieldUpdateOperationsInput | number | null
    pressure?: NullableFloatFieldUpdateOperationsInput | number | null
    weather?: NullableStringFieldUpdateOperationsInput | string | null
    airQuality?: NullableIntFieldUpdateOperationsInput | number | null
    pollutants?: NullableJsonNullValueInput | InputJsonValue
    lightLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    uvIndex?: NullableFloatFieldUpdateOperationsInput | number | null
    noiseLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMembershipUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    shareProgress?: BoolFieldUpdateOperationsInput | boolean
    shareGoals?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: WellnessGroupUpdateOneRequiredWithoutMembersNestedInput
  }

  export type GroupMembershipUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    shareProgress?: BoolFieldUpdateOperationsInput | boolean
    shareGoals?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMembershipUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    shareProgress?: BoolFieldUpdateOperationsInput | boolean
    shareGoals?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkplaceIntegrationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    frequency?: StringFieldUpdateOperationsInput | string
    canSuggestBreaks?: BoolFieldUpdateOperationsInput | boolean
    canAccessCalendar?: BoolFieldUpdateOperationsInput | boolean
    canSendReminders?: BoolFieldUpdateOperationsInput | boolean
    workHours?: NullableJsonNullValueInput | InputJsonValue
    breakPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkplaceIntegrationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    frequency?: StringFieldUpdateOperationsInput | string
    canSuggestBreaks?: BoolFieldUpdateOperationsInput | boolean
    canAccessCalendar?: BoolFieldUpdateOperationsInput | boolean
    canSendReminders?: BoolFieldUpdateOperationsInput | boolean
    workHours?: NullableJsonNullValueInput | InputJsonValue
    breakPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkplaceIntegrationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    frequency?: StringFieldUpdateOperationsInput | string
    canSuggestBreaks?: BoolFieldUpdateOperationsInput | boolean
    canAccessCalendar?: BoolFieldUpdateOperationsInput | boolean
    canSendReminders?: BoolFieldUpdateOperationsInput | boolean
    workHours?: NullableJsonNullValueInput | InputJsonValue
    breakPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateManyClassInput = {
    id?: string
    userId: string
    aiSuggested?: boolean
    predictedEffectiveness?: number | null
    createdAt?: Date | string
  }

  export type BookingUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    aiSuggested?: BoolFieldUpdateOperationsInput | boolean
    predictedEffectiveness?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type BookingUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    aiSuggested?: BoolFieldUpdateOperationsInput | boolean
    predictedEffectiveness?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    aiSuggested?: BoolFieldUpdateOperationsInput | boolean
    predictedEffectiveness?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeParticipantCreateManyChallengeInput = {
    id?: string
    userId: string
    progress: JsonNullValueInput | InputJsonValue
    completed?: boolean
    currentStreak?: number
    bestStreak?: number
    rank?: number | null
    joinedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type ChallengeParticipantUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: JsonNullValueInput | InputJsonValue
    completed?: BoolFieldUpdateOperationsInput | boolean
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutChallengeParticipantsNestedInput
  }

  export type ChallengeParticipantUncheckedUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    progress?: JsonNullValueInput | InputJsonValue
    completed?: BoolFieldUpdateOperationsInput | boolean
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChallengeParticipantUncheckedUpdateManyWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    progress?: JsonNullValueInput | InputJsonValue
    completed?: BoolFieldUpdateOperationsInput | boolean
    currentStreak?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GroupMembershipCreateManyGroupInput = {
    id?: string
    userId: string
    role?: string
    shareProgress?: boolean
    shareGoals?: boolean
    joinedAt?: Date | string
  }

  export type GroupMembershipUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    shareProgress?: BoolFieldUpdateOperationsInput | boolean
    shareGoals?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCollaborativeGroupsNestedInput
  }

  export type GroupMembershipUncheckedUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    shareProgress?: BoolFieldUpdateOperationsInput | boolean
    shareGoals?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMembershipUncheckedUpdateManyWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    shareProgress?: BoolFieldUpdateOperationsInput | boolean
    shareGoals?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}